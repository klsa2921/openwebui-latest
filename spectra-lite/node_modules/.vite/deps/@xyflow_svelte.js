import "./chunk-X7HCJ7ZS.js";
import {
  drag_default,
  identity,
  pointer_default,
  select_default,
  transform,
  zoom_default
} from "./chunk-LCJT65LD.js";
import "./chunk-AYNHEKRI.js";
import {
  derived,
  readable,
  writable
} from "./chunk-VGWTF5V2.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  get_svelte_dataset,
  globals,
  group_outros,
  hasContext,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  not_equal,
  null_to_empty,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  subscribe,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-ZUFKCA25.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-RDM5KK2T.js";

// node_modules/classcat/index.js
function cc(names) {
  if (typeof names === "string" || typeof names === "number") return "" + names;
  let out = "";
  if (Array.isArray(names)) {
    for (let i = 0, tmp; i < names.length; i++) {
      if ((tmp = cc(names[i])) !== "") {
        out += (out && " ") + tmp;
      }
    }
  } else {
    for (let k in names) {
      if (names[k]) out += (out && " ") + k;
    }
  }
  return out;
}

// node_modules/@xyflow/system/dist/esm/index.mjs
var errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id) => `The old edge with id=${id} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: "${handleType === "source" ? sourceHandle : targetHandle}", edge id: ${id}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id) => `Node with id "${id}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (lib = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`
};
var infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
];
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2["Strict"] = "strict";
  ConnectionMode2["Loose"] = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2["Free"] = "free";
  PanOnScrollMode2["Vertical"] = "vertical";
  PanOnScrollMode2["Horizontal"] = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2["Partial"] = "partial";
  SelectionMode2["Full"] = "full";
})(SelectionMode || (SelectionMode = {}));
var initialConnection = {
  inProgress: false,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2["Bezier"] = "default";
  ConnectionLineType2["Straight"] = "straight";
  ConnectionLineType2["Step"] = "step";
  ConnectionLineType2["SmoothStep"] = "smoothstep";
  ConnectionLineType2["SimpleBezier"] = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2["Arrow"] = "arrow";
  MarkerType2["ArrowClosed"] = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2["Left"] = "left";
  Position2["Top"] = "top";
  Position2["Right"] = "right";
  Position2["Bottom"] = "bottom";
})(Position || (Position = {}));
var oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
function areConnectionMapsEqual(a, b) {
  if (!a && !b) {
    return true;
  }
  if (!a || !b || a.size !== b.size) {
    return false;
  }
  if (!a.size && !b.size) {
    return true;
  }
  for (const key2 of a.keys()) {
    if (!b.has(key2)) {
      return false;
    }
  }
  return true;
}
function handleConnectionChange(a, b, cb) {
  if (!cb) {
    return;
  }
  const diff = [];
  a.forEach((connection, key2) => {
    if (!(b == null ? void 0 : b.has(key2))) {
      diff.push(connection);
    }
  });
  if (diff.length) {
    cb(diff);
  }
}
function getConnectionStatus(isValid) {
  return isValid === null ? null : isValid ? "valid" : "invalid";
}
var isEdgeBase = (element2) => "id" in element2 && "source" in element2 && "target" in element2;
var isNodeBase = (element2) => "id" in element2 && "position" in element2 && !("source" in element2) && !("target" in element2);
var isInternalNodeBase = (element2) => "id" in element2 && "internals" in element2 && !("source" in element2) && !("target" in element2);
var getOutgoers = (node, nodes, edges) => {
  if (!node.id) {
    return [];
  }
  const outgoerIds = /* @__PURE__ */ new Set();
  edges.forEach((edge) => {
    if (edge.source === node.id) {
      outgoerIds.add(edge.target);
    }
  });
  return nodes.filter((n) => outgoerIds.has(n.id));
};
var getIncomers = (node, nodes, edges) => {
  if (!node.id) {
    return [];
  }
  const incomersIds = /* @__PURE__ */ new Set();
  edges.forEach((edge) => {
    if (edge.target === node.id) {
      incomersIds.add(edge.source);
    }
  });
  return nodes.filter((n) => incomersIds.has(n.id));
};
var getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {
  const { width, height } = getNodeDimensions(node);
  const origin = node.origin ?? nodeOrigin;
  const offsetX = width * origin[0];
  const offsetY = height * origin[1];
  return {
    x: node.position.x - offsetX,
    y: node.position.y - offsetY
  };
};
var getNodesBounds = (nodes, params = { nodeOrigin: [0, 0], nodeLookup: void 0 }) => {
  if (!params.nodeLookup) {
    console.warn("Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.");
  }
  if (nodes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  const box = nodes.reduce((currBox, nodeOrId) => {
    const isId = typeof nodeOrId === "string";
    let currentNode = !params.nodeLookup && !isId ? nodeOrId : void 0;
    if (params.nodeLookup) {
      currentNode = isId ? params.nodeLookup.get(nodeOrId) : !isInternalNodeBase(nodeOrId) ? params.nodeLookup.get(nodeOrId.id) : nodeOrId;
    }
    const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return getBoundsOfBoxes(currBox, nodeBox);
  }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });
  return boxToRect(box);
};
var getInternalNodesBounds = (nodeLookup, params = {}) => {
  if (nodeLookup.size === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };
  nodeLookup.forEach((node) => {
    if (params.filter === void 0 || params.filter(node)) {
      const nodeBox = nodeToBox(node);
      box = getBoundsOfBoxes(box, nodeBox);
    }
  });
  return boxToRect(box);
};
var getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, excludeNonSelectableNodes = false) => {
  const paneRect = {
    ...pointToRendererPoint(rect, [tx, ty, tScale]),
    width: rect.width / tScale,
    height: rect.height / tScale
  };
  const visibleNodes = [];
  for (const node of nodes.values()) {
    const { measured, selectable = true, hidden = false } = node;
    if (excludeNonSelectableNodes && !selectable || hidden) {
      continue;
    }
    const width = measured.width ?? node.width ?? node.initialWidth ?? null;
    const height = measured.height ?? node.height ?? node.initialHeight ?? null;
    const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));
    const area = (width ?? 0) * (height ?? 0);
    const partiallyVisible = partially && overlappingArea > 0;
    const forceInitialRender = !node.internals.handleBounds;
    const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;
    if (isVisible || node.dragging) {
      visibleNodes.push(node);
    }
  }
  return visibleNodes;
};
var getConnectedEdges = (nodes, edges) => {
  const nodeIds = /* @__PURE__ */ new Set();
  nodes.forEach((node) => {
    nodeIds.add(node.id);
  });
  return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
};
function getFitViewNodes(nodeLookup, options) {
  const fitViewNodes = /* @__PURE__ */ new Map();
  const optionNodeIds = (options == null ? void 0 : options.nodes) ? new Set(options.nodes.map((node) => node.id)) : null;
  nodeLookup.forEach((n) => {
    const isVisible = n.measured.width && n.measured.height && ((options == null ? void 0 : options.includeHiddenNodes) || !n.hidden);
    if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {
      fitViewNodes.set(n.id, n);
    }
  });
  return fitViewNodes;
}
async function fitView({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {
  if (nodes.size === 0) {
    return Promise.resolve(false);
  }
  const bounds = getInternalNodesBounds(nodes);
  const viewport = getViewportForBounds(bounds, width, height, (options == null ? void 0 : options.minZoom) ?? minZoom, (options == null ? void 0 : options.maxZoom) ?? maxZoom, (options == null ? void 0 : options.padding) ?? 0.1);
  await panZoom.setViewport(viewport, { duration: options == null ? void 0 : options.duration });
  return Promise.resolve(true);
}
function calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError }) {
  const node = nodeLookup.get(nodeId);
  const parentNode = node.parentId ? nodeLookup.get(node.parentId) : void 0;
  const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };
  const origin = node.origin ?? nodeOrigin;
  let extent = nodeExtent;
  if (node.extent === "parent" && !node.expandParent) {
    if (!parentNode) {
      onError == null ? void 0 : onError("005", errorMessages["error005"]());
    } else {
      const parentWidth = parentNode.measured.width;
      const parentHeight = parentNode.measured.height;
      if (parentWidth && parentHeight) {
        extent = [
          [parentX, parentY],
          [parentX + parentWidth, parentY + parentHeight]
        ];
      }
    }
  } else if (parentNode && isCoordinateExtent(node.extent)) {
    extent = [
      [node.extent[0][0] + parentX, node.extent[0][1] + parentY],
      [node.extent[1][0] + parentX, node.extent[1][1] + parentY]
    ];
  }
  const positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node.measured) : nextPosition;
  return {
    position: {
      x: positionAbsolute.x - parentX + node.measured.width * origin[0],
      y: positionAbsolute.y - parentY + node.measured.height * origin[1]
    },
    positionAbsolute
  };
}
async function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete }) {
  const nodeIds = new Set(nodesToRemove.map((node) => node.id));
  const matchingNodes = [];
  for (const node of nodes) {
    if (node.deletable === false) {
      continue;
    }
    const isIncluded = nodeIds.has(node.id);
    const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);
    if (isIncluded || parentHit) {
      matchingNodes.push(node);
    }
  }
  const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));
  const deletableEdges = edges.filter((edge) => edge.deletable !== false);
  const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);
  const matchingEdges = connectedEdges;
  for (const edge of deletableEdges) {
    const isIncluded = edgeIds.has(edge.id);
    if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {
      matchingEdges.push(edge);
    }
  }
  if (!onBeforeDelete) {
    return {
      edges: matchingEdges,
      nodes: matchingNodes
    };
  }
  const onBeforeDeleteResult = await onBeforeDelete({
    nodes: matchingNodes,
    edges: matchingEdges
  });
  if (typeof onBeforeDeleteResult === "boolean") {
    return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };
  }
  return onBeforeDeleteResult;
}
var clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);
var clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({
  x: clamp(position.x, extent[0][0], extent[1][0] - ((dimensions == null ? void 0 : dimensions.width) ?? 0)),
  y: clamp(position.y, extent[0][1], extent[1][1] - ((dimensions == null ? void 0 : dimensions.height) ?? 0))
});
function clampPositionToParent(childPosition, childDimensions, parent) {
  const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);
  const { x: parentX, y: parentY } = parent.internals.positionAbsolute;
  return clampPosition(childPosition, [
    [parentX, parentY],
    [parentX + parentWidth, parentY + parentHeight]
  ], childDimensions);
}
var calcAutoPanVelocity = (value, min, max) => {
  if (value < min) {
    return clamp(Math.abs(value - min), 1, min) / min;
  } else if (value > max) {
    return -clamp(Math.abs(value - max), 1, min) / min;
  }
  return 0;
};
var calcAutoPan = (pos, bounds, speed = 15, distance2 = 40) => {
  const xMovement = calcAutoPanVelocity(pos.x, distance2, bounds.width - distance2) * speed;
  const yMovement = calcAutoPanVelocity(pos.y, distance2, bounds.height - distance2) * speed;
  return [xMovement, yMovement];
};
var getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
});
var rectToBox = ({ x, y, width, height }) => ({
  x,
  y,
  x2: x + width,
  y2: y + height
});
var boxToRect = ({ x, y, x2, y2 }) => ({
  x,
  y,
  width: x2 - x,
  height: y2 - y
});
var nodeToRect = (node, nodeOrigin = [0, 0]) => {
  var _a, _b;
  const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x,
    y,
    width: ((_a = node.measured) == null ? void 0 : _a.width) ?? node.width ?? node.initialWidth ?? 0,
    height: ((_b = node.measured) == null ? void 0 : _b.height) ?? node.height ?? node.initialHeight ?? 0
  };
};
var nodeToBox = (node, nodeOrigin = [0, 0]) => {
  var _a, _b;
  const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x,
    y,
    x2: x + (((_a = node.measured) == null ? void 0 : _a.width) ?? node.width ?? node.initialWidth ?? 0),
    y2: y + (((_b = node.measured) == null ? void 0 : _b.height) ?? node.height ?? node.initialHeight ?? 0)
  };
};
var getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
var getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
};
var isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
var isNumeric = (n) => !isNaN(n) && isFinite(n);
var devWarn = (id, message) => {
  if (true) {
    console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);
  }
};
var snapPosition = (position, snapGrid = [1, 1]) => {
  return {
    x: snapGrid[0] * Math.round(position.x / snapGrid[0]),
    y: snapGrid[1] * Math.round(position.y / snapGrid[1])
  };
};
var pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {
  const position = {
    x: (x - tx) / tScale,
    y: (y - ty) / tScale
  };
  return snapToGrid ? snapPosition(position, snapGrid) : position;
};
var rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {
  return {
    x: x * tScale + tx,
    y: y * tScale + ty
  };
};
var getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {
  const xZoom = width / (bounds.width * (1 + padding));
  const yZoom = height / (bounds.height * (1 + padding));
  const zoom2 = Math.min(xZoom, yZoom);
  const clampedZoom = clamp(zoom2, minZoom, maxZoom);
  const boundsCenterX = bounds.x + bounds.width / 2;
  const boundsCenterY = bounds.y + bounds.height / 2;
  const x = width / 2 - boundsCenterX * clampedZoom;
  const y = height / 2 - boundsCenterY * clampedZoom;
  return { x, y, zoom: clampedZoom };
};
var isMacOs = () => {
  var _a;
  return typeof navigator !== "undefined" && ((_a = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a.indexOf("Mac")) >= 0;
};
function isCoordinateExtent(extent) {
  return extent !== void 0 && extent !== "parent";
}
function getNodeDimensions(node) {
  var _a, _b;
  return {
    width: ((_a = node.measured) == null ? void 0 : _a.width) ?? node.width ?? node.initialWidth ?? 0,
    height: ((_b = node.measured) == null ? void 0 : _b.height) ?? node.height ?? node.initialHeight ?? 0
  };
}
function nodeHasDimensions(node) {
  var _a, _b;
  return (((_a = node.measured) == null ? void 0 : _a.width) ?? node.width ?? node.initialWidth) !== void 0 && (((_b = node.measured) == null ? void 0 : _b.height) ?? node.height ?? node.initialHeight) !== void 0;
}
function evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {
  let nextParentId = parentId;
  const positionAbsolute = { ...position };
  while (nextParentId) {
    const parent = nodeLookup.get(nextParentId);
    nextParentId = parent == null ? void 0 : parent.parentId;
    if (parent) {
      const origin = parent.origin || nodeOrigin;
      positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];
      positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];
    }
  }
  return positionAbsolute;
}
function getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform: transform2 }) {
  const { x, y } = getEventPosition(event);
  const pointerPos = pointToRendererPoint({ x, y }, transform2);
  const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;
  return {
    xSnapped,
    ySnapped,
    ...pointerPos
  };
}
var getDimensions = (node) => ({
  width: node.offsetWidth,
  height: node.offsetHeight
});
var getHostForElement = (element2) => {
  var _a;
  return ((_a = element2.getRootNode) == null ? void 0 : _a.call(element2)) || (window == null ? void 0 : window.document);
};
var inputTags = ["INPUT", "SELECT", "TEXTAREA"];
function isInputDOMNode(event) {
  var _a, _b;
  const target = ((_b = (_a = event.composedPath) == null ? void 0 : _a.call(event)) == null ? void 0 : _b[0]) || event.target;
  const isInput = inputTags.includes(target == null ? void 0 : target.nodeName) || (target == null ? void 0 : target.hasAttribute("contenteditable"));
  return isInput || !!(target == null ? void 0 : target.closest(".nokey"));
}
var isMouseEvent = (event) => "clientX" in event;
var getEventPosition = (event, bounds) => {
  var _a, _b;
  const isMouse = isMouseEvent(event);
  const evtX = isMouse ? event.clientX : (_a = event.touches) == null ? void 0 : _a[0].clientX;
  const evtY = isMouse ? event.clientY : (_b = event.touches) == null ? void 0 : _b[0].clientY;
  return {
    x: evtX - ((bounds == null ? void 0 : bounds.left) ?? 0),
    y: evtY - ((bounds == null ? void 0 : bounds.top) ?? 0)
  };
};
var getHandleBounds = (type, nodeElement, nodeBounds, zoom2, nodeId) => {
  const handles = nodeElement.querySelectorAll(`.${type}`);
  if (!handles || !handles.length) {
    return null;
  }
  return Array.from(handles).map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      type,
      nodeId,
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left) / zoom2,
      y: (handleBounds.top - nodeBounds.top) / zoom2,
      ...getDimensions(handle)
    };
  });
};
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
  const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
  const offsetX = Math.abs(centerX - sourceX);
  const offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  if (distance2 >= 0) {
    return 0.5 * distance2;
  }
  return curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  });
  const [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  });
  const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2;
  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  const yOffset = Math.abs(targetY - sourceY) / 2;
  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex = 0, elevateOnSelect = false }) {
  if (!elevateOnSelect) {
    return zIndex;
  }
  const edgeOrConnectedNodeSelected = selected || targetNode.selected || sourceNode.selected;
  const selectedZIndex = Math.max(sourceNode.internals.z || 0, targetNode.internals.z || 0, 1e3);
  return zIndex + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);
}
function isEdgeVisible({ sourceNode, targetNode, width, height, transform: transform2 }) {
  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  if (edgeBox.x === edgeBox.x2) {
    edgeBox.x2 += 1;
  }
  if (edgeBox.y === edgeBox.y2) {
    edgeBox.y2 += 1;
  }
  const viewRect = {
    x: -transform2[0] / transform2[2],
    y: -transform2[1] / transform2[2],
    width: width / transform2[2],
    height: height / transform2[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
var getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ""}-${target}${targetHandle || ""}`;
var connectionExists = (edge, edges) => {
  return edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));
};
var addEdge = (edgeParams, edges) => {
  if (!edgeParams.source || !edgeParams.target) {
    devWarn("006", errorMessages["error006"]());
    return edges;
  }
  let edge;
  if (isEdgeBase(edgeParams)) {
    edge = { ...edgeParams };
  } else {
    edge = {
      ...edgeParams,
      id: getEdgeId(edgeParams)
    };
  }
  if (connectionExists(edge, edges)) {
    return edges;
  }
  if (edge.sourceHandle === null) {
    delete edge.sourceHandle;
  }
  if (edge.targetHandle === null) {
    delete edge.targetHandle;
  }
  return edges.concat(edge);
};
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
var handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
};
var getDirection = ({ source, sourcePosition = Position.Bottom, target }) => {
  if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
    return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
  }
  return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
};
var distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset }) {
  const sourceDir = handleDirections[sourcePosition];
  const targetDir = handleDirections[targetPosition];
  const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };
  const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };
  const dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  });
  const dirAccessor = dir.x !== 0 ? "x" : "y";
  const currDir = dir[dirAccessor];
  let points = [];
  let centerX, centerY;
  const sourceGapOffset = { x: 0, y: 0 };
  const targetGapOffset = { x: 0, y: 0 };
  const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    centerX = center.x ?? defaultCenterX;
    centerY = center.y ?? defaultCenterY;
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ];
    const horizontalSplit = [
      { x: sourceGapped.x, y: centerY },
      { x: targetGapped.x, y: centerY }
    ];
    if (sourceDir[dirAccessor] === currDir) {
      points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
    } else {
      points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
    }
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
    const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x") {
      points = sourceDir.x === currDir ? targetSource : sourceTarget;
    } else {
      points = sourceDir.y === currDir ? sourceTarget : targetSource;
    }
    if (sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      if (diff <= offset) {
        const gapOffset = Math.min(offset - 1, offset - diff);
        if (sourceDir[dirAccessor] === currDir) {
          sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;
        } else {
          targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
        }
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x";
      const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
      const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
      if (flipSourceTarget) {
        points = dirAccessor === "x" ? sourceTarget : targetSource;
      }
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };
    const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };
    const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
    const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    if (maxXDistance >= maxYDistance) {
      centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
      centerY = points[0].y;
    } else {
      centerX = points[0].x;
      centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
    }
  }
  const pathPoints = [
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ];
  return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a, b, c, size) {
  const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);
  const { x, y } = b;
  if (a.x === x && x === c.x || a.y === y && y === c.y) {
    return `L${x} ${y}`;
  }
  if (a.y === y) {
    const xDir2 = a.x < c.x ? -1 : 1;
    const yDir2 = a.y < c.y ? 1 : -1;
    return `L ${x + bendSize * xDir2},${y}Q ${x},${y} ${x},${y + bendSize * yDir2}`;
  }
  const xDir = a.x < c.x ? 1 : -1;
  const yDir = a.y < c.y ? -1 : 1;
  return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY },
    offset
  });
  const path = points.reduce((res, p, i) => {
    let segment = "";
    if (i > 0 && i < points.length - 1) {
      segment = getBend(points[i - 1], p, points[i + 1], borderRadius);
    } else {
      segment = `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
    }
    res += segment;
    return res;
  }, "");
  return [path, labelX, labelY, offsetX, offsetY];
}
function isNodeInitialized(node) {
  var _a;
  return node && !!(node.internals.handleBounds || ((_a = node.handles) == null ? void 0 : _a.length)) && !!(node.measured.width || node.width || node.initialWidth);
}
function getEdgePosition(params) {
  var _a;
  const { sourceNode, targetNode } = params;
  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {
    return null;
  }
  const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);
  const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);
  const sourceHandle = getHandle$1((sourceHandleBounds == null ? void 0 : sourceHandleBounds.source) ?? [], params.sourceHandle);
  const targetHandle = getHandle$1(
    // when connection type is loose we can define all handles as sources and connect source -> source
    params.connectionMode === ConnectionMode.Strict ? (targetHandleBounds == null ? void 0 : targetHandleBounds.target) ?? [] : ((targetHandleBounds == null ? void 0 : targetHandleBounds.target) ?? []).concat((targetHandleBounds == null ? void 0 : targetHandleBounds.source) ?? []),
    params.targetHandle
  );
  if (!sourceHandle || !targetHandle) {
    (_a = params.onError) == null ? void 0 : _a.call(params, "008", errorMessages["error008"](!sourceHandle ? "source" : "target", {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    }));
    return null;
  }
  const sourcePosition = (sourceHandle == null ? void 0 : sourceHandle.position) || Position.Bottom;
  const targetPosition = (targetHandle == null ? void 0 : targetHandle.position) || Position.Top;
  const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);
  const target = getHandlePosition(targetNode, targetHandle, targetPosition);
  return {
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y,
    sourcePosition,
    targetPosition
  };
}
function toHandleBounds(handles) {
  if (!handles) {
    return null;
  }
  const source = [];
  const target = [];
  for (const handle of handles) {
    handle.width = handle.width ?? 1;
    handle.height = handle.height ?? 1;
    if (handle.type === "source") {
      source.push(handle);
    } else if (handle.type === "target") {
      target.push(handle);
    }
  }
  return {
    source,
    target
  };
}
function getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {
  const x = ((handle == null ? void 0 : handle.x) ?? 0) + node.internals.positionAbsolute.x;
  const y = ((handle == null ? void 0 : handle.y) ?? 0) + node.internals.positionAbsolute.y;
  const { width, height } = handle ?? getNodeDimensions(node);
  if (center) {
    return { x: x + width / 2, y: y + height / 2 };
  }
  const position = (handle == null ? void 0 : handle.position) ?? fallbackPosition;
  switch (position) {
    case Position.Top:
      return { x: x + width / 2, y };
    case Position.Right:
      return { x: x + width, y: y + height / 2 };
    case Position.Bottom:
      return { x: x + width / 2, y: y + height };
    case Position.Left:
      return { x, y: y + height / 2 };
  }
}
function getHandle$1(bounds, handleId) {
  if (!bounds) {
    return null;
  }
  return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;
}
function getMarkerId(marker, id) {
  if (!marker) {
    return "";
  }
  if (typeof marker === "string") {
    return marker;
  }
  const idPrefix = id ? `${id}__` : "";
  return `${idPrefix}${Object.keys(marker).sort().map((key2) => `${key2}=${marker[key2]}`).join("&")}`;
}
function createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd }) {
  const ids = /* @__PURE__ */ new Set();
  return edges.reduce((markers, edge) => {
    [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {
      if (marker && typeof marker === "object") {
        const markerId = getMarkerId(marker, id);
        if (!ids.has(markerId)) {
          markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });
          ids.add(markerId);
        }
      }
    });
    return markers;
  }, []).sort((a, b) => a.id.localeCompare(b.id));
}
function getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {
  let alignmentOffset = 0.5;
  if (align === "start") {
    alignmentOffset = 0;
  } else if (align === "end") {
    alignmentOffset = 1;
  }
  let pos = [
    (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,
    nodeRect.y * viewport.zoom + viewport.y - offset
  ];
  let shift = [-100 * alignmentOffset, -100];
  switch (position) {
    case Position.Right:
      pos = [
        (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ];
      shift = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;
      shift[1] = 0;
      break;
    case Position.Left:
      pos = [
        nodeRect.x * viewport.zoom + viewport.x - offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ];
      shift = [-100, -100 * alignmentOffset];
      break;
  }
  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;
}
var defaultOptions = {
  nodeOrigin: [0, 0],
  nodeExtent: infiniteExtent,
  elevateNodesOnSelect: true,
  defaults: {}
};
var adoptUserNodesDefaultOptions = {
  ...defaultOptions,
  checkEquality: true
};
function mergeObjects(base, incoming) {
  const result = { ...base };
  for (const key2 in incoming) {
    if (incoming[key2] !== void 0) {
      result[key2] = incoming[key2];
    }
  }
  return result;
}
function adoptUserNodes(nodes, nodeLookup, parentLookup, options) {
  var _a, _b;
  const _options = mergeObjects(adoptUserNodesDefaultOptions, options);
  const tmpLookup = new Map(nodeLookup);
  const selectedNodeZ = (_options == null ? void 0 : _options.elevateNodesOnSelect) ? 1e3 : 0;
  nodeLookup.clear();
  parentLookup.clear();
  for (const userNode of nodes) {
    let internalNode = tmpLookup.get(userNode.id);
    if (_options.checkEquality && userNode === (internalNode == null ? void 0 : internalNode.internals.userNode)) {
      nodeLookup.set(userNode.id, internalNode);
    } else {
      const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);
      const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;
      const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));
      internalNode = {
        ..._options.defaults,
        ...userNode,
        measured: {
          width: (_a = userNode.measured) == null ? void 0 : _a.width,
          height: (_b = userNode.measured) == null ? void 0 : _b.height
        },
        internals: {
          positionAbsolute: clampedPosition,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: !userNode.measured ? void 0 : internalNode == null ? void 0 : internalNode.internals.handleBounds,
          z: calculateZ(userNode, selectedNodeZ),
          userNode
        }
      };
      nodeLookup.set(userNode.id, internalNode);
    }
    if (userNode.parentId) {
      updateChildNode(internalNode, nodeLookup, parentLookup, options);
    }
  }
}
function updateParentLookup(node, parentLookup) {
  if (!node.parentId) {
    return;
  }
  const childNodes = parentLookup.get(node.parentId);
  if (childNodes) {
    childNodes.set(node.id, node);
  } else {
    parentLookup.set(node.parentId, /* @__PURE__ */ new Map([[node.id, node]]));
  }
}
function updateChildNode(node, nodeLookup, parentLookup, options) {
  const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);
  const parentId = node.parentId;
  const parentNode = nodeLookup.get(parentId);
  if (!parentNode) {
    console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  updateParentLookup(node, parentLookup);
  const selectedNodeZ = elevateNodesOnSelect ? 1e3 : 0;
  const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);
  const { positionAbsolute } = node.internals;
  const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;
  if (positionChanged || z !== node.internals.z) {
    node.internals = {
      ...node.internals,
      positionAbsolute: positionChanged ? { x, y } : positionAbsolute,
      z
    };
  }
}
function calculateZ(node, selectedNodeZ) {
  return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);
}
function calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {
  const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;
  const childDimensions = getNodeDimensions(childNode);
  const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);
  const clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;
  let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);
  if (childNode.extent === "parent") {
    absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);
  }
  const childZ = calculateZ(childNode, selectedNodeZ);
  const parentZ = parentNode.internals.z ?? 0;
  return {
    x: absolutePosition.x,
    y: absolutePosition.y,
    z: parentZ > childZ ? parentZ : childZ
  };
}
function handleExpandParent(children2, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {
  var _a;
  const changes = [];
  const parentExpansions = /* @__PURE__ */ new Map();
  for (const child of children2) {
    const parent = nodeLookup.get(child.parentId);
    if (!parent) {
      continue;
    }
    const parentRect = ((_a = parentExpansions.get(child.parentId)) == null ? void 0 : _a.expandedRect) ?? nodeToRect(parent);
    const expandedRect = getBoundsOfRects(parentRect, child.rect);
    parentExpansions.set(child.parentId, { expandedRect, parent });
  }
  if (parentExpansions.size > 0) {
    parentExpansions.forEach(({ expandedRect, parent }, parentId) => {
      var _a2;
      const positionAbsolute = parent.internals.positionAbsolute;
      const dimensions = getNodeDimensions(parent);
      const origin = parent.origin ?? nodeOrigin;
      const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;
      const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;
      const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));
      const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));
      const widthChange = (newWidth - dimensions.width) * origin[0];
      const heightChange = (newHeight - dimensions.height) * origin[1];
      if (xChange > 0 || yChange > 0 || widthChange || heightChange) {
        changes.push({
          id: parentId,
          type: "position",
          position: {
            x: parent.position.x - xChange + widthChange,
            y: parent.position.y - yChange + heightChange
          }
        });
        (_a2 = parentLookup.get(parentId)) == null ? void 0 : _a2.forEach((childNode) => {
          if (!children2.some((child) => child.id === childNode.id)) {
            changes.push({
              id: childNode.id,
              type: "position",
              position: {
                x: childNode.position.x + xChange,
                y: childNode.position.y + yChange
              }
            });
          }
        });
      }
      if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {
        changes.push({
          id: parentId,
          type: "dimensions",
          setAttributes: true,
          dimensions: {
            width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),
            height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)
          }
        });
      }
    });
  }
  return changes;
}
function updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {
  const viewportNode = domNode == null ? void 0 : domNode.querySelector(".xyflow__viewport");
  let updatedInternals = false;
  if (!viewportNode) {
    return { changes: [], updatedInternals };
  }
  const changes = [];
  const style = window.getComputedStyle(viewportNode);
  const { m22: zoom2 } = new window.DOMMatrixReadOnly(style.transform);
  const parentExpandChildren = [];
  for (const update of updates.values()) {
    const node = nodeLookup.get(update.id);
    if (!node) {
      continue;
    }
    if (node.hidden) {
      node.internals = {
        ...node.internals,
        handleBounds: void 0
      };
      updatedInternals = true;
    } else {
      const dimensions = getDimensions(update.nodeElement);
      const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;
      const doUpdate = !!(dimensions.width && dimensions.height && (dimensionChanged || !node.internals.handleBounds || update.force));
      if (doUpdate) {
        const nodeBounds = update.nodeElement.getBoundingClientRect();
        const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;
        let { positionAbsolute } = node.internals;
        if (node.parentId && node.extent === "parent") {
          positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));
        } else if (extent) {
          positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);
        }
        node.measured = dimensions;
        node.internals = {
          ...node.internals,
          positionAbsolute,
          handleBounds: {
            source: getHandleBounds("source", update.nodeElement, nodeBounds, zoom2, node.id),
            target: getHandleBounds("target", update.nodeElement, nodeBounds, zoom2, node.id)
          }
        };
        if (node.parentId) {
          updateChildNode(node, nodeLookup, parentLookup, { nodeOrigin });
        }
        updatedInternals = true;
        if (dimensionChanged) {
          changes.push({
            id: node.id,
            type: "dimensions",
            dimensions
          });
          if (node.expandParent && node.parentId) {
            parentExpandChildren.push({
              id: node.id,
              parentId: node.parentId,
              rect: nodeToRect(node, nodeOrigin)
            });
          }
        }
      }
    }
  }
  if (parentExpandChildren.length > 0) {
    const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);
    changes.push(...parentExpandChanges);
  }
  return { changes, updatedInternals };
}
async function panBy({ delta, panZoom, transform: transform2, translateExtent, width, height }) {
  if (!panZoom || !delta.x && !delta.y) {
    return Promise.resolve(false);
  }
  const nextViewport = await panZoom.setViewportConstrained({
    x: transform2[0] + delta.x,
    y: transform2[1] + delta.y,
    zoom: transform2[2]
  }, [
    [0, 0],
    [width, height]
  ], translateExtent);
  const transformChanged = !!nextViewport && (nextViewport.x !== transform2[0] || nextViewport.y !== transform2[1] || nextViewport.k !== transform2[2]);
  return Promise.resolve(transformChanged);
}
function updateConnectionLookup(connectionLookup, edgeLookup, edges) {
  connectionLookup.clear();
  edgeLookup.clear();
  for (const edge of edges) {
    const { source, target, sourceHandle = null, targetHandle = null } = edge;
    const sourceKey = `${source}-source-${sourceHandle}`;
    const targetKey = `${target}-target-${targetHandle}`;
    const prevSource = connectionLookup.get(sourceKey) || /* @__PURE__ */ new Map();
    const prevTarget = connectionLookup.get(targetKey) || /* @__PURE__ */ new Map();
    const connection = { edgeId: edge.id, source, target, sourceHandle, targetHandle };
    edgeLookup.set(edge.id, edge);
    connectionLookup.set(sourceKey, prevSource.set(`${target}-${targetHandle}`, connection));
    connectionLookup.set(targetKey, prevTarget.set(`${source}-${sourceHandle}`, connection));
  }
}
function shallowNodeData(a, b) {
  if (a === null || b === null) {
    return false;
  }
  const _a = Array.isArray(a) ? a : [a];
  const _b = Array.isArray(b) ? b : [b];
  if (_a.length !== _b.length) {
    return false;
  }
  for (let i = 0; i < _a.length; i++) {
    if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {
      return false;
    }
  }
  return true;
}
function isParentSelected(node, nodeLookup) {
  if (!node.parentId) {
    return false;
  }
  const parentNode = nodeLookup.get(node.parentId);
  if (!parentNode) {
    return false;
  }
  if (parentNode.selected) {
    return true;
  }
  return isParentSelected(parentNode, nodeLookup);
}
function hasSelector(target, selector, domNode) {
  let current = target;
  do {
    if (current == null ? void 0 : current.matches(selector))
      return true;
    if (current === domNode)
      return false;
    current = current.parentElement;
  } while (current);
  return false;
}
function getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {
  const dragItems = /* @__PURE__ */ new Map();
  for (const [id, node] of nodeLookup) {
    if ((node.selected || node.id === nodeId) && (!node.parentId || !isParentSelected(node, nodeLookup)) && (node.draggable || nodesDraggable && typeof node.draggable === "undefined")) {
      const internalNode = nodeLookup.get(id);
      if (internalNode) {
        dragItems.set(id, {
          id,
          position: internalNode.position || { x: 0, y: 0 },
          distance: {
            x: mousePos.x - internalNode.internals.positionAbsolute.x,
            y: mousePos.y - internalNode.internals.positionAbsolute.y
          },
          extent: internalNode.extent,
          parentId: internalNode.parentId,
          origin: internalNode.origin,
          expandParent: internalNode.expandParent,
          internals: {
            positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 }
          },
          measured: {
            width: internalNode.measured.width ?? 0,
            height: internalNode.measured.height ?? 0
          }
        });
      }
    }
  }
  return dragItems;
}
function getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true }) {
  var _a, _b;
  const nodesFromDragItems = [];
  for (const [id, dragItem] of dragItems) {
    const node2 = (_a = nodeLookup.get(id)) == null ? void 0 : _a.internals.userNode;
    if (node2) {
      nodesFromDragItems.push({
        ...node2,
        position: dragItem.position,
        dragging
      });
    }
  }
  if (!nodeId) {
    return [nodesFromDragItems[0], nodesFromDragItems];
  }
  const node = nodeLookup.get(nodeId).internals.userNode;
  return [
    {
      ...node,
      position: ((_b = dragItems.get(nodeId)) == null ? void 0 : _b.position) || node.position,
      dragging
    },
    nodesFromDragItems
  ];
}
function XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {
  let lastPos = { x: null, y: null };
  let autoPanId = 0;
  let dragItems = /* @__PURE__ */ new Map();
  let autoPanStarted = false;
  let mousePosition = { x: 0, y: 0 };
  let containerBounds = null;
  let dragStarted = false;
  let d3Selection = null;
  let abortDrag = false;
  function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0 }) {
    d3Selection = select_default(domNode);
    function updateNodes({ x, y }, dragEvent) {
      const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();
      lastPos = { x, y };
      let hasChange = false;
      let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };
      if (dragItems.size > 1 && nodeExtent) {
        const rect = getInternalNodesBounds(dragItems);
        nodesBox = rectToBox(rect);
      }
      for (const [id, dragItem] of dragItems) {
        let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };
        if (snapToGrid) {
          nextPosition = snapPosition(nextPosition, snapGrid);
        }
        let adjustedNodeExtent = [
          [nodeExtent[0][0], nodeExtent[0][1]],
          [nodeExtent[1][0], nodeExtent[1][1]]
        ];
        if (dragItems.size > 1 && nodeExtent && !dragItem.extent) {
          const { positionAbsolute: positionAbsolute2 } = dragItem.internals;
          const x1 = positionAbsolute2.x - nodesBox.x + nodeExtent[0][0];
          const x2 = positionAbsolute2.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];
          const y1 = positionAbsolute2.y - nodesBox.y + nodeExtent[0][1];
          const y2 = positionAbsolute2.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];
          adjustedNodeExtent = [
            [x1, y1],
            [x2, y2]
          ];
        }
        const { position, positionAbsolute } = calculateNodePosition({
          nodeId: id,
          nextPosition,
          nodeLookup,
          nodeExtent: adjustedNodeExtent,
          nodeOrigin,
          onError
        });
        hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;
        dragItem.position = position;
        dragItem.internals.positionAbsolute = positionAbsolute;
      }
      if (!hasChange) {
        return;
      }
      updateNodePositions(dragItems, true);
      if (dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDrag == null ? void 0 : onDrag(dragEvent, dragItems, currentNode, currentNodes);
        onNodeDrag == null ? void 0 : onNodeDrag(dragEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDrag == null ? void 0 : onSelectionDrag(dragEvent, currentNodes);
        }
      }
    }
    async function autoPan() {
      if (!containerBounds) {
        return;
      }
      const { transform: transform2, panBy: panBy2, autoPanSpeed } = getStoreItems();
      const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);
      if (xMovement !== 0 || yMovement !== 0) {
        lastPos.x = (lastPos.x ?? 0) - xMovement / transform2[2];
        lastPos.y = (lastPos.y ?? 0) - yMovement / transform2[2];
        if (await panBy2({ x: xMovement, y: yMovement })) {
          updateNodes(lastPos, null);
        }
      }
      autoPanId = requestAnimationFrame(autoPan);
    }
    function startDrag(event) {
      var _a;
      const { nodeLookup, multiSelectionActive, nodesDraggable, transform: transform2, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();
      dragStarted = true;
      if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {
        if (!((_a = nodeLookup.get(nodeId)) == null ? void 0 : _a.selected)) {
          unselectNodesAndEdges();
        }
      }
      if (isSelectable && selectNodesOnDrag && nodeId) {
        onNodeMouseDown == null ? void 0 : onNodeMouseDown(nodeId);
      }
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      lastPos = pointerPos;
      dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);
      if (dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDragStart == null ? void 0 : onDragStart(event.sourceEvent, dragItems, currentNode, currentNodes);
        onNodeDragStart == null ? void 0 : onNodeDragStart(event.sourceEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDragStart == null ? void 0 : onSelectionDragStart(event.sourceEvent, currentNodes);
        }
      }
    }
    const d3DragInstance = drag_default().clickDistance(nodeClickDistance).on("start", (event) => {
      const { domNode: domNode2, nodeDragThreshold, transform: transform2, snapGrid, snapToGrid } = getStoreItems();
      abortDrag = false;
      if (nodeDragThreshold === 0) {
        startDrag(event);
      }
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      lastPos = pointerPos;
      containerBounds = (domNode2 == null ? void 0 : domNode2.getBoundingClientRect()) || null;
      mousePosition = getEventPosition(event.sourceEvent, containerBounds);
    }).on("drag", (event) => {
      const { autoPanOnNodeDrag, transform: transform2, snapGrid, snapToGrid, nodeDragThreshold } = getStoreItems();
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      if (event.sourceEvent.type === "touchmove" && event.sourceEvent.touches.length > 1) {
        abortDrag = true;
      }
      if (abortDrag) {
        return;
      }
      if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {
        autoPanStarted = true;
        autoPan();
      }
      if (!dragStarted) {
        const x = pointerPos.xSnapped - (lastPos.x ?? 0);
        const y = pointerPos.ySnapped - (lastPos.y ?? 0);
        const distance2 = Math.sqrt(x * x + y * y);
        if (distance2 > nodeDragThreshold) {
          startDrag(event);
        }
      }
      if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {
        mousePosition = getEventPosition(event.sourceEvent, containerBounds);
        updateNodes(pointerPos, event.sourceEvent);
      }
    }).on("end", (event) => {
      if (!dragStarted || abortDrag) {
        return;
      }
      autoPanStarted = false;
      dragStarted = false;
      cancelAnimationFrame(autoPanId);
      if (dragItems.size > 0) {
        const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();
        updateNodePositions(dragItems, false);
        if (onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {
          const [currentNode, currentNodes] = getEventHandlerParams({
            nodeId,
            dragItems,
            nodeLookup,
            dragging: false
          });
          onDragStop == null ? void 0 : onDragStop(event.sourceEvent, dragItems, currentNode, currentNodes);
          onNodeDragStop == null ? void 0 : onNodeDragStop(event.sourceEvent, currentNode, currentNodes);
          if (!nodeId) {
            onSelectionDragStop == null ? void 0 : onSelectionDragStop(event.sourceEvent, currentNodes);
          }
        }
      }
    }).filter((event) => {
      const target = event.target;
      const isDraggable = !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));
      return isDraggable;
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    d3Selection == null ? void 0 : d3Selection.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getNodesWithinDistance(position, nodeLookup, distance2) {
  const nodes = [];
  const rect = {
    x: position.x - distance2,
    y: position.y - distance2,
    width: distance2 * 2,
    height: distance2 * 2
  };
  for (const node of nodeLookup.values()) {
    if (getOverlappingArea(rect, nodeToRect(node)) > 0) {
      nodes.push(node);
    }
  }
  return nodes;
}
var ADDITIONAL_DISTANCE = 250;
function getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {
  var _a, _b;
  let closestHandles = [];
  let minDistance = Infinity;
  const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);
  for (const node of closeNodes) {
    const allHandles = [...((_a = node.internals.handleBounds) == null ? void 0 : _a.source) ?? [], ...((_b = node.internals.handleBounds) == null ? void 0 : _b.target) ?? []];
    for (const handle of allHandles) {
      if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {
        continue;
      }
      const { x, y } = getHandlePosition(node, handle, handle.position, true);
      const distance2 = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));
      if (distance2 > connectionRadius) {
        continue;
      }
      if (distance2 < minDistance) {
        closestHandles = [{ ...handle, x, y }];
        minDistance = distance2;
      } else if (distance2 === minDistance) {
        closestHandles.push({ ...handle, x, y });
      }
    }
  }
  if (!closestHandles.length) {
    return null;
  }
  if (closestHandles.length > 1) {
    const oppositeHandleType = fromHandle.type === "source" ? "target" : "source";
    return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];
  }
  return closestHandles[0];
}
function getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {
  var _a, _b, _c;
  const node = nodeLookup.get(nodeId);
  if (!node) {
    return null;
  }
  const handles = connectionMode === "strict" ? (_a = node.internals.handleBounds) == null ? void 0 : _a[handleType] : [...((_b = node.internals.handleBounds) == null ? void 0 : _b.source) ?? [], ...((_c = node.internals.handleBounds) == null ? void 0 : _c.target) ?? []];
  const handle = (handleId ? handles == null ? void 0 : handles.find((h) => h.id === handleId) : handles == null ? void 0 : handles[0]) ?? null;
  return handle && withAbsolutePosition ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) } : handle;
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  if (edgeUpdaterType) {
    return edgeUpdaterType;
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("target")) {
    return "target";
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("source")) {
    return "source";
  }
  return null;
}
function isConnectionValid(isInsideConnectionRadius, isHandleValid) {
  let isValid = null;
  if (isHandleValid) {
    isValid = true;
  } else if (isInsideConnectionRadius && !isHandleValid) {
    isValid = false;
  }
  return isValid;
}
var alwaysValid = () => true;
function onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy: panBy2, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed }) {
  const doc = getHostForElement(event.target);
  let autoPanId = 0;
  let closestHandle;
  const { x, y } = getEventPosition(event);
  const clickedHandle = doc == null ? void 0 : doc.elementFromPoint(x, y);
  const handleType = getHandleType(edgeUpdaterType, clickedHandle);
  const containerBounds = domNode == null ? void 0 : domNode.getBoundingClientRect();
  if (!containerBounds || !handleType) {
    return;
  }
  const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);
  if (!fromHandleInternal) {
    return;
  }
  let position = getEventPosition(event, containerBounds);
  let autoPanStarted = false;
  let connection = null;
  let isValid = false;
  let handleDomNode = null;
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds) {
      return;
    }
    const [x2, y2] = calcAutoPan(position, containerBounds, autoPanSpeed);
    panBy2({ x: x2, y: y2 });
    autoPanId = requestAnimationFrame(autoPan);
  }
  const fromHandle = {
    ...fromHandleInternal,
    nodeId,
    type: handleType,
    position: fromHandleInternal.position
  };
  const fromNodeInternal = nodeLookup.get(nodeId);
  const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);
  const newConnection = {
    inProgress: true,
    isValid: null,
    from,
    fromHandle,
    fromPosition: fromHandle.position,
    fromNode: fromNodeInternal,
    to: position,
    toHandle: null,
    toPosition: oppositePosition[fromHandle.position],
    toNode: null
  };
  updateConnection(newConnection);
  let previousConnection = newConnection;
  onConnectStart == null ? void 0 : onConnectStart(event, { nodeId, handleId, handleType });
  function onPointerMove(event2) {
    if (!getFromHandle() || !fromHandle) {
      onPointerUp(event2);
      return;
    }
    const transform2 = getTransform();
    position = getEventPosition(event2, containerBounds);
    closestHandle = getClosestHandle(pointToRendererPoint(position, transform2, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);
    if (!autoPanStarted) {
      autoPan();
      autoPanStarted = true;
    }
    const result = isValidHandle(event2, {
      handle: closestHandle,
      connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? "target" : "source",
      isValidConnection,
      doc,
      lib,
      flowId,
      nodeLookup
    });
    handleDomNode = result.handleDomNode;
    connection = result.connection;
    isValid = isConnectionValid(!!closestHandle, result.isValid);
    const newConnection2 = {
      // from stays the same
      ...previousConnection,
      isValid,
      to: closestHandle && isValid ? rendererPointToPoint({ x: closestHandle.x, y: closestHandle.y }, transform2) : position,
      toHandle: result.toHandle,
      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],
      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null
    };
    if (isValid && closestHandle && previousConnection.toHandle && newConnection2.toHandle && previousConnection.toHandle.type === newConnection2.toHandle.type && previousConnection.toHandle.nodeId === newConnection2.toHandle.nodeId && previousConnection.toHandle.id === newConnection2.toHandle.id && previousConnection.to.x === newConnection2.to.x && previousConnection.to.y === newConnection2.to.y) {
      return;
    }
    updateConnection(newConnection2);
    previousConnection = newConnection2;
  }
  function onPointerUp(event2) {
    if ((closestHandle || handleDomNode) && connection && isValid) {
      onConnect == null ? void 0 : onConnect(connection);
    }
    const { inProgress, ...connectionState } = previousConnection;
    const finalConnectionState = {
      ...connectionState,
      toPosition: previousConnection.toHandle ? previousConnection.toPosition : null
    };
    onConnectEnd == null ? void 0 : onConnectEnd(event2, finalConnectionState);
    if (edgeUpdaterType) {
      onReconnectEnd == null ? void 0 : onReconnectEnd(event2, finalConnectionState);
    }
    cancelConnection();
    cancelAnimationFrame(autoPanId);
    autoPanStarted = false;
    isValid = false;
    connection = null;
    handleDomNode = null;
    doc.removeEventListener("mousemove", onPointerMove);
    doc.removeEventListener("mouseup", onPointerUp);
    doc.removeEventListener("touchmove", onPointerMove);
    doc.removeEventListener("touchend", onPointerUp);
  }
  doc.addEventListener("mousemove", onPointerMove);
  doc.addEventListener("mouseup", onPointerUp);
  doc.addEventListener("touchmove", onPointerMove);
  doc.addEventListener("touchend", onPointerUp);
}
function isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup }) {
  const isTarget = fromType === "target";
  const handleDomNode = handle ? doc.querySelector(`.${lib}-flow__handle[data-id="${flowId}-${handle == null ? void 0 : handle.nodeId}-${handle == null ? void 0 : handle.id}-${handle == null ? void 0 : handle.type}"]`) : null;
  const { x, y } = getEventPosition(event);
  const handleBelow = doc.elementFromPoint(x, y);
  const handleToCheck = (handleBelow == null ? void 0 : handleBelow.classList.contains(`${lib}-flow__handle`)) ? handleBelow : handleDomNode;
  const result = {
    handleDomNode: handleToCheck,
    isValid: false,
    connection: null,
    toHandle: null
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck);
    const handleNodeId = handleToCheck.getAttribute("data-nodeid");
    const handleId = handleToCheck.getAttribute("data-handleid");
    const connectable = handleToCheck.classList.contains("connectable");
    const connectableEnd = handleToCheck.classList.contains("connectableend");
    if (!handleNodeId || !handleType) {
      return result;
    }
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isConnectable = connectable && connectableEnd;
    const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    result.isValid = isValid && isValidConnection(connection);
    result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, false);
  }
  return result;
}
var XYHandle = {
  onPointerDown,
  isValid: isValidHandle
};
function XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {
  const selection = select_default(domNode);
  function update({ translateExtent, width, height, zoomStep = 10, pannable = true, zoomable = true, inversePan = false }) {
    const zoomHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "wheel" || !panZoom) {
        return;
      }
      const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep;
      const nextZoom = transform2[2] * Math.pow(2, pinchDelta);
      panZoom.scaleTo(nextZoom);
    };
    let panStart = [0, 0];
    const panStartHandler = (event) => {
      if (event.sourceEvent.type === "mousedown" || event.sourceEvent.type === "touchstart") {
        panStart = [
          event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
          event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
        ];
      }
    };
    const panHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "mousemove" && event.sourceEvent.type !== "touchmove" || !panZoom) {
        return;
      }
      const panCurrent = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ];
      const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];
      panStart = panCurrent;
      const moveScale = getViewScale() * Math.max(transform2[2], Math.log(transform2[2])) * (inversePan ? -1 : 1);
      const position = {
        x: transform2[0] - panDelta[0] * moveScale,
        y: transform2[1] - panDelta[1] * moveScale
      };
      const extent = [
        [0, 0],
        [width, height]
      ];
      panZoom.setViewportConstrained({
        x: position.x,
        y: position.y,
        zoom: transform2[2]
      }, extent, translateExtent);
    };
    const zoomAndPanHandler = zoom_default().on("start", panStartHandler).on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
    selection.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection.on("zoom", null);
  }
  return {
    update,
    destroy,
    pointer: pointer_default
  };
}
var viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;
var transformToViewport = (transform2) => ({
  x: transform2.x,
  y: transform2.y,
  zoom: transform2.k
});
var viewportToTransform = ({ x, y, zoom: zoom2 }) => identity.translate(x, y).scale(zoom2);
var isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);
var isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);
var getD3Transition = (selection, duration = 0, onEnd = () => {
}) => {
  const hasDuration = typeof duration === "number" && duration > 0;
  if (!hasDuration) {
    onEnd();
  }
  return hasDuration ? selection.transition().duration(duration).on("end", onEnd) : selection;
};
var wheelDelta = (event) => {
  const factor = event.ctrlKey && isMacOs() ? 10 : 1;
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
};
function createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {
  return (event) => {
    if (isWrappedWithClass(event, noWheelClassName)) {
      return false;
    }
    event.preventDefault();
    event.stopImmediatePropagation();
    const currentZoom = d3Selection.property("__zoom").k || 1;
    if (event.ctrlKey && zoomOnPinch) {
      const point = pointer_default(event);
      const pinchDelta = wheelDelta(event);
      const zoom2 = currentZoom * Math.pow(2, pinchDelta);
      d3Zoom.scaleTo(d3Selection, zoom2, point, event);
      return;
    }
    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;
    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
    if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {
      deltaX = event.deltaY * deltaNormalize;
      deltaY = 0;
    }
    d3Zoom.translateBy(
      d3Selection,
      -(deltaX / currentZoom) * panOnScrollSpeed,
      -(deltaY / currentZoom) * panOnScrollSpeed,
      // @ts-ignore
      { internal: true }
    );
    const nextViewport = transformToViewport(d3Selection.property("__zoom"));
    clearTimeout(zoomPanValues.panScrollTimeout);
    if (!zoomPanValues.isPanScrolling) {
      zoomPanValues.isPanScrolling = true;
      onPanZoomStart == null ? void 0 : onPanZoomStart(event, nextViewport);
    }
    if (zoomPanValues.isPanScrolling) {
      onPanZoom == null ? void 0 : onPanZoom(event, nextViewport);
      zoomPanValues.panScrollTimeout = setTimeout(() => {
        onPanZoomEnd == null ? void 0 : onPanZoomEnd(event, nextViewport);
        zoomPanValues.isPanScrolling = false;
      }, 150);
    }
  };
}
function createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {
  return function(event, d) {
    const preventZoom = !preventScrolling && event.type === "wheel" && !event.ctrlKey;
    if (preventZoom || isWrappedWithClass(event, noWheelClassName)) {
      return null;
    }
    event.preventDefault();
    d3ZoomHandler.call(this, event, d);
  };
}
function createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {
  return (event) => {
    var _a, _b, _c;
    if ((_a = event.sourceEvent) == null ? void 0 : _a.internal) {
      return;
    }
    const viewport = transformToViewport(event.transform);
    zoomPanValues.mouseButton = ((_b = event.sourceEvent) == null ? void 0 : _b.button) || 0;
    zoomPanValues.isZoomingOrPanning = true;
    zoomPanValues.prevViewport = viewport;
    if (((_c = event.sourceEvent) == null ? void 0 : _c.type) === "mousedown") {
      onDraggingChange(true);
    }
    if (onPanZoomStart) {
      onPanZoomStart == null ? void 0 : onPanZoomStart(event.sourceEvent, viewport);
    }
  };
}
function createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {
  return (event) => {
    var _a, _b;
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));
    if (!((_a = event.sourceEvent) == null ? void 0 : _a.sync)) {
      onTransformChange([event.transform.x, event.transform.y, event.transform.k]);
    }
    if (onPanZoom && !((_b = event.sourceEvent) == null ? void 0 : _b.internal)) {
      onPanZoom == null ? void 0 : onPanZoom(event.sourceEvent, transformToViewport(event.transform));
    }
  };
}
function createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {
  return (event) => {
    var _a;
    if ((_a = event.sourceEvent) == null ? void 0 : _a.internal) {
      return;
    }
    zoomPanValues.isZoomingOrPanning = false;
    if (onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent) {
      onPaneContextMenu(event.sourceEvent);
    }
    zoomPanValues.usedRightMouseButton = false;
    onDraggingChange(false);
    if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {
      const viewport = transformToViewport(event.transform);
      zoomPanValues.prevViewport = viewport;
      clearTimeout(zoomPanValues.timerId);
      zoomPanValues.timerId = setTimeout(
        () => {
          onPanZoomEnd == null ? void 0 : onPanZoomEnd(event.sourceEvent, viewport);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        panOnScroll ? 150 : 0
      );
    }
  };
}
function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib }) {
  return (event) => {
    var _a;
    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
    const pinchZoom = zoomOnPinch && event.ctrlKey;
    if (event.button === 1 && event.type === "mousedown" && (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {
      return true;
    }
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
      return false;
    }
    if (userSelectionActive) {
      return false;
    }
    if (isWrappedWithClass(event, noWheelClassName) && event.type === "wheel") {
      return false;
    }
    if (isWrappedWithClass(event, noPanClassName) && (event.type !== "wheel" || panOnScroll && event.type === "wheel" && !zoomActivationKeyPressed)) {
      return false;
    }
    if (!zoomOnPinch && event.ctrlKey && event.type === "wheel") {
      return false;
    }
    if (!zoomOnPinch && event.type === "touchstart" && ((_a = event.touches) == null ? void 0 : _a.length) > 1) {
      event.preventDefault();
      return false;
    }
    if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === "wheel") {
      return false;
    }
    if (!panOnDrag && (event.type === "mousedown" || event.type === "touchstart")) {
      return false;
    }
    if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === "mousedown") {
      return false;
    }
    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
    return (!event.ctrlKey || event.type === "wheel") && buttonAllowed;
  };
}
function XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange }) {
  const zoomPanValues = {
    isZoomingOrPanning: false,
    usedRightMouseButton: false,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: false
  };
  const bbox = domNode.getBoundingClientRect();
  const d3ZoomInstance = zoom_default().clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance).scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);
  const d3Selection = select_default(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp(viewport.zoom, minZoom, maxZoom)
  }, [
    [0, 0],
    [bbox.width, bbox.height]
  ], translateExtent);
  const d3ZoomHandler = d3Selection.on("wheel.zoom");
  const d3DblClickZoomHandler = d3Selection.on("dblclick.zoom");
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform2, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.transform(getD3Transition(d3Selection, options == null ? void 0 : options.duration, () => resolve(true)), transform2);
      });
    }
    return Promise.resolve(false);
  }
  function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange }) {
    if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {
      destroy();
    }
    const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;
    const wheelHandler = isPanOnScroll ? createPanOnScrollHandler({
      zoomPanValues,
      noWheelClassName,
      d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode,
      panOnScrollSpeed,
      zoomOnPinch,
      onPanZoomStart,
      onPanZoom,
      onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName,
      preventScrolling,
      d3ZoomHandler
    });
    d3Selection.on("wheel.zoom", wheelHandler, { passive: false });
    if (!userSelectionActive) {
      const startHandler = createPanZoomStartHandler({
        zoomPanValues,
        onDraggingChange,
        onPanZoomStart
      });
      d3ZoomInstance.on("start", startHandler);
      const panZoomHandler = createPanZoomHandler({
        zoomPanValues,
        panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom,
        onTransformChange
      });
      d3ZoomInstance.on("zoom", panZoomHandler);
      const panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues,
        panOnDrag,
        panOnScroll,
        onPaneContextMenu,
        onPanZoomEnd,
        onDraggingChange
      });
      d3ZoomInstance.on("end", panZoomEndHandler);
    }
    const filter = createFilter({
      zoomActivationKeyPressed,
      panOnDrag,
      zoomOnScroll,
      panOnScroll,
      zoomOnDoubleClick,
      zoomOnPinch,
      userSelectionActive,
      noPanClassName,
      noWheelClassName,
      lib
    });
    d3ZoomInstance.filter(filter);
    if (zoomOnDoubleClick) {
      d3Selection.on("dblclick.zoom", d3DblClickZoomHandler);
    } else {
      d3Selection.on("dblclick.zoom", null);
    }
  }
  function destroy() {
    d3ZoomInstance.on("zoom", null);
  }
  async function setViewportConstrained(viewport2, extent, translateExtent2) {
    const nextTransform = viewportToTransform(viewport2);
    const contrainedTransform = d3ZoomInstance == null ? void 0 : d3ZoomInstance.constrain()(nextTransform, extent, translateExtent2);
    if (contrainedTransform) {
      await setTransform(contrainedTransform);
    }
    return new Promise((resolve) => resolve(contrainedTransform));
  }
  async function setViewport(viewport2, options) {
    const nextTransform = viewportToTransform(viewport2);
    await setTransform(nextTransform, options);
    return new Promise((resolve) => resolve(nextTransform));
  }
  function syncViewport(viewport2) {
    if (d3Selection) {
      const nextTransform = viewportToTransform(viewport2);
      const currentTransform = d3Selection.property("__zoom");
      if (currentTransform.k !== viewport2.zoom || currentTransform.x !== viewport2.x || currentTransform.y !== viewport2.y) {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.transform(d3Selection, nextTransform, null, { sync: true });
      }
    }
  }
  function getViewport() {
    const transform2 = d3Selection ? transform(d3Selection.node()) : { x: 0, y: 0, k: 1 };
    return { x: transform2.x, y: transform2.y, zoom: transform2.k };
  }
  function scaleTo(zoom2, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleTo(getD3Transition(d3Selection, options == null ? void 0 : options.duration, () => resolve(true)), zoom2);
      });
    }
    return Promise.resolve(false);
  }
  function scaleBy(factor, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleBy(getD3Transition(d3Selection, options == null ? void 0 : options.duration, () => resolve(true)), factor);
      });
    }
    return Promise.resolve(false);
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent2) {
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.translateExtent(translateExtent2);
  }
  function setClickDistance(distance2) {
    const validDistance = !isNumeric(distance2) || distance2 < 0 ? 0 : distance2;
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.clickDistance(validDistance);
  }
  return {
    update,
    destroy,
    setViewport,
    setViewportConstrained,
    getViewport,
    scaleTo,
    scaleBy,
    setScaleExtent,
    setTranslateExtent,
    syncViewport,
    setClickDistance
  };
}
var ResizeControlVariant;
(function(ResizeControlVariant2) {
  ResizeControlVariant2["Line"] = "line";
  ResizeControlVariant2["Handle"] = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
var XY_RESIZER_HANDLE_POSITIONS = ["top-left", "top-right", "bottom-left", "bottom-right"];
var XY_RESIZER_LINE_POSITIONS = ["top", "right", "bottom", "left"];
function getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY }) {
  const deltaWidth = width - prevWidth;
  const deltaHeight = height - prevHeight;
  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  if (deltaWidth && affectsX) {
    direction[0] = direction[0] * -1;
  }
  if (deltaHeight && affectsY) {
    direction[1] = direction[1] * -1;
  }
  return direction;
}
function getControlDirection(controlPosition) {
  const isHorizontal = controlPosition.includes("right") || controlPosition.includes("left");
  const isVertical = controlPosition.includes("bottom") || controlPosition.includes("top");
  const affectsX = controlPosition.includes("left");
  const affectsY = controlPosition.includes("top");
  return {
    isHorizontal,
    isVertical,
    affectsX,
    affectsY
  };
}
function getLowerExtentClamp(lowerExtent, lowerBound) {
  return Math.max(0, lowerBound - lowerExtent);
}
function getUpperExtentClamp(upperExtent, upperBound) {
  return Math.max(0, upperExtent - upperBound);
}
function getSizeClamp(size, minSize, maxSize) {
  return Math.max(0, minSize - size, size - maxSize);
}
function xor(a, b) {
  return a ? !b : b;
}
function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {
  let { affectsX, affectsY } = controlDirection;
  const { isHorizontal, isVertical } = controlDirection;
  const isDiagonal = isHorizontal && isVertical;
  const { xSnapped, ySnapped } = pointerPosition;
  const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;
  const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;
  let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);
  let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);
  const newWidth = startWidth + (affectsX ? -distX : distX);
  const newHeight = startHeight + (affectsY ? -distY : distY);
  const originOffsetX = -nodeOrigin[0] * startWidth;
  const originOffsetY = -nodeOrigin[1] * startHeight;
  let clampX = getSizeClamp(newWidth, minWidth, maxWidth);
  let clampY = getSizeClamp(newHeight, minHeight, maxHeight);
  if (extent) {
    let xExtentClamp = 0;
    let yExtentClamp = 0;
    if (affectsX && distX < 0) {
      xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);
    } else if (!affectsX && distX > 0) {
      xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);
    }
    if (affectsY && distY < 0) {
      yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);
    } else if (!affectsY && distY > 0) {
      yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);
    }
    clampX = Math.max(clampX, xExtentClamp);
    clampY = Math.max(clampY, yExtentClamp);
  }
  if (childExtent) {
    let xExtentClamp = 0;
    let yExtentClamp = 0;
    if (affectsX && distX > 0) {
      xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);
    } else if (!affectsX && distX < 0) {
      xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);
    }
    if (affectsY && distY > 0) {
      yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);
    } else if (!affectsY && distY < 0) {
      yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);
    }
    clampX = Math.max(clampX, xExtentClamp);
    clampY = Math.max(clampY, yExtentClamp);
  }
  if (keepAspectRatio) {
    if (isHorizontal) {
      const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;
      clampX = Math.max(clampX, aspectHeightClamp);
      if (extent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;
        } else {
          aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;
        } else {
          aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, aspectExtentClamp);
      }
    }
    if (isVertical) {
      const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;
      clampY = Math.max(clampY, aspectWidthClamp);
      if (extent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;
        } else {
          aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;
        } else {
          aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, aspectExtentClamp);
      }
    }
  }
  distY = distY + (distY < 0 ? clampY : -clampY);
  distX = distX + (distX < 0 ? clampX : -clampX);
  if (keepAspectRatio) {
    if (isDiagonal) {
      if (newWidth > newHeight * aspectRatio) {
        distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;
      } else {
        distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;
      }
    } else {
      if (isHorizontal) {
        distY = distX / aspectRatio;
        affectsY = affectsX;
      } else {
        distX = distY * aspectRatio;
        affectsX = affectsY;
      }
    }
  }
  const x = affectsX ? startX + distX : startX;
  const y = affectsY ? startY + distY : startY;
  return {
    width: startWidth + (affectsX ? -distX : distX),
    height: startHeight + (affectsY ? -distY : distY),
    x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,
    y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y
  };
}
var initPrevValues = { width: 0, height: 0, x: 0, y: 0 };
var initStartValues = {
  ...initPrevValues,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function nodeToParentExtent(node) {
  return [
    [0, 0],
    [node.measured.width, node.measured.height]
  ];
}
function nodeToChildExtent(child, parent, nodeOrigin) {
  const x = parent.position.x + child.position.x;
  const y = parent.position.y + child.position.y;
  const width = child.measured.width ?? 0;
  const height = child.measured.height ?? 0;
  const originOffsetX = nodeOrigin[0] * width;
  const originOffsetY = nodeOrigin[1] * height;
  return [
    [x - originOffsetX, y - originOffsetY],
    [x + width - originOffsetX, y + height - originOffsetY]
  ];
}
function XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {
  const selection = select_default(domNode);
  function update({ controlPosition, boundaries, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize }) {
    let prevValues = { ...initPrevValues };
    let startValues = { ...initStartValues };
    const controlDirection = getControlDirection(controlPosition);
    let node = void 0;
    let childNodes = [];
    let parentNode = void 0;
    let parentExtent = void 0;
    let childExtent = void 0;
    const dragHandler = drag_default().on("start", (event) => {
      const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin } = getStoreItems();
      node = nodeLookup.get(nodeId);
      if (!node) {
        return;
      }
      const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      prevValues = {
        width: node.measured.width ?? 0,
        height: node.measured.height ?? 0,
        x: node.position.x ?? 0,
        y: node.position.y ?? 0
      };
      startValues = {
        ...prevValues,
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.width / prevValues.height
      };
      parentNode = void 0;
      if (node.parentId && (node.extent === "parent" || node.expandParent)) {
        parentNode = nodeLookup.get(node.parentId);
        parentExtent = parentNode && node.extent === "parent" ? nodeToParentExtent(parentNode) : void 0;
      }
      childNodes = [];
      childExtent = void 0;
      for (const [childId, child] of nodeLookup) {
        if (child.parentId === nodeId) {
          childNodes.push({
            id: childId,
            position: { ...child.position },
            extent: child.extent
          });
          if (child.extent === "parent" || child.expandParent) {
            const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);
            if (childExtent) {
              childExtent = [
                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],
                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]
              ];
            } else {
              childExtent = extent;
            }
          }
        }
      }
      onResizeStart == null ? void 0 : onResizeStart(event, { ...prevValues });
    }).on("drag", (event) => {
      const { transform: transform2, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();
      const pointerPosition = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      const childChanges = [];
      if (!node) {
        return;
      }
      const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;
      const change = {};
      const nodeOrigin = node.origin ?? storeNodeOrigin;
      const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);
      const isWidthChange = width !== prevWidth;
      const isHeightChange = height !== prevHeight;
      const isXPosChange = x !== prevX && isWidthChange;
      const isYPosChange = y !== prevY && isHeightChange;
      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {
        return;
      }
      if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {
        change.x = isXPosChange ? x : prevValues.x;
        change.y = isYPosChange ? y : prevValues.y;
        prevValues.x = change.x;
        prevValues.y = change.y;
        if (childNodes.length > 0) {
          const xChange = x - prevX;
          const yChange = y - prevY;
          for (const childNode of childNodes) {
            childNode.position = {
              x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),
              y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)
            };
            childChanges.push(childNode);
          }
        }
      }
      if (isWidthChange || isHeightChange) {
        change.width = isWidthChange ? width : prevValues.width;
        change.height = isHeightChange ? height : prevValues.height;
        prevValues.width = change.width;
        prevValues.height = change.height;
      }
      if (parentNode && node.expandParent) {
        const xLimit = nodeOrigin[0] * (change.width ?? 0);
        if (change.x && change.x < xLimit) {
          prevValues.x = xLimit;
          startValues.x = startValues.x - (change.x - xLimit);
        }
        const yLimit = nodeOrigin[1] * (change.height ?? 0);
        if (change.y && change.y < yLimit) {
          prevValues.y = yLimit;
          startValues.y = startValues.y - (change.y - yLimit);
        }
      }
      const direction = getResizeDirection({
        width: prevValues.width,
        prevWidth,
        height: prevValues.height,
        prevHeight,
        affectsX: controlDirection.affectsX,
        affectsY: controlDirection.affectsY
      });
      const nextValues = { ...prevValues, direction };
      const callResize = shouldResize == null ? void 0 : shouldResize(event, nextValues);
      if (callResize === false) {
        return;
      }
      onResize == null ? void 0 : onResize(event, nextValues);
      onChange(change, childChanges);
    }).on("end", (event) => {
      onResizeEnd == null ? void 0 : onResizeEnd(event, { ...prevValues });
      onEnd == null ? void 0 : onEnd();
    });
    selection.call(dragHandler);
  }
  function destroy() {
    selection.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte
var file = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\Handle\\Handle.svelte";
function create_fragment(ctx) {
  let div;
  let div_data_id_value;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[45].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-handleid": true,
        "data-nodeid": true,
        "data-handlepos": true,
        "data-id": true,
        class: true,
        style: true,
        role: true,
        tabindex: true
      });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "data-handleid",
        /*handleId*/
        ctx[6]
      );
      attr_dev(
        div,
        "data-nodeid",
        /*nodeId*/
        ctx[14]
      );
      attr_dev(
        div,
        "data-handlepos",
        /*position*/
        ctx[2]
      );
      attr_dev(div, "data-id", div_data_id_value = /*$flowId*/
      ctx[13] + "-" + /*nodeId*/
      ctx[14] + "-" + /*id*/
      (ctx[0] || null) + "-" + /*type*/
      ctx[1]);
      attr_dev(div, "class", div_class_value = cc([
        "svelte-flow__handle",
        `svelte-flow__handle-${/*position*/
        ctx[2]}`,
        "nodrag",
        "nopan",
        /*position*/
        ctx[2],
        /*className*/
        ctx[4]
      ]));
      attr_dev(
        div,
        "style",
        /*style*/
        ctx[3]
      );
      attr_dev(div, "role", "button");
      attr_dev(div, "tabindex", "-1");
      toggle_class(
        div,
        "valid",
        /*valid*/
        ctx[7]
      );
      toggle_class(
        div,
        "connectingto",
        /*connectingTo*/
        ctx[5]
      );
      toggle_class(
        div,
        "connectingfrom",
        /*connectingFrom*/
        ctx[9]
      );
      toggle_class(div, "source", !/*isTarget*/
      ctx[11]);
      toggle_class(
        div,
        "target",
        /*isTarget*/
        ctx[11]
      );
      toggle_class(
        div,
        "connectablestart",
        /*isConnectable*/
        ctx[12]
      );
      toggle_class(
        div,
        "connectableend",
        /*isConnectable*/
        ctx[12]
      );
      toggle_class(
        div,
        "connectable",
        /*isConnectable*/
        ctx[12]
      );
      toggle_class(
        div,
        "connectionindicator",
        /*isConnectable*/
        ctx[12] && (!/*connectionInProcess*/
        ctx[10] || /*isPossibleEndHandle*/
        ctx[8])
      );
      add_location(div, file, 101, 0, 4375);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "mousedown",
            /*onPointerDown*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchstart",
            /*onPointerDown*/
            ctx[32],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*handleId*/
      64) {
        attr_dev(
          div,
          "data-handleid",
          /*handleId*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*position*/
      4) {
        attr_dev(
          div,
          "data-handlepos",
          /*position*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*$flowId, id, type*/
      8195 && div_data_id_value !== (div_data_id_value = /*$flowId*/
      ctx2[13] + "-" + /*nodeId*/
      ctx2[14] + "-" + /*id*/
      (ctx2[0] || null) + "-" + /*type*/
      ctx2[1])) {
        attr_dev(div, "data-id", div_data_id_value);
      }
      if (!current || dirty[0] & /*position, className*/
      20 && div_class_value !== (div_class_value = cc([
        "svelte-flow__handle",
        `svelte-flow__handle-${/*position*/
        ctx2[2]}`,
        "nodrag",
        "nopan",
        /*position*/
        ctx2[2],
        /*className*/
        ctx2[4]
      ]))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*style*/
      8) {
        attr_dev(
          div,
          "style",
          /*style*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*position, className, valid*/
      148) {
        toggle_class(
          div,
          "valid",
          /*valid*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*position, className, connectingTo*/
      52) {
        toggle_class(
          div,
          "connectingto",
          /*connectingTo*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*position, className, connectingFrom*/
      532) {
        toggle_class(
          div,
          "connectingfrom",
          /*connectingFrom*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*position, className, isTarget*/
      2068) {
        toggle_class(div, "source", !/*isTarget*/
        ctx2[11]);
      }
      if (!current || dirty[0] & /*position, className, isTarget*/
      2068) {
        toggle_class(
          div,
          "target",
          /*isTarget*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*position, className, isConnectable*/
      4116) {
        toggle_class(
          div,
          "connectablestart",
          /*isConnectable*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*position, className, isConnectable*/
      4116) {
        toggle_class(
          div,
          "connectableend",
          /*isConnectable*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*position, className, isConnectable*/
      4116) {
        toggle_class(
          div,
          "connectable",
          /*isConnectable*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*position, className, isConnectable, connectionInProcess, isPossibleEndHandle*/
      5396) {
        toggle_class(
          div,
          "connectionindicator",
          /*isConnectable*/
          ctx2[12] && (!/*connectionInProcess*/
          ctx2[10] || /*isPossibleEndHandle*/
          ctx2[8])
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let isTarget;
  let isConnectable;
  let handleId;
  let connectionInProcess;
  let connectingFrom;
  let connectingTo;
  let isPossibleEndHandle;
  let valid;
  let $connection;
  let $connectionMode;
  let $connectionLookup;
  let $edges;
  let $viewport;
  let $onConnectEndAction;
  let $onConnectStartAction;
  let $onConnectAction;
  let $onedgecreate;
  let $isValidConnectionStore;
  let $flowId;
  let $autoPanOnConnect;
  let $lib;
  let $nodeLookup;
  let $domNode;
  let $connectionRadius;
  let $connectable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Handle", slots, ["default"]);
  let { id = void 0 } = $$props;
  let { type = "source" } = $$props;
  let { position = Position.Top } = $$props;
  let { style = void 0 } = $$props;
  let { isValidConnection = void 0 } = $$props;
  let { onconnect = void 0 } = $$props;
  let { ondisconnect = void 0 } = $$props;
  let { isConnectable: isConnectableProp = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  const nodeId = getContext("svelteflow__node_id");
  const connectable = getContext("svelteflow__node_connectable");
  validate_store(connectable, "connectable");
  component_subscribe($$self, connectable, (value) => $$invalidate(43, $connectable = value));
  const store = useStore();
  const { connectionMode, domNode, nodeLookup, connectionRadius, viewport, isValidConnection: isValidConnectionStore, lib, addEdge: addEdge2, onedgecreate, panBy: panBy2, cancelConnection, updateConnection, autoPanOnConnect, edges, connectionLookup, onconnect: onConnectAction, onconnectstart: onConnectStartAction, onconnectend: onConnectEndAction, flowId, connection } = store;
  validate_store(connectionMode, "connectionMode");
  component_subscribe($$self, connectionMode, (value) => $$invalidate(40, $connectionMode = value));
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(55, $domNode = value));
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(54, $nodeLookup = value));
  validate_store(connectionRadius, "connectionRadius");
  component_subscribe($$self, connectionRadius, (value) => $$invalidate(56, $connectionRadius = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(46, $viewport = value));
  validate_store(isValidConnectionStore, "isValidConnectionStore");
  component_subscribe($$self, isValidConnectionStore, (value) => $$invalidate(51, $isValidConnectionStore = value));
  validate_store(lib, "lib");
  component_subscribe($$self, lib, (value) => $$invalidate(53, $lib = value));
  validate_store(onedgecreate, "onedgecreate");
  component_subscribe($$self, onedgecreate, (value) => $$invalidate(50, $onedgecreate = value));
  validate_store(autoPanOnConnect, "autoPanOnConnect");
  component_subscribe($$self, autoPanOnConnect, (value) => $$invalidate(52, $autoPanOnConnect = value));
  validate_store(edges, "edges");
  component_subscribe($$self, edges, (value) => $$invalidate(42, $edges = value));
  validate_store(connectionLookup, "connectionLookup");
  component_subscribe($$self, connectionLookup, (value) => $$invalidate(41, $connectionLookup = value));
  validate_store(onConnectAction, "onConnectAction");
  component_subscribe($$self, onConnectAction, (value) => $$invalidate(49, $onConnectAction = value));
  validate_store(onConnectStartAction, "onConnectStartAction");
  component_subscribe($$self, onConnectStartAction, (value) => $$invalidate(48, $onConnectStartAction = value));
  validate_store(onConnectEndAction, "onConnectEndAction");
  component_subscribe($$self, onConnectEndAction, (value) => $$invalidate(47, $onConnectEndAction = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(13, $flowId = value));
  validate_store(connection, "connection");
  component_subscribe($$self, connection, (value) => $$invalidate(39, $connection = value));
  function onPointerDown2(event) {
    const isMouseTriggered = isMouseEvent(event);
    if (isMouseTriggered && event.button === 0 || !isMouseTriggered) {
      XYHandle.onPointerDown(event, {
        handleId,
        nodeId,
        isTarget,
        connectionRadius: $connectionRadius,
        domNode: $domNode,
        nodeLookup: $nodeLookup,
        connectionMode: $connectionMode,
        lib: $lib,
        autoPanOnConnect: $autoPanOnConnect,
        flowId: $flowId,
        isValidConnection: isValidConnection ?? $isValidConnectionStore,
        updateConnection,
        cancelConnection,
        panBy: panBy2,
        onConnect: (connection2) => {
          const edge = $onedgecreate ? $onedgecreate(connection2) : connection2;
          if (!edge) {
            return;
          }
          addEdge2(edge);
          $onConnectAction == null ? void 0 : $onConnectAction(connection2);
        },
        onConnectStart: (event2, startParams) => {
          $onConnectStartAction == null ? void 0 : $onConnectStartAction(event2, {
            nodeId: startParams.nodeId,
            handleId: startParams.handleId,
            handleType: startParams.handleType
          });
        },
        onConnectEnd: (event2, connectionState) => {
          $onConnectEndAction == null ? void 0 : $onConnectEndAction(event2, connectionState);
        },
        getTransform: () => [$viewport.x, $viewport.y, $viewport.zoom],
        getFromHandle: () => $connection.fromHandle
      });
    }
  }
  let prevConnections = null;
  let connections;
  const writable_props = [
    "id",
    "type",
    "position",
    "style",
    "isValidConnection",
    "onconnect",
    "ondisconnect",
    "isConnectable",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Handle> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("type" in $$props2) $$invalidate(1, type = $$props2.type);
    if ("position" in $$props2) $$invalidate(2, position = $$props2.position);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("isValidConnection" in $$props2) $$invalidate(33, isValidConnection = $$props2.isValidConnection);
    if ("onconnect" in $$props2) $$invalidate(34, onconnect = $$props2.onconnect);
    if ("ondisconnect" in $$props2) $$invalidate(35, ondisconnect = $$props2.ondisconnect);
    if ("isConnectable" in $$props2) $$invalidate(36, isConnectableProp = $$props2.isConnectable);
    if ("class" in $$props2) $$invalidate(4, className = $$props2.class);
    if ("$$scope" in $$props2) $$invalidate(44, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    cc,
    Position,
    XYHandle,
    isMouseEvent,
    areConnectionMapsEqual,
    handleConnectionChange,
    ConnectionMode,
    useStore,
    id,
    type,
    position,
    style,
    isValidConnection,
    onconnect,
    ondisconnect,
    isConnectableProp,
    className,
    nodeId,
    connectable,
    store,
    connectionMode,
    domNode,
    nodeLookup,
    connectionRadius,
    viewport,
    isValidConnectionStore,
    lib,
    addEdge: addEdge2,
    onedgecreate,
    panBy: panBy2,
    cancelConnection,
    updateConnection,
    autoPanOnConnect,
    edges,
    connectionLookup,
    onConnectAction,
    onConnectStartAction,
    onConnectEndAction,
    flowId,
    connection,
    onPointerDown: onPointerDown2,
    prevConnections,
    connections,
    connectingTo,
    valid,
    handleId,
    isPossibleEndHandle,
    connectingFrom,
    connectionInProcess,
    isTarget,
    isConnectable,
    $connection,
    $connectionMode,
    $connectionLookup,
    $edges,
    $viewport,
    $onConnectEndAction,
    $onConnectStartAction,
    $onConnectAction,
    $onedgecreate,
    $isValidConnectionStore,
    $flowId,
    $autoPanOnConnect,
    $lib,
    $nodeLookup,
    $domNode,
    $connectionRadius,
    $connectable
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("type" in $$props2) $$invalidate(1, type = $$props2.type);
    if ("position" in $$props2) $$invalidate(2, position = $$props2.position);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("isValidConnection" in $$props2) $$invalidate(33, isValidConnection = $$props2.isValidConnection);
    if ("onconnect" in $$props2) $$invalidate(34, onconnect = $$props2.onconnect);
    if ("ondisconnect" in $$props2) $$invalidate(35, ondisconnect = $$props2.ondisconnect);
    if ("isConnectableProp" in $$props2) $$invalidate(36, isConnectableProp = $$props2.isConnectableProp);
    if ("className" in $$props2) $$invalidate(4, className = $$props2.className);
    if ("prevConnections" in $$props2) $$invalidate(37, prevConnections = $$props2.prevConnections);
    if ("connections" in $$props2) $$invalidate(38, connections = $$props2.connections);
    if ("connectingTo" in $$props2) $$invalidate(5, connectingTo = $$props2.connectingTo);
    if ("valid" in $$props2) $$invalidate(7, valid = $$props2.valid);
    if ("handleId" in $$props2) $$invalidate(6, handleId = $$props2.handleId);
    if ("isPossibleEndHandle" in $$props2) $$invalidate(8, isPossibleEndHandle = $$props2.isPossibleEndHandle);
    if ("connectingFrom" in $$props2) $$invalidate(9, connectingFrom = $$props2.connectingFrom);
    if ("connectionInProcess" in $$props2) $$invalidate(10, connectionInProcess = $$props2.connectionInProcess);
    if ("isTarget" in $$props2) $$invalidate(11, isTarget = $$props2.isTarget);
    if ("isConnectable" in $$props2) $$invalidate(12, isConnectable = $$props2.isConnectable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if ($$self.$$.dirty[0] & /*type*/
    2) {
      $: $$invalidate(11, isTarget = type === "target");
    }
    if ($$self.$$.dirty[1] & /*isConnectableProp, $connectable*/
    4128) {
      $: $$invalidate(12, isConnectable = isConnectableProp !== void 0 ? isConnectableProp : $connectable);
    }
    if ($$self.$$.dirty[0] & /*id*/
    1) {
      $: $$invalidate(6, handleId = id || null);
    }
    if ($$self.$$.dirty[0] & /*type, id*/
    3 | $$self.$$.dirty[1] & /*onconnect, ondisconnect, $edges, $connectionLookup*/
    3096) {
      $: if (onconnect || ondisconnect) {
        $edges;
        $$invalidate(38, connections = $connectionLookup.get(`${nodeId}-${type}-${id || null}`));
      }
    }
    if ($$self.$$.dirty[1] & /*prevConnections, connections, ondisconnect, onconnect*/
    216) {
      $: {
        if (prevConnections && !areConnectionMapsEqual(connections, prevConnections)) {
          const _connections = connections ?? /* @__PURE__ */ new Map();
          handleConnectionChange(prevConnections, _connections, ondisconnect);
          handleConnectionChange(_connections, prevConnections, onconnect);
        }
        $$invalidate(37, prevConnections = connections ?? /* @__PURE__ */ new Map());
      }
    }
    if ($$self.$$.dirty[1] & /*$connection*/
    256) {
      $: $$invalidate(10, connectionInProcess = !!$connection.fromHandle);
    }
    if ($$self.$$.dirty[0] & /*type, handleId*/
    66 | $$self.$$.dirty[1] & /*$connection*/
    256) {
      $: $$invalidate(9, connectingFrom = ((_a = $connection.fromHandle) == null ? void 0 : _a.nodeId) === nodeId && ((_b = $connection.fromHandle) == null ? void 0 : _b.type) === type && ((_c = $connection.fromHandle) == null ? void 0 : _c.id) === handleId);
    }
    if ($$self.$$.dirty[0] & /*type, handleId*/
    66 | $$self.$$.dirty[1] & /*$connection*/
    256) {
      $: $$invalidate(5, connectingTo = ((_d = $connection.toHandle) == null ? void 0 : _d.nodeId) === nodeId && ((_e = $connection.toHandle) == null ? void 0 : _e.type) === type && ((_f = $connection.toHandle) == null ? void 0 : _f.id) === handleId);
    }
    if ($$self.$$.dirty[0] & /*type, handleId*/
    66 | $$self.$$.dirty[1] & /*$connectionMode, $connection*/
    768) {
      $: $$invalidate(8, isPossibleEndHandle = $connectionMode === ConnectionMode.Strict ? ((_g = $connection.fromHandle) == null ? void 0 : _g.type) !== type : nodeId !== ((_h = $connection.fromHandle) == null ? void 0 : _h.nodeId) || handleId !== ((_i = $connection.fromHandle) == null ? void 0 : _i.id));
    }
    if ($$self.$$.dirty[0] & /*connectingTo*/
    32 | $$self.$$.dirty[1] & /*$connection*/
    256) {
      $: $$invalidate(7, valid = connectingTo && $connection.isValid);
    }
  };
  return [
    id,
    type,
    position,
    style,
    className,
    connectingTo,
    handleId,
    valid,
    isPossibleEndHandle,
    connectingFrom,
    connectionInProcess,
    isTarget,
    isConnectable,
    $flowId,
    nodeId,
    connectable,
    connectionMode,
    domNode,
    nodeLookup,
    connectionRadius,
    viewport,
    isValidConnectionStore,
    lib,
    onedgecreate,
    autoPanOnConnect,
    edges,
    connectionLookup,
    onConnectAction,
    onConnectStartAction,
    onConnectEndAction,
    flowId,
    connection,
    onPointerDown2,
    isValidConnection,
    onconnect,
    ondisconnect,
    isConnectableProp,
    prevConnections,
    connections,
    $connection,
    $connectionMode,
    $connectionLookup,
    $edges,
    $connectable,
    $$scope,
    slots
  ];
}
var Handle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        id: 0,
        type: 1,
        position: 2,
        style: 3,
        isValidConnection: 33,
        onconnect: 34,
        ondisconnect: 35,
        isConnectable: 36,
        class: 4
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Handle",
      options,
      id: create_fragment.name
    });
  }
  get id() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isValidConnection() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isValidConnection(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onconnect() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onconnect(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ondisconnect() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ondisconnect(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isConnectable() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isConnectable(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Handle_default = Handle;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/DefaultNode.svelte
function create_fragment2(ctx) {
  var _a;
  let handle0;
  let t0;
  let t1_value = (
    /*data*/
    ((_a = ctx[0]) == null ? void 0 : _a.label) + ""
  );
  let t1;
  let t2;
  let handle1;
  let current;
  handle0 = new Handle_default({
    props: {
      type: "target",
      position: (
        /*targetPosition*/
        ctx[1] ?? Position.Top
      )
    },
    $$inline: true
  });
  handle1 = new Handle_default({
    props: {
      type: "source",
      position: (
        /*sourcePosition*/
        ctx[2] ?? Position.Bottom
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(handle0.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      create_component(handle1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(handle0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(nodes, t1_value);
      t2 = claim_space(nodes);
      claim_component(handle1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(handle0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(handle1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      const handle0_changes = {};
      if (dirty & /*targetPosition*/
      2) handle0_changes.position = /*targetPosition*/
      ctx2[1] ?? Position.Top;
      handle0.$set(handle0_changes);
      if ((!current || dirty & /*data*/
      1) && t1_value !== (t1_value = /*data*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.label) + "")) set_data_dev(t1, t1_value);
      const handle1_changes = {};
      if (dirty & /*sourcePosition*/
      4) handle1_changes.position = /*sourcePosition*/
      ctx2[2] ?? Position.Bottom;
      handle1.$set(handle1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(handle0.$$.fragment, local);
      transition_in(handle1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(handle0.$$.fragment, local);
      transition_out(handle1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(handle0, detaching);
      destroy_component(handle1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["data", "targetPosition", "sourcePosition"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultNode", slots, []);
  let { data = { label: "Node" } } = $$props;
  let { targetPosition = void 0 } = $$props;
  let { sourcePosition = void 0 } = $$props;
  $$restProps;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props) $$invalidate(0, data = $$new_props.data);
    if ("targetPosition" in $$new_props) $$invalidate(1, targetPosition = $$new_props.targetPosition);
    if ("sourcePosition" in $$new_props) $$invalidate(2, sourcePosition = $$new_props.sourcePosition);
  };
  $$self.$capture_state = () => ({
    Position,
    Handle: Handle_default,
    data,
    targetPosition,
    sourcePosition
  });
  $$self.$inject_state = ($$new_props) => {
    if ("data" in $$props) $$invalidate(0, data = $$new_props.data);
    if ("targetPosition" in $$props) $$invalidate(1, targetPosition = $$new_props.targetPosition);
    if ("sourcePosition" in $$props) $$invalidate(2, sourcePosition = $$new_props.sourcePosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [data, targetPosition, sourcePosition];
}
var DefaultNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      data: 0,
      targetPosition: 1,
      sourcePosition: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultNode",
      options,
      id: create_fragment2.name
    });
  }
  get data() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultNode_default = DefaultNode;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/InputNode.svelte
function create_fragment3(ctx) {
  var _a;
  let t0_value = (
    /*data*/
    ((_a = ctx[0]) == null ? void 0 : _a.label) + ""
  );
  let t0;
  let t1;
  let handle;
  let current;
  handle = new Handle_default({
    props: {
      type: "source",
      position: (
        /*sourcePosition*/
        ctx[1] ?? Position.Bottom
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      create_component(handle.$$.fragment);
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
      claim_component(handle.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(handle, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      if ((!current || dirty & /*data*/
      1) && t0_value !== (t0_value = /*data*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.label) + "")) set_data_dev(t0, t0_value);
      const handle_changes = {};
      if (dirty & /*sourcePosition*/
      2) handle_changes.position = /*sourcePosition*/
      ctx2[1] ?? Position.Bottom;
      handle.$set(handle_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(handle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(handle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(handle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["data", "sourcePosition"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputNode", slots, []);
  let { data = { label: "Node" } } = $$props;
  let { sourcePosition = void 0 } = $$props;
  $$restProps;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props) $$invalidate(0, data = $$new_props.data);
    if ("sourcePosition" in $$new_props) $$invalidate(1, sourcePosition = $$new_props.sourcePosition);
  };
  $$self.$capture_state = () => ({ Position, Handle: Handle_default, data, sourcePosition });
  $$self.$inject_state = ($$new_props) => {
    if ("data" in $$props) $$invalidate(0, data = $$new_props.data);
    if ("sourcePosition" in $$props) $$invalidate(1, sourcePosition = $$new_props.sourcePosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [data, sourcePosition];
}
var InputNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { data: 0, sourcePosition: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputNode",
      options,
      id: create_fragment3.name
    });
  }
  get data() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputNode_default = InputNode;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/OutputNode.svelte
function create_fragment4(ctx) {
  var _a;
  let t0_value = (
    /*data*/
    ((_a = ctx[0]) == null ? void 0 : _a.label) + ""
  );
  let t0;
  let t1;
  let handle;
  let current;
  handle = new Handle_default({
    props: {
      type: "target",
      position: (
        /*targetPosition*/
        ctx[1] ?? Position.Top
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      create_component(handle.$$.fragment);
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
      claim_component(handle.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(handle, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      if ((!current || dirty & /*data*/
      1) && t0_value !== (t0_value = /*data*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.label) + "")) set_data_dev(t0, t0_value);
      const handle_changes = {};
      if (dirty & /*targetPosition*/
      2) handle_changes.position = /*targetPosition*/
      ctx2[1] ?? Position.Top;
      handle.$set(handle_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(handle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(handle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(handle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["data", "targetPosition"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OutputNode", slots, []);
  let { data = { label: "Node" } } = $$props;
  let { targetPosition = void 0 } = $$props;
  $$restProps;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props) $$invalidate(0, data = $$new_props.data);
    if ("targetPosition" in $$new_props) $$invalidate(1, targetPosition = $$new_props.targetPosition);
  };
  $$self.$capture_state = () => ({ Position, Handle: Handle_default, data, targetPosition });
  $$self.$inject_state = ($$new_props) => {
    if ("data" in $$props) $$invalidate(0, data = $$new_props.data);
    if ("targetPosition" in $$props) $$invalidate(1, targetPosition = $$new_props.targetPosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [data, targetPosition];
}
var OutputNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { data: 0, targetPosition: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OutputNode",
      options,
      id: create_fragment4.name
    });
  }
  get data() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OutputNode_default = OutputNode;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/GroupNode.svelte
function create_fragment5(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GroupNode", slots, []);
  $$restProps;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [];
}
var GroupNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GroupNode",
      options,
      id: create_fragment5.name
    });
  }
};
var GroupNode_default = GroupNode;

// node_modules/@xyflow/svelte/dist/lib/actions/portal/index.js
function tryToMount(node, domNode, target) {
  if (!domNode) {
    return;
  }
  const targetEl = target ? domNode.querySelector(target) : domNode;
  if (targetEl) {
    targetEl.appendChild(node);
  }
}
function portal_default(node, { target, domNode }) {
  tryToMount(node, domNode, target);
  return {
    async update({ target: target2, domNode: domNode2 }) {
      tryToMount(node, domNode2, target2);
    },
    destroy() {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/EdgeLabelRenderer/EdgeLabelRenderer.svelte
var file2 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\EdgeLabelRenderer\\EdgeLabelRenderer.svelte";
function create_fragment6(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 5, 0, 134);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal_default.call(null, div, {
          target: ".svelte-flow__edgelabel-renderer",
          domNode: (
            /*$domNode*/
            ctx[0]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*$domNode*/
      1) portal_action.update.call(null, {
        target: ".svelte-flow__edgelabel-renderer",
        domNode: (
          /*$domNode*/
          ctx2[0]
        )
      });
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $domNode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeLabelRenderer", slots, ["default"]);
  const { domNode } = useStore();
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(0, $domNode = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<EdgeLabelRenderer> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ portal: portal_default, useStore, domNode, $domNode });
  return [$domNode, domNode, $$scope, slots];
}
var EdgeLabelRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeLabelRenderer",
      options,
      id: create_fragment6.name
    });
  }
};
var EdgeLabelRenderer_default = EdgeLabelRenderer;

// node_modules/@xyflow/svelte/dist/lib/hooks/useHandleEdgeSelect.js
function useHandleEdgeSelect() {
  const { edgeLookup, selectionRect, selectionRectMode, multiselectionKeyPressed, addSelectedEdges, unselectNodesAndEdges, elementsSelectable } = useStore();
  return (id) => {
    const edge = get_store_value(edgeLookup).get(id);
    if (!edge) {
      console.warn("012", errorMessages["error012"](id));
      return;
    }
    const selectable = edge.selectable || get_store_value(elementsSelectable) && typeof edge.selectable === "undefined";
    if (selectable) {
      selectionRect.set(null);
      selectionRectMode.set(null);
      if (!edge.selected) {
        addSelectedEdges([id]);
      } else if (edge.selected && get_store_value(multiselectionKeyPressed)) {
        unselectNodesAndEdges({ nodes: [], edges: [edge] });
      }
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/EdgeLabel/EdgeLabel.svelte
var file3 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\EdgeLabel\\EdgeLabel.svelte";
function create_default_slot(ctx) {
  let div;
  let div_style_value;
  let style_transform = `translate(-50%, -50%) translate(${/*x*/
  ctx[1]}px,${/*y*/
  ctx[2]}px)`;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        style: true,
        role: true,
        tabindex: true
      });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-flow__edge-label");
      attr_dev(div, "style", div_style_value = "pointer-events: all;" + /*style*/
      ctx[0]);
      attr_dev(div, "role", "button");
      attr_dev(div, "tabindex", "-1");
      set_style(div, "transform", style_transform);
      add_location(div, file3, 11, 2, 383);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "keyup", keyup_handler, false, false, false, false),
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*style*/
      1 && div_style_value !== (div_style_value = "pointer-events: all;" + /*style*/
      ctx2[0])) {
        attr_dev(div, "style", div_style_value);
      }
      const style_changed = dirty & /*style*/
      1;
      if (dirty & /*x, y, style*/
      7 && style_transform !== (style_transform = `translate(-50%, -50%) translate(${/*x*/
      ctx2[1]}px,${/*y*/
      ctx2[2]}px)`) || style_changed) {
        set_style(div, "transform", style_transform);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(11:0) <EdgeLabelRenderer>",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let edgelabelrenderer;
  let current;
  edgelabelrenderer = new EdgeLabelRenderer_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(edgelabelrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(edgelabelrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(edgelabelrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const edgelabelrenderer_changes = {};
      if (dirty & /*$$scope, style, x, y*/
      135) {
        edgelabelrenderer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      edgelabelrenderer.$set(edgelabelrenderer_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(edgelabelrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(edgelabelrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(edgelabelrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keyup_handler = () => {
};
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeLabel", slots, ["default"]);
  let { style = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  const handleEdgeSelect = useHandleEdgeSelect();
  const id = getContext("svelteflow__edge_id");
  const writable_props = ["style", "x", "y"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<EdgeLabel> was created with unknown prop '${key2}'`);
  });
  const click_handler = () => {
    if (id) handleEdgeSelect(id);
  };
  $$self.$$set = ($$props2) => {
    if ("style" in $$props2) $$invalidate(0, style = $$props2.style);
    if ("x" in $$props2) $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(2, y = $$props2.y);
    if ("$$scope" in $$props2) $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    EdgeLabelRenderer: EdgeLabelRenderer_default,
    useHandleEdgeSelect,
    style,
    x,
    y,
    handleEdgeSelect,
    id
  });
  $$self.$inject_state = ($$props2) => {
    if ("style" in $$props2) $$invalidate(0, style = $$props2.style);
    if ("x" in $$props2) $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(2, y = $$props2.y);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [style, x, y, handleEdgeSelect, id, slots, click_handler, $$scope];
}
var EdgeLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { style: 0, x: 1, y: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeLabel",
      options,
      id: create_fragment7.name
    });
  }
  get style() {
    throw new Error("<EdgeLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<EdgeLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<EdgeLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<EdgeLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<EdgeLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<EdgeLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeLabel_default = EdgeLabel;

// node_modules/@xyflow/svelte/dist/lib/components/BaseEdge/BaseEdge.svelte
var file4 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\BaseEdge\\BaseEdge.svelte";
function create_if_block_1(ctx) {
  let path_1;
  let path_1_stroke_opacity_value;
  const block = {
    c: function create() {
      path_1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path_1 = claim_svg_element(nodes, "path", {
        d: true,
        "stroke-opacity": true,
        "stroke-width": true,
        fill: true,
        class: true
      });
      children(path_1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[1]
      );
      attr_dev(path_1, "stroke-opacity", path_1_stroke_opacity_value = 0);
      attr_dev(
        path_1,
        "stroke-width",
        /*interactionWidthValue*/
        ctx[10]
      );
      attr_dev(path_1, "fill", "none");
      attr_dev(path_1, "class", "svelte-flow__edge-interaction");
      add_location(path_1, file4, 28, 2, 736);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*path*/
      2) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(28:0) {#if interactionWidthValue}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let edgelabel;
  let current;
  edgelabel = new EdgeLabel_default({
    props: {
      x: (
        /*labelX*/
        ctx[3]
      ),
      y: (
        /*labelY*/
        ctx[4]
      ),
      style: (
        /*labelStyle*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(edgelabel.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(edgelabel.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(edgelabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const edgelabel_changes = {};
      if (dirty & /*labelX*/
      8) edgelabel_changes.x = /*labelX*/
      ctx2[3];
      if (dirty & /*labelY*/
      16) edgelabel_changes.y = /*labelY*/
      ctx2[4];
      if (dirty & /*labelStyle*/
      32) edgelabel_changes.style = /*labelStyle*/
      ctx2[5];
      if (dirty & /*$$scope, label*/
      4100) {
        edgelabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      edgelabel.$set(edgelabel_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(edgelabel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(edgelabel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(edgelabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(38:0) {#if label}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      4) set_data_dev(
        t,
        /*label*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(39:2) <EdgeLabel x={labelX} y={labelY} style={labelStyle}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let path_1;
  let path_1_class_value;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*interactionWidthValue*/
    ctx[10] && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*label*/
    ctx[2] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      path_1 = svg_element("path");
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      path_1 = claim_svg_element(nodes, "path", {
        id: true,
        d: true,
        class: true,
        "marker-start": true,
        "marker-end": true,
        fill: true,
        style: true
      });
      children(path_1).forEach(detach_dev);
      t0 = claim_space(nodes);
      if (if_block0) if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        path_1,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[1]
      );
      attr_dev(path_1, "class", path_1_class_value = cc([
        "svelte-flow__edge-path",
        /*className*/
        ctx[9]
      ]));
      attr_dev(
        path_1,
        "marker-start",
        /*markerStart*/
        ctx[6]
      );
      attr_dev(
        path_1,
        "marker-end",
        /*markerEnd*/
        ctx[7]
      );
      attr_dev(path_1, "fill", "none");
      attr_dev(
        path_1,
        "style",
        /*style*/
        ctx[8]
      );
      add_location(path_1, file4, 17, 0, 548);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path_1, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*id*/
      1) {
        attr_dev(
          path_1,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*path*/
      2) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*className*/
      512 && path_1_class_value !== (path_1_class_value = cc([
        "svelte-flow__edge-path",
        /*className*/
        ctx2[9]
      ]))) {
        attr_dev(path_1, "class", path_1_class_value);
      }
      if (!current || dirty & /*markerStart*/
      64) {
        attr_dev(
          path_1,
          "marker-start",
          /*markerStart*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*markerEnd*/
      128) {
        attr_dev(
          path_1,
          "marker-end",
          /*markerEnd*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*style*/
      256) {
        attr_dev(
          path_1,
          "style",
          /*style*/
          ctx2[8]
        );
      }
      if (
        /*interactionWidthValue*/
        ctx2[10]
      ) if_block0.p(ctx2, dirty);
      if (
        /*label*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*label*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path_1);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BaseEdge", slots, []);
  let { id = void 0 } = $$props;
  let { path } = $$props;
  let { label = void 0 } = $$props;
  let { labelX = void 0 } = $$props;
  let { labelY = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { interactionWidth = 20 } = $$props;
  let { class: className = void 0 } = $$props;
  let interactionWidthValue = interactionWidth === void 0 ? 20 : interactionWidth;
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<BaseEdge> was created without expected prop 'path'");
    }
  });
  const writable_props = [
    "id",
    "path",
    "label",
    "labelX",
    "labelY",
    "labelStyle",
    "markerStart",
    "markerEnd",
    "style",
    "interactionWidth",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<BaseEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("path" in $$props2) $$invalidate(1, path = $$props2.path);
    if ("label" in $$props2) $$invalidate(2, label = $$props2.label);
    if ("labelX" in $$props2) $$invalidate(3, labelX = $$props2.labelX);
    if ("labelY" in $$props2) $$invalidate(4, labelY = $$props2.labelY);
    if ("labelStyle" in $$props2) $$invalidate(5, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2) $$invalidate(6, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(7, markerEnd = $$props2.markerEnd);
    if ("style" in $$props2) $$invalidate(8, style = $$props2.style);
    if ("interactionWidth" in $$props2) $$invalidate(11, interactionWidth = $$props2.interactionWidth);
    if ("class" in $$props2) $$invalidate(9, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    EdgeLabel: EdgeLabel_default,
    id,
    path,
    label,
    labelX,
    labelY,
    labelStyle,
    markerStart,
    markerEnd,
    style,
    interactionWidth,
    className,
    interactionWidthValue
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("path" in $$props2) $$invalidate(1, path = $$props2.path);
    if ("label" in $$props2) $$invalidate(2, label = $$props2.label);
    if ("labelX" in $$props2) $$invalidate(3, labelX = $$props2.labelX);
    if ("labelY" in $$props2) $$invalidate(4, labelY = $$props2.labelY);
    if ("labelStyle" in $$props2) $$invalidate(5, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2) $$invalidate(6, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(7, markerEnd = $$props2.markerEnd);
    if ("style" in $$props2) $$invalidate(8, style = $$props2.style);
    if ("interactionWidth" in $$props2) $$invalidate(11, interactionWidth = $$props2.interactionWidth);
    if ("className" in $$props2) $$invalidate(9, className = $$props2.className);
    if ("interactionWidthValue" in $$props2) $$invalidate(10, interactionWidthValue = $$props2.interactionWidthValue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id,
    path,
    label,
    labelX,
    labelY,
    labelStyle,
    markerStart,
    markerEnd,
    style,
    className,
    interactionWidthValue,
    interactionWidth
  ];
}
var BaseEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      id: 0,
      path: 1,
      label: 2,
      labelX: 3,
      labelY: 4,
      labelStyle: 5,
      markerStart: 6,
      markerEnd: 7,
      style: 8,
      interactionWidth: 11,
      class: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BaseEdge",
      options,
      id: create_fragment8.name
    });
  }
  get id() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get path() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelX() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelX(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelY() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelY(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BaseEdge_default = BaseEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdge.svelte
function create_fragment9(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      path: (
        /*path*/
        ctx[9]
      ),
      labelX: (
        /*labelX*/
        ctx[8]
      ),
      labelY: (
        /*labelY*/
        ctx[7]
      ),
      label: (
        /*label*/
        ctx[1]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[2]
      ),
      markerStart: (
        /*markerStart*/
        ctx[4]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[5]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[6]
      ),
      style: (
        /*style*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(baseedge.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*id*/
      1) baseedge_changes.id = /*id*/
      ctx2[0];
      if (dirty & /*path*/
      512) baseedge_changes.path = /*path*/
      ctx2[9];
      if (dirty & /*labelX*/
      256) baseedge_changes.labelX = /*labelX*/
      ctx2[8];
      if (dirty & /*labelY*/
      128) baseedge_changes.labelY = /*labelY*/
      ctx2[7];
      if (dirty & /*label*/
      2) baseedge_changes.label = /*label*/
      ctx2[1];
      if (dirty & /*labelStyle*/
      4) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[2];
      if (dirty & /*markerStart*/
      16) baseedge_changes.markerStart = /*markerStart*/
      ctx2[4];
      if (dirty & /*markerEnd*/
      32) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[5];
      if (dirty & /*interactionWidth*/
      64) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[6];
      if (dirty & /*style*/
      8) baseedge_changes.style = /*style*/
      ctx2[3];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(baseedge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BezierEdge", slots, []);
  let { id = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { pathOptions = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<BezierEdge> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<BezierEdge> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<BezierEdge> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<BezierEdge> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<BezierEdge> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<BezierEdge> was created without expected prop 'targetPosition'");
    }
  });
  const writable_props = [
    "id",
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "pathOptions",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<BezierEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
  };
  $$self.$capture_state = () => ({
    getBezierPath,
    BaseEdge: BaseEdge_default,
    id,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    pathOptions,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
    if ("labelY" in $$props2) $$invalidate(7, labelY = $$props2.labelY);
    if ("labelX" in $$props2) $$invalidate(8, labelX = $$props2.labelX);
    if ("path" in $$props2) $$invalidate(9, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, pathOptions*/
    130048) {
      $: $$invalidate(
        9,
        [path, labelX, labelY] = getBezierPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition,
          curvature: pathOptions == null ? void 0 : pathOptions.curvature
        }),
        path,
        ($$invalidate(8, labelX), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions)),
        ($$invalidate(7, labelY), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions))
      );
    }
  };
  return [
    id,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    pathOptions,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var BezierEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      id: 0,
      label: 1,
      labelStyle: 2,
      style: 3,
      markerStart: 4,
      markerEnd: 5,
      pathOptions: 10,
      interactionWidth: 6,
      sourceX: 11,
      sourceY: 12,
      sourcePosition: 13,
      targetX: 14,
      targetY: 15,
      targetPosition: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BezierEdge",
      options,
      id: create_fragment9.name
    });
  }
  get id() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathOptions() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathOptions(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BezierEdge_default = BezierEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdgeInternal.svelte
function create_fragment10(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[8]
      ),
      labelX: (
        /*labelX*/
        ctx[7]
      ),
      labelY: (
        /*labelY*/
        ctx[6]
      ),
      label: (
        /*label*/
        ctx[0]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[1]
      ),
      markerStart: (
        /*markerStart*/
        ctx[3]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[4]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[5]
      ),
      style: (
        /*style*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(baseedge.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      256) baseedge_changes.path = /*path*/
      ctx2[8];
      if (dirty & /*labelX*/
      128) baseedge_changes.labelX = /*labelX*/
      ctx2[7];
      if (dirty & /*labelY*/
      64) baseedge_changes.labelY = /*labelY*/
      ctx2[6];
      if (dirty & /*label*/
      1) baseedge_changes.label = /*label*/
      ctx2[0];
      if (dirty & /*labelStyle*/
      2) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[1];
      if (dirty & /*markerStart*/
      8) baseedge_changes.markerStart = /*markerStart*/
      ctx2[3];
      if (dirty & /*markerEnd*/
      16) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[4];
      if (dirty & /*interactionWidth*/
      32) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[5];
      if (dirty & /*style*/
      4) baseedge_changes.style = /*style*/
      ctx2[2];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(baseedge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  const omit_props_names = [
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BezierEdgeInternal", slots, []);
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$restProps;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'targetPosition'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$new_props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$new_props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$new_props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$new_props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$new_props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$new_props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$new_props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$new_props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$new_props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$new_props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$new_props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
  };
  $$self.$capture_state = () => ({
    getBezierPath,
    BaseEdge: BaseEdge_default,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
    if ("labelY" in $$props) $$invalidate(6, labelY = $$new_props.labelY);
    if ("labelX" in $$props) $$invalidate(7, labelX = $$new_props.labelX);
    if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition*/
    32256) {
      $: $$invalidate(
        8,
        [path, labelX, labelY] = getBezierPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition
        }),
        path,
        ($$invalidate(7, labelX), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition)),
        ($$invalidate(6, labelY), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition))
      );
    }
  };
  return [
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var BezierEdgeInternal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      label: 0,
      labelStyle: 1,
      style: 2,
      markerStart: 3,
      markerEnd: 4,
      interactionWidth: 5,
      sourceX: 9,
      sourceY: 10,
      sourcePosition: 11,
      targetX: 12,
      targetY: 13,
      targetPosition: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BezierEdgeInternal",
      options,
      id: create_fragment10.name
    });
  }
  get label() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BezierEdgeInternal_default = BezierEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdge.svelte
function create_fragment11(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      path: (
        /*path*/
        ctx[9]
      ),
      labelX: (
        /*labelX*/
        ctx[8]
      ),
      labelY: (
        /*labelY*/
        ctx[7]
      ),
      label: (
        /*label*/
        ctx[1]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[2]
      ),
      markerStart: (
        /*markerStart*/
        ctx[4]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[5]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[6]
      ),
      style: (
        /*style*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(baseedge.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*id*/
      1) baseedge_changes.id = /*id*/
      ctx2[0];
      if (dirty & /*path*/
      512) baseedge_changes.path = /*path*/
      ctx2[9];
      if (dirty & /*labelX*/
      256) baseedge_changes.labelX = /*labelX*/
      ctx2[8];
      if (dirty & /*labelY*/
      128) baseedge_changes.labelY = /*labelY*/
      ctx2[7];
      if (dirty & /*label*/
      2) baseedge_changes.label = /*label*/
      ctx2[1];
      if (dirty & /*labelStyle*/
      4) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[2];
      if (dirty & /*markerStart*/
      16) baseedge_changes.markerStart = /*markerStart*/
      ctx2[4];
      if (dirty & /*markerEnd*/
      32) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[5];
      if (dirty & /*interactionWidth*/
      64) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[6];
      if (dirty & /*style*/
      8) baseedge_changes.style = /*style*/
      ctx2[3];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(baseedge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SmoothStepEdge", slots, []);
  let { id = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { pathOptions = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'targetPosition'");
    }
  });
  const writable_props = [
    "id",
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "pathOptions",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<SmoothStepEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    id,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    pathOptions,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
    if ("labelY" in $$props2) $$invalidate(7, labelY = $$props2.labelY);
    if ("labelX" in $$props2) $$invalidate(8, labelX = $$props2.labelX);
    if ("path" in $$props2) $$invalidate(9, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, pathOptions*/
    130048) {
      $: $$invalidate(
        9,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition,
          borderRadius: pathOptions == null ? void 0 : pathOptions.borderRadius,
          offset: pathOptions == null ? void 0 : pathOptions.offset
        }),
        path,
        ($$invalidate(8, labelX), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions)),
        ($$invalidate(7, labelY), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions))
      );
    }
  };
  return [
    id,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    pathOptions,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var SmoothStepEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      id: 0,
      label: 1,
      labelStyle: 2,
      style: 3,
      markerStart: 4,
      markerEnd: 5,
      pathOptions: 10,
      interactionWidth: 6,
      sourceX: 11,
      sourceY: 12,
      sourcePosition: 13,
      targetX: 14,
      targetY: 15,
      targetPosition: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmoothStepEdge",
      options,
      id: create_fragment11.name
    });
  }
  get id() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathOptions() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathOptions(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SmoothStepEdge_default = SmoothStepEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdgeInternal.svelte
function create_fragment12(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[8]
      ),
      labelX: (
        /*labelX*/
        ctx[7]
      ),
      labelY: (
        /*labelY*/
        ctx[6]
      ),
      label: (
        /*label*/
        ctx[0]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[1]
      ),
      markerStart: (
        /*markerStart*/
        ctx[3]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[4]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[5]
      ),
      style: (
        /*style*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(baseedge.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      256) baseedge_changes.path = /*path*/
      ctx2[8];
      if (dirty & /*labelX*/
      128) baseedge_changes.labelX = /*labelX*/
      ctx2[7];
      if (dirty & /*labelY*/
      64) baseedge_changes.labelY = /*labelY*/
      ctx2[6];
      if (dirty & /*label*/
      1) baseedge_changes.label = /*label*/
      ctx2[0];
      if (dirty & /*labelStyle*/
      2) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[1];
      if (dirty & /*markerStart*/
      8) baseedge_changes.markerStart = /*markerStart*/
      ctx2[3];
      if (dirty & /*markerEnd*/
      16) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[4];
      if (dirty & /*interactionWidth*/
      32) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[5];
      if (dirty & /*style*/
      4) baseedge_changes.style = /*style*/
      ctx2[2];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(baseedge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  const omit_props_names = [
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SmoothStepEdgeInternal", slots, []);
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$restProps;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'targetPosition'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$new_props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$new_props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$new_props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$new_props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$new_props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$new_props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$new_props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$new_props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$new_props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$new_props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$new_props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
    if ("labelY" in $$props) $$invalidate(6, labelY = $$new_props.labelY);
    if ("labelX" in $$props) $$invalidate(7, labelX = $$new_props.labelX);
    if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition*/
    32256) {
      $: $$invalidate(
        8,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition
        }),
        path,
        ($$invalidate(7, labelX), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition)),
        ($$invalidate(6, labelY), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition))
      );
    }
  };
  return [
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var SmoothStepEdgeInternal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      label: 0,
      labelStyle: 1,
      style: 2,
      markerStart: 3,
      markerEnd: 4,
      interactionWidth: 5,
      sourceX: 9,
      sourceY: 10,
      sourcePosition: 11,
      targetX: 12,
      targetY: 13,
      targetPosition: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmoothStepEdgeInternal",
      options,
      id: create_fragment12.name
    });
  }
  get label() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SmoothStepEdgeInternal_default = SmoothStepEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdge.svelte
function create_fragment13(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      path: (
        /*path*/
        ctx[9]
      ),
      labelX: (
        /*labelX*/
        ctx[8]
      ),
      labelY: (
        /*labelY*/
        ctx[7]
      ),
      label: (
        /*label*/
        ctx[1]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[2]
      ),
      markerStart: (
        /*markerStart*/
        ctx[4]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[5]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[6]
      ),
      style: (
        /*style*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(baseedge.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*id*/
      1) baseedge_changes.id = /*id*/
      ctx2[0];
      if (dirty & /*path*/
      512) baseedge_changes.path = /*path*/
      ctx2[9];
      if (dirty & /*labelX*/
      256) baseedge_changes.labelX = /*labelX*/
      ctx2[8];
      if (dirty & /*labelY*/
      128) baseedge_changes.labelY = /*labelY*/
      ctx2[7];
      if (dirty & /*label*/
      2) baseedge_changes.label = /*label*/
      ctx2[1];
      if (dirty & /*labelStyle*/
      4) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[2];
      if (dirty & /*markerStart*/
      16) baseedge_changes.markerStart = /*markerStart*/
      ctx2[4];
      if (dirty & /*markerEnd*/
      32) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[5];
      if (dirty & /*interactionWidth*/
      64) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[6];
      if (dirty & /*style*/
      8) baseedge_changes.style = /*style*/
      ctx2[3];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(baseedge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StraightEdge", slots, []);
  let { id = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<StraightEdge> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<StraightEdge> was created without expected prop 'sourceY'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<StraightEdge> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<StraightEdge> was created without expected prop 'targetY'");
    }
  });
  const writable_props = [
    "id",
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "targetX",
    "targetY"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<StraightEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(10, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(11, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2) $$invalidate(12, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(13, targetY = $$props2.targetY);
  };
  $$self.$capture_state = () => ({
    getStraightPath,
    BaseEdge: BaseEdge_default,
    id,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    targetX,
    targetY,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(10, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(11, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2) $$invalidate(12, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(13, targetY = $$props2.targetY);
    if ("labelY" in $$props2) $$invalidate(7, labelY = $$props2.labelY);
    if ("labelX" in $$props2) $$invalidate(8, labelX = $$props2.labelX);
    if ("path" in $$props2) $$invalidate(9, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY*/
    15360) {
      $: $$invalidate(9, [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY }), path, ($$invalidate(8, labelX), $$invalidate(10, sourceX), $$invalidate(11, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY)), ($$invalidate(7, labelY), $$invalidate(10, sourceX), $$invalidate(11, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY)));
    }
  };
  return [
    id,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    targetX,
    targetY
  ];
}
var StraightEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      id: 0,
      label: 1,
      labelStyle: 2,
      style: 3,
      markerStart: 4,
      markerEnd: 5,
      interactionWidth: 6,
      sourceX: 10,
      sourceY: 11,
      targetX: 12,
      targetY: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StraightEdge",
      options,
      id: create_fragment13.name
    });
  }
  get id() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StraightEdge_default = StraightEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdgeInternal.svelte
function create_fragment14(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[8]
      ),
      labelX: (
        /*labelX*/
        ctx[7]
      ),
      labelY: (
        /*labelY*/
        ctx[6]
      ),
      label: (
        /*label*/
        ctx[0]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[1]
      ),
      markerStart: (
        /*markerStart*/
        ctx[3]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[4]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[5]
      ),
      style: (
        /*style*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(baseedge.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      256) baseedge_changes.path = /*path*/
      ctx2[8];
      if (dirty & /*labelX*/
      128) baseedge_changes.labelX = /*labelX*/
      ctx2[7];
      if (dirty & /*labelY*/
      64) baseedge_changes.labelY = /*labelY*/
      ctx2[6];
      if (dirty & /*label*/
      1) baseedge_changes.label = /*label*/
      ctx2[0];
      if (dirty & /*labelStyle*/
      2) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[1];
      if (dirty & /*markerStart*/
      8) baseedge_changes.markerStart = /*markerStart*/
      ctx2[3];
      if (dirty & /*markerEnd*/
      16) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[4];
      if (dirty & /*interactionWidth*/
      32) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[5];
      if (dirty & /*style*/
      4) baseedge_changes.style = /*style*/
      ctx2[2];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(baseedge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  const omit_props_names = [
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "targetX",
    "targetY"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StraightEdgeInternal", slots, []);
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  $$restProps;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<StraightEdgeInternal> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<StraightEdgeInternal> was created without expected prop 'sourceY'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<StraightEdgeInternal> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<StraightEdgeInternal> was created without expected prop 'targetY'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$new_props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$new_props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$new_props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$new_props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$new_props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$new_props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$new_props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("targetX" in $$new_props) $$invalidate(11, targetX = $$new_props.targetX);
    if ("targetY" in $$new_props) $$invalidate(12, targetY = $$new_props.targetY);
  };
  $$self.$capture_state = () => ({
    getStraightPath,
    BaseEdge: BaseEdge_default,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    targetX,
    targetY,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("targetX" in $$props) $$invalidate(11, targetX = $$new_props.targetX);
    if ("targetY" in $$props) $$invalidate(12, targetY = $$new_props.targetY);
    if ("labelY" in $$props) $$invalidate(6, labelY = $$new_props.labelY);
    if ("labelX" in $$props) $$invalidate(7, labelX = $$new_props.labelX);
    if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY*/
    7680) {
      $: $$invalidate(8, [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY }), path, ($$invalidate(7, labelX), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(11, targetX), $$invalidate(12, targetY)), ($$invalidate(6, labelY), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(11, targetX), $$invalidate(12, targetY)));
    }
  };
  return [
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    targetX,
    targetY
  ];
}
var StraightEdgeInternal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      label: 0,
      labelStyle: 1,
      style: 2,
      markerStart: 3,
      markerEnd: 4,
      interactionWidth: 5,
      sourceX: 9,
      sourceY: 10,
      targetX: 11,
      targetY: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StraightEdgeInternal",
      options,
      id: create_fragment14.name
    });
  }
  get label() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StraightEdgeInternal_default = StraightEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdge.svelte
function create_fragment15(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      path: (
        /*path*/
        ctx[9]
      ),
      labelX: (
        /*labelX*/
        ctx[8]
      ),
      labelY: (
        /*labelY*/
        ctx[7]
      ),
      label: (
        /*label*/
        ctx[1]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[2]
      ),
      markerStart: (
        /*markerStart*/
        ctx[4]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[5]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[6]
      ),
      style: (
        /*style*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(baseedge.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*id*/
      1) baseedge_changes.id = /*id*/
      ctx2[0];
      if (dirty & /*path*/
      512) baseedge_changes.path = /*path*/
      ctx2[9];
      if (dirty & /*labelX*/
      256) baseedge_changes.labelX = /*labelX*/
      ctx2[8];
      if (dirty & /*labelY*/
      128) baseedge_changes.labelY = /*labelY*/
      ctx2[7];
      if (dirty & /*label*/
      2) baseedge_changes.label = /*label*/
      ctx2[1];
      if (dirty & /*labelStyle*/
      4) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[2];
      if (dirty & /*markerStart*/
      16) baseedge_changes.markerStart = /*markerStart*/
      ctx2[4];
      if (dirty & /*markerEnd*/
      32) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[5];
      if (dirty & /*interactionWidth*/
      64) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[6];
      if (dirty & /*style*/
      8) baseedge_changes.style = /*style*/
      ctx2[3];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(baseedge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StepEdge", slots, []);
  let { id = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { pathOptions = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<StepEdge> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<StepEdge> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<StepEdge> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<StepEdge> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<StepEdge> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<StepEdge> was created without expected prop 'targetPosition'");
    }
  });
  const writable_props = [
    "id",
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "pathOptions",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<StepEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    id,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    pathOptions,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
    if ("labelY" in $$props2) $$invalidate(7, labelY = $$props2.labelY);
    if ("labelX" in $$props2) $$invalidate(8, labelX = $$props2.labelX);
    if ("path" in $$props2) $$invalidate(9, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, pathOptions*/
    130048) {
      $: $$invalidate(
        9,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition,
          borderRadius: 0,
          offset: pathOptions == null ? void 0 : pathOptions.offset
        }),
        path,
        ($$invalidate(8, labelX), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions)),
        ($$invalidate(7, labelY), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions))
      );
    }
  };
  return [
    id,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    pathOptions,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var StepEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      id: 0,
      label: 1,
      labelStyle: 2,
      style: 3,
      markerStart: 4,
      markerEnd: 5,
      pathOptions: 10,
      interactionWidth: 6,
      sourceX: 11,
      sourceY: 12,
      sourcePosition: 13,
      targetX: 14,
      targetY: 15,
      targetPosition: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StepEdge",
      options,
      id: create_fragment15.name
    });
  }
  get id() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathOptions() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathOptions(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StepEdge_default = StepEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdgeInternal.svelte
function create_fragment16(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[8]
      ),
      labelX: (
        /*labelX*/
        ctx[7]
      ),
      labelY: (
        /*labelY*/
        ctx[6]
      ),
      label: (
        /*label*/
        ctx[0]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[1]
      ),
      markerStart: (
        /*markerStart*/
        ctx[3]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[4]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[5]
      ),
      style: (
        /*style*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(baseedge.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      256) baseedge_changes.path = /*path*/
      ctx2[8];
      if (dirty & /*labelX*/
      128) baseedge_changes.labelX = /*labelX*/
      ctx2[7];
      if (dirty & /*labelY*/
      64) baseedge_changes.labelY = /*labelY*/
      ctx2[6];
      if (dirty & /*label*/
      1) baseedge_changes.label = /*label*/
      ctx2[0];
      if (dirty & /*labelStyle*/
      2) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[1];
      if (dirty & /*markerStart*/
      8) baseedge_changes.markerStart = /*markerStart*/
      ctx2[3];
      if (dirty & /*markerEnd*/
      16) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[4];
      if (dirty & /*interactionWidth*/
      32) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[5];
      if (dirty & /*style*/
      4) baseedge_changes.style = /*style*/
      ctx2[2];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(baseedge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  const omit_props_names = [
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StepEdgeInternal", slots, []);
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$restProps;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'targetPosition'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$new_props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$new_props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$new_props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$new_props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$new_props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$new_props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$new_props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$new_props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$new_props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$new_props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$new_props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
    if ("labelY" in $$props) $$invalidate(6, labelY = $$new_props.labelY);
    if ("labelX" in $$props) $$invalidate(7, labelX = $$new_props.labelX);
    if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition*/
    32256) {
      $: $$invalidate(
        8,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition,
          borderRadius: 0
        }),
        path,
        ($$invalidate(7, labelX), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition)),
        ($$invalidate(6, labelY), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition))
      );
    }
  };
  return [
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var StepEdgeInternal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      label: 0,
      labelStyle: 1,
      style: 2,
      markerStart: 3,
      markerEnd: 4,
      interactionWidth: 5,
      sourceX: 9,
      sourceY: 10,
      sourcePosition: 11,
      targetX: 12,
      targetY: 13,
      targetPosition: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StepEdgeInternal",
      options,
      id: create_fragment16.name
    });
  }
  get label() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StepEdgeInternal_default = StepEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/store/utils.js
function syncNodeStores(nodesStore, userNodesStore) {
  const nodesStoreSetter = nodesStore.set;
  const userNodesStoreSetter = userNodesStore.set;
  const currentNodesStore = get_store_value(nodesStore);
  const currentUserNodesStore = get_store_value(userNodesStore);
  const initWithUserNodes = currentNodesStore.length === 0 && currentUserNodesStore.length > 0;
  let val = initWithUserNodes ? currentUserNodesStore : currentNodesStore;
  nodesStore.set(val);
  const _set = (nds) => {
    const updatedNodes = nodesStoreSetter(nds);
    val = updatedNodes;
    userNodesStoreSetter(val);
    return updatedNodes;
  };
  nodesStore.set = userNodesStore.set = _set;
  nodesStore.update = userNodesStore.update = (fn) => _set(fn(val));
}
function syncEdgeStores(edgesStore, userEdgesStore) {
  const nodesStoreSetter = edgesStore.set;
  const userEdgesStoreSetter = userEdgesStore.set;
  let val = get_store_value(userEdgesStore);
  edgesStore.set(val);
  const _set = (eds) => {
    nodesStoreSetter(eds);
    userEdgesStoreSetter(eds);
    val = eds;
  };
  edgesStore.set = userEdgesStore.set = _set;
  edgesStore.update = userEdgesStore.update = (fn) => _set(fn(val));
}
var syncViewportStores = (panZoomStore, viewportStore, userViewportStore) => {
  if (!userViewportStore) {
    return;
  }
  const panZoom = get_store_value(panZoomStore);
  const viewportStoreSetter = viewportStore.set;
  const userViewportStoreSetter = userViewportStore.set;
  let val = userViewportStore ? get_store_value(userViewportStore) : { x: 0, y: 0, zoom: 1 };
  viewportStore.set(val);
  viewportStore.set = (vp) => {
    viewportStoreSetter(vp);
    userViewportStoreSetter(vp);
    val = vp;
    return vp;
  };
  userViewportStore.set = (vp) => {
    panZoom == null ? void 0 : panZoom.syncViewport(vp);
    viewportStoreSetter(vp);
    userViewportStoreSetter(vp);
    val = vp;
    return vp;
  };
  viewportStore.update = (fn) => {
    viewportStore.set(fn(val));
  };
  userViewportStore.update = (fn) => {
    userViewportStore.set(fn(val));
  };
};
var createNodesStore = (nodes, nodeLookup, parentLookup, nodeOrigin = [0, 0], nodeExtent = infiniteExtent) => {
  const { subscribe: subscribe2, set, update } = writable([]);
  let value = nodes;
  let defaults = {};
  let elevateNodesOnSelect = true;
  const _set = (nds) => {
    adoptUserNodes(nds, nodeLookup, parentLookup, {
      elevateNodesOnSelect,
      nodeOrigin,
      nodeExtent,
      defaults,
      checkEquality: false
    });
    value = nds;
    set(value);
    return value;
  };
  const _update = (fn) => _set(fn(value));
  const setDefaultOptions = (options) => {
    defaults = options;
  };
  const setOptions = (options) => {
    elevateNodesOnSelect = options.elevateNodesOnSelect ?? elevateNodesOnSelect;
  };
  _set(value);
  return {
    subscribe: subscribe2,
    set: _set,
    update: _update,
    setDefaultOptions,
    setOptions
  };
};
var createEdgesStore = (edges, connectionLookup, edgeLookup, defaultOptions2) => {
  const { subscribe: subscribe2, set, update } = writable([]);
  let value = edges;
  let defaults = defaultOptions2 || {};
  const _set = (eds) => {
    const nextEdges = defaults ? eds.map((edge) => ({ ...defaults, ...edge })) : eds;
    updateConnectionLookup(connectionLookup, edgeLookup, nextEdges);
    value = nextEdges;
    set(value);
  };
  const _update = (fn) => _set(fn(value));
  const setDefaultOptions = (options) => {
    defaults = options;
  };
  _set(value);
  return {
    subscribe: subscribe2,
    set: _set,
    update: _update,
    setDefaultOptions
  };
};

// node_modules/@xyflow/svelte/dist/lib/store/initial-store.js
var initialNodeTypes = {
  input: InputNode_default,
  output: OutputNode_default,
  default: DefaultNode_default,
  group: GroupNode_default
};
var initialEdgeTypes = {
  straight: StraightEdgeInternal_default,
  smoothstep: SmoothStepEdgeInternal_default,
  default: BezierEdgeInternal_default,
  step: StepEdgeInternal_default
};
var getInitialStore = ({ nodes = [], edges = [], width, height, fitView: fitView2, nodeOrigin, nodeExtent }) => {
  const nodeLookup = /* @__PURE__ */ new Map();
  const parentLookup = /* @__PURE__ */ new Map();
  const connectionLookup = /* @__PURE__ */ new Map();
  const edgeLookup = /* @__PURE__ */ new Map();
  const storeNodeOrigin = nodeOrigin ?? [0, 0];
  const storeNodeExtent = nodeExtent ?? infiniteExtent;
  adoptUserNodes(nodes, nodeLookup, parentLookup, {
    nodeExtent: storeNodeExtent,
    nodeOrigin: storeNodeOrigin,
    elevateNodesOnSelect: false,
    checkEquality: false
  });
  updateConnectionLookup(connectionLookup, edgeLookup, edges);
  let viewport = { x: 0, y: 0, zoom: 1 };
  if (fitView2 && width && height) {
    const bounds = getInternalNodesBounds(nodeLookup, {
      filter: (node) => !!((node.width || node.initialWidth) && (node.height || node.initialHeight))
    });
    viewport = getViewportForBounds(bounds, width, height, 0.5, 2, 0.1);
  }
  return {
    flowId: writable(null),
    nodes: createNodesStore(nodes, nodeLookup, parentLookup, storeNodeOrigin, storeNodeExtent),
    nodeLookup: readable(nodeLookup),
    parentLookup: readable(parentLookup),
    edgeLookup: readable(edgeLookup),
    visibleNodes: readable([]),
    edges: createEdgesStore(edges, connectionLookup, edgeLookup),
    visibleEdges: readable([]),
    connectionLookup: readable(connectionLookup),
    height: writable(500),
    width: writable(500),
    minZoom: writable(0.5),
    maxZoom: writable(2),
    nodeOrigin: writable(storeNodeOrigin),
    nodeDragThreshold: writable(1),
    nodeExtent: writable(storeNodeExtent),
    translateExtent: writable(infiniteExtent),
    autoPanOnNodeDrag: writable(true),
    autoPanOnConnect: writable(true),
    fitViewOnInit: writable(false),
    fitViewOnInitDone: writable(false),
    fitViewOptions: writable(void 0),
    panZoom: writable(null),
    snapGrid: writable(null),
    dragging: writable(false),
    selectionRect: writable(null),
    selectionKeyPressed: writable(false),
    multiselectionKeyPressed: writable(false),
    deleteKeyPressed: writable(false),
    panActivationKeyPressed: writable(false),
    zoomActivationKeyPressed: writable(false),
    selectionRectMode: writable(null),
    selectionMode: writable(SelectionMode.Partial),
    nodeTypes: writable(initialNodeTypes),
    edgeTypes: writable(initialEdgeTypes),
    viewport: writable(viewport),
    connectionMode: writable(ConnectionMode.Strict),
    domNode: writable(null),
    connection: readable(initialConnection),
    connectionLineType: writable(ConnectionLineType.Bezier),
    connectionRadius: writable(20),
    isValidConnection: writable(() => true),
    nodesDraggable: writable(true),
    nodesConnectable: writable(true),
    elementsSelectable: writable(true),
    selectNodesOnDrag: writable(true),
    markers: readable([]),
    defaultMarkerColor: writable("#b1b1b7"),
    lib: readable("svelte"),
    onlyRenderVisibleElements: writable(false),
    onerror: writable(devWarn),
    ondelete: writable(void 0),
    onedgecreate: writable(void 0),
    onconnect: writable(void 0),
    onconnectstart: writable(void 0),
    onconnectend: writable(void 0),
    onbeforedelete: writable(void 0),
    nodesInitialized: writable(false),
    edgesInitialized: writable(false),
    viewportInitialized: writable(false),
    initialized: readable(false)
  };
};

// node_modules/@xyflow/svelte/dist/lib/store/visible-edges.js
function getVisibleEdges(store) {
  const visibleEdges = derived([
    store.edges,
    store.nodes,
    store.nodeLookup,
    store.onlyRenderVisibleElements,
    store.viewport,
    store.width,
    store.height
  ], ([edges, , nodeLookup, onlyRenderVisibleElements, viewport, width, height]) => {
    const visibleEdges2 = onlyRenderVisibleElements && width && height ? edges.filter((edge) => {
      const sourceNode = nodeLookup.get(edge.source);
      const targetNode = nodeLookup.get(edge.target);
      return sourceNode && targetNode && isEdgeVisible({
        sourceNode,
        targetNode,
        width,
        height,
        transform: [viewport.x, viewport.y, viewport.zoom]
      });
    }) : edges;
    return visibleEdges2;
  });
  return derived([visibleEdges, store.nodes, store.nodeLookup, store.connectionMode, store.onerror], ([visibleEdges2, , nodeLookup, connectionMode, onerror]) => {
    const layoutedEdges = visibleEdges2.reduce((res, edge) => {
      const sourceNode = nodeLookup.get(edge.source);
      const targetNode = nodeLookup.get(edge.target);
      if (!sourceNode || !targetNode) {
        return res;
      }
      const edgePosition = getEdgePosition({
        id: edge.id,
        sourceNode,
        targetNode,
        sourceHandle: edge.sourceHandle || null,
        targetHandle: edge.targetHandle || null,
        connectionMode,
        onError: onerror
      });
      if (edgePosition) {
        res.push({
          ...edge,
          zIndex: getElevatedEdgeZIndex({
            selected: edge.selected,
            zIndex: edge.zIndex,
            sourceNode,
            targetNode,
            elevateOnSelect: false
          }),
          ...edgePosition
        });
      }
      return res;
    }, []);
    return layoutedEdges;
  });
}

// node_modules/@xyflow/svelte/dist/lib/store/visible-nodes.js
function getVisibleNodes(store) {
  return derived([
    store.nodeLookup,
    store.onlyRenderVisibleElements,
    store.width,
    store.height,
    store.viewport,
    store.nodes
  ], ([nodeLookup, onlyRenderVisibleElements, width, height, viewport]) => {
    const transform2 = [viewport.x, viewport.y, viewport.zoom];
    return onlyRenderVisibleElements ? getNodesInside(nodeLookup, { x: 0, y: 0, width, height }, transform2, true) : Array.from(nodeLookup.values());
  });
}

// node_modules/@xyflow/svelte/dist/lib/store/index.js
var key = Symbol();
function createStore({ nodes, edges, width, height, fitView: fitViewOnCreate, nodeOrigin, nodeExtent }) {
  const store = getInitialStore({
    nodes,
    edges,
    width,
    height,
    fitView: fitViewOnCreate,
    nodeOrigin,
    nodeExtent
  });
  function setNodeTypes(nodeTypes) {
    store.nodeTypes.set({
      ...initialNodeTypes,
      ...nodeTypes
    });
  }
  function setEdgeTypes(edgeTypes) {
    store.edgeTypes.set({
      ...initialEdgeTypes,
      ...edgeTypes
    });
  }
  function addEdge2(edgeParams) {
    const edges2 = get_store_value(store.edges);
    store.edges.set(addEdge(edgeParams, edges2));
  }
  const updateNodePositions = (nodeDragItems, dragging = false) => {
    var _a;
    const nodeLookup = get_store_value(store.nodeLookup);
    for (const [id, dragItem] of nodeDragItems) {
      const node = (_a = nodeLookup.get(id)) == null ? void 0 : _a.internals.userNode;
      if (!node) {
        continue;
      }
      node.position = dragItem.position;
      node.dragging = dragging;
    }
    store.nodes.update((nds) => nds);
  };
  function updateNodeInternals2(updates) {
    var _a, _b, _c;
    const nodeLookup = get_store_value(store.nodeLookup);
    const { changes, updatedInternals } = updateNodeInternals(updates, nodeLookup, get_store_value(store.parentLookup), get_store_value(store.domNode), get_store_value(store.nodeOrigin));
    if (!updatedInternals) {
      return;
    }
    if (!get_store_value(store.fitViewOnInitDone) && get_store_value(store.fitViewOnInit)) {
      const fitViewOptions = get_store_value(store.fitViewOptions);
      const fitViewOnInitDone = fitViewSync({
        ...fitViewOptions,
        nodes: fitViewOptions == null ? void 0 : fitViewOptions.nodes
      });
      store.fitViewOnInitDone.set(fitViewOnInitDone);
    }
    for (const change of changes) {
      const node = (_a = nodeLookup.get(change.id)) == null ? void 0 : _a.internals.userNode;
      if (!node) {
        continue;
      }
      switch (change.type) {
        case "dimensions": {
          const measured = { ...node.measured, ...change.dimensions };
          if (change.setAttributes) {
            node.width = ((_b = change.dimensions) == null ? void 0 : _b.width) ?? node.width;
            node.height = ((_c = change.dimensions) == null ? void 0 : _c.height) ?? node.height;
          }
          node.measured = measured;
          break;
        }
        case "position":
          node.position = change.position ?? node.position;
          break;
      }
    }
    store.nodes.update((nds) => nds);
    if (!get_store_value(store.nodesInitialized)) {
      store.nodesInitialized.set(true);
    }
  }
  function fitView2(options) {
    const panZoom = get_store_value(store.panZoom);
    if (!panZoom) {
      return Promise.resolve(false);
    }
    const fitViewNodes = getFitViewNodes(get_store_value(store.nodeLookup), options);
    return fitView({
      nodes: fitViewNodes,
      width: get_store_value(store.width),
      height: get_store_value(store.height),
      minZoom: get_store_value(store.minZoom),
      maxZoom: get_store_value(store.maxZoom),
      panZoom
    }, options);
  }
  function fitViewSync(options) {
    const panZoom = get_store_value(store.panZoom);
    if (!panZoom) {
      return false;
    }
    const fitViewNodes = getFitViewNodes(get_store_value(store.nodeLookup), options);
    fitView({
      nodes: fitViewNodes,
      width: get_store_value(store.width),
      height: get_store_value(store.height),
      minZoom: get_store_value(store.minZoom),
      maxZoom: get_store_value(store.maxZoom),
      panZoom
    }, options);
    return fitViewNodes.size > 0;
  }
  function zoomBy(factor, options) {
    const panZoom = get_store_value(store.panZoom);
    if (!panZoom) {
      return Promise.resolve(false);
    }
    return panZoom.scaleBy(factor, options);
  }
  function zoomIn(options) {
    return zoomBy(1.2, options);
  }
  function zoomOut(options) {
    return zoomBy(1 / 1.2, options);
  }
  function setMinZoom(minZoom) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.setScaleExtent([minZoom, get_store_value(store.maxZoom)]);
      store.minZoom.set(minZoom);
    }
  }
  function setMaxZoom(maxZoom) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.setScaleExtent([get_store_value(store.minZoom), maxZoom]);
      store.maxZoom.set(maxZoom);
    }
  }
  function setTranslateExtent(extent) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.setTranslateExtent(extent);
      store.translateExtent.set(extent);
    }
  }
  function resetSelectedElements(elements) {
    let elementsChanged = false;
    elements.forEach((element2) => {
      if (element2.selected) {
        element2.selected = false;
        elementsChanged = true;
      }
    });
    return elementsChanged;
  }
  function setPaneClickDistance(distance2) {
    var _a;
    (_a = get_store_value(store.panZoom)) == null ? void 0 : _a.setClickDistance(distance2);
  }
  function unselectNodesAndEdges(params) {
    const resetNodes = resetSelectedElements((params == null ? void 0 : params.nodes) || get_store_value(store.nodes));
    if (resetNodes)
      store.nodes.set(get_store_value(store.nodes));
    const resetEdges = resetSelectedElements((params == null ? void 0 : params.edges) || get_store_value(store.edges));
    if (resetEdges)
      store.edges.set(get_store_value(store.edges));
  }
  store.deleteKeyPressed.subscribe(async (deleteKeyPressed) => {
    var _a;
    if (deleteKeyPressed) {
      const nodes2 = get_store_value(store.nodes);
      const edges2 = get_store_value(store.edges);
      const selectedNodes = nodes2.filter((node) => node.selected);
      const selectedEdges = edges2.filter((edge) => edge.selected);
      const { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
        nodesToRemove: selectedNodes,
        edgesToRemove: selectedEdges,
        nodes: nodes2,
        edges: edges2,
        onBeforeDelete: get_store_value(store.onbeforedelete)
      });
      if (matchingNodes.length || matchingEdges.length) {
        store.nodes.update((nds) => nds.filter((node) => !matchingNodes.some((mN) => mN.id === node.id)));
        store.edges.update((eds) => eds.filter((edge) => !matchingEdges.some((mE) => mE.id === edge.id)));
        (_a = get_store_value(store.ondelete)) == null ? void 0 : _a({
          nodes: matchingNodes,
          edges: matchingEdges
        });
      }
    }
  });
  function addSelectedNodes(ids) {
    const isMultiSelection = get_store_value(store.multiselectionKeyPressed);
    store.nodes.update((ns) => ns.map((node) => {
      const nodeWillBeSelected = ids.includes(node.id);
      const selected = isMultiSelection ? node.selected || nodeWillBeSelected : nodeWillBeSelected;
      node.selected = selected;
      return node;
    }));
    if (!isMultiSelection) {
      store.edges.update((es) => es.map((edge) => {
        edge.selected = false;
        return edge;
      }));
    }
  }
  function addSelectedEdges(ids) {
    const isMultiSelection = get_store_value(store.multiselectionKeyPressed);
    store.edges.update((edges2) => edges2.map((edge) => {
      const edgeWillBeSelected = ids.includes(edge.id);
      const selected = isMultiSelection ? edge.selected || edgeWillBeSelected : edgeWillBeSelected;
      edge.selected = selected;
      return edge;
    }));
    if (!isMultiSelection) {
      store.nodes.update((ns) => ns.map((node) => {
        node.selected = false;
        return node;
      }));
    }
  }
  function handleNodeSelection(id) {
    var _a;
    const node = (_a = get_store_value(store.nodes)) == null ? void 0 : _a.find((n) => n.id === id);
    if (!node) {
      console.warn("012", errorMessages["error012"](id));
      return;
    }
    store.selectionRect.set(null);
    store.selectionRectMode.set(null);
    if (!node.selected) {
      addSelectedNodes([id]);
    } else if (node.selected && get_store_value(store.multiselectionKeyPressed)) {
      unselectNodesAndEdges({ nodes: [node], edges: [] });
    }
  }
  function panBy2(delta) {
    const viewport = get_store_value(store.viewport);
    return panBy({
      delta,
      panZoom: get_store_value(store.panZoom),
      transform: [viewport.x, viewport.y, viewport.zoom],
      translateExtent: get_store_value(store.translateExtent),
      width: get_store_value(store.width),
      height: get_store_value(store.height)
    });
  }
  const _connection = writable(initialConnection);
  const updateConnection = (newConnection) => {
    _connection.set({ ...newConnection });
  };
  function cancelConnection() {
    _connection.set(initialConnection);
  }
  function reset() {
    store.fitViewOnInitDone.set(false);
    store.selectionRect.set(null);
    store.selectionRectMode.set(null);
    store.snapGrid.set(null);
    store.isValidConnection.set(() => true);
    unselectNodesAndEdges();
    cancelConnection();
  }
  return {
    // state
    ...store,
    // derived state
    visibleEdges: getVisibleEdges(store),
    visibleNodes: getVisibleNodes(store),
    connection: derived([_connection, store.viewport], ([connection, viewport]) => {
      return connection.inProgress ? {
        ...connection,
        to: pointToRendererPoint(connection.to, [viewport.x, viewport.y, viewport.zoom])
      } : { ...connection };
    }),
    markers: derived([store.edges, store.defaultMarkerColor, store.flowId], ([edges2, defaultColor, id]) => createMarkerIds(edges2, { defaultColor, id })),
    initialized: (() => {
      let initialized = false;
      const initialNodesLength = get_store_value(store.nodes).length;
      const initialEdgesLength = get_store_value(store.edges).length;
      return derived([store.nodesInitialized, store.edgesInitialized, store.viewportInitialized], ([nodesInitialized, edgesInitialized, viewportInitialized]) => {
        if (initialized)
          return initialized;
        if (initialNodesLength === 0) {
          initialized = viewportInitialized;
        } else if (initialEdgesLength === 0) {
          initialized = viewportInitialized && nodesInitialized;
        } else {
          initialized = viewportInitialized && nodesInitialized && edgesInitialized;
        }
        return initialized;
      });
    })(),
    // actions
    syncNodeStores: (nodes2) => syncNodeStores(store.nodes, nodes2),
    syncEdgeStores: (edges2) => syncEdgeStores(store.edges, edges2),
    syncViewport: (viewport) => syncViewportStores(store.panZoom, store.viewport, viewport),
    setNodeTypes,
    setEdgeTypes,
    addEdge: addEdge2,
    updateNodePositions,
    updateNodeInternals: updateNodeInternals2,
    zoomIn,
    zoomOut,
    fitView: (options) => fitView2(options),
    setMinZoom,
    setMaxZoom,
    setTranslateExtent,
    setPaneClickDistance,
    unselectNodesAndEdges,
    addSelectedNodes,
    addSelectedEdges,
    handleNodeSelection,
    panBy: panBy2,
    updateConnection,
    cancelConnection,
    reset
  };
}
function useStore() {
  const store = getContext(key);
  if (!store) {
    throw new Error("In order to use useStore you need to wrap your component in a <SvelteFlowProvider />");
  }
  return store.getStore();
}
function createStoreContext({ nodes, edges, width, height, fitView: fitView2, nodeOrigin, nodeExtent }) {
  const store = createStore({ nodes, edges, width, height, fitView: fitView2, nodeOrigin, nodeExtent });
  setContext(key, {
    getStore: () => store
  });
  return store;
}

// node_modules/@xyflow/svelte/dist/lib/actions/zoom/index.js
function zoom(domNode, params) {
  const { panZoom, minZoom, maxZoom, initialViewport, viewport, dragging, translateExtent, paneClickDistance } = params;
  const panZoomInstance = XYPanZoom({
    domNode,
    minZoom,
    maxZoom,
    translateExtent,
    viewport: initialViewport,
    paneClickDistance,
    onDraggingChange: dragging.set
  });
  const currentViewport = panZoomInstance.getViewport();
  viewport.set(currentViewport);
  panZoom.set(panZoomInstance);
  panZoomInstance.update(params);
  return {
    update(params2) {
      panZoomInstance.update(params2);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte
var file5 = "node_modules\\@xyflow\\svelte\\dist\\lib\\container\\Zoom\\Zoom.svelte";
function add_css(target) {
  append_styles(target, "svelte-4xkw84", ".svelte-flow__zoom.svelte-4xkw84{width:100%;height:100%;position:absolute;top:0;left:0;z-index:4}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWm9vbS5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhaXVzZXI5XFxEb2N1bWVudHNcXG11a2VzaFxcbmV3LXdvcmtpbmctd2ViLW1haW5cXG5ldy13b3JraW5nLXdlYi1tYWluXFxzcGVjdHJhLWxpdGVcXG5vZGVfbW9kdWxlc1xcQHh5Zmxvd1xcc3ZlbHRlXFxkaXN0XFxsaWJcXGNvbnRhaW5lclxcWm9vbVxcWm9vbS5zdmVsdGUiXX0= */");
}
function create_fragment17(ctx) {
  let div;
  let zoom_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[35].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[34],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-flow__zoom svelte-4xkw84");
      add_location(div, file5, 26, 0, 1052);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(zoom_action = zoom.call(null, div, {
          viewport: (
            /*viewport*/
            ctx[18]
          ),
          minZoom: (
            /*$minZoom*/
            ctx[12]
          ),
          maxZoom: (
            /*$maxZoom*/
            ctx[13]
          ),
          initialViewport: (
            /*viewPort*/
            ctx[11]
          ),
          dragging: (
            /*dragging*/
            ctx[23]
          ),
          panZoom: (
            /*panZoom*/
            ctx[19]
          ),
          onPanZoomStart: (
            /*onMoveStart*/
            ctx[0]
          ),
          onPanZoom: (
            /*onMove*/
            ctx[1]
          ),
          onPanZoomEnd: (
            /*onMoveEnd*/
            ctx[2]
          ),
          zoomOnScroll: (
            /*zoomOnScroll*/
            ctx[5]
          ),
          zoomOnDoubleClick: (
            /*zoomOnDoubleClick*/
            ctx[6]
          ),
          zoomOnPinch: (
            /*zoomOnPinch*/
            ctx[7]
          ),
          panOnScroll: (
            /*_panOnScroll*/
            ctx[9]
          ),
          panOnDrag: (
            /*_panOnDrag*/
            ctx[10]
          ),
          panOnScrollSpeed: 0.5,
          panOnScrollMode: (
            /*panOnScrollMode*/
            ctx[3] || PanOnScrollMode.Free
          ),
          zoomActivationKeyPressed: (
            /*$zoomActivationKeyPressed*/
            ctx[14]
          ),
          preventScrolling: typeof /*preventScrolling*/
          ctx[4] === "boolean" ? (
            /*preventScrolling*/
            ctx[4]
          ) : true,
          noPanClassName: "nopan",
          noWheelClassName: "nowheel",
          userSelectionActive: !!/*$selectionRect*/
          ctx[15],
          translateExtent: (
            /*$translateExtent*/
            ctx[16]
          ),
          lib: (
            /*$lib*/
            ctx[17]
          ),
          paneClickDistance: (
            /*paneClickDistance*/
            ctx[8]
          ),
          onTransformChange: (
            /*onTransformChange*/
            ctx[29]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[34],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[34]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[34],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (zoom_action && is_function(zoom_action.update) && dirty[0] & /*$minZoom, $maxZoom, viewPort, onMoveStart, onMove, onMoveEnd, zoomOnScroll, zoomOnDoubleClick, zoomOnPinch, _panOnScroll, _panOnDrag, panOnScrollMode, $zoomActivationKeyPressed, preventScrolling, $selectionRect, $translateExtent, $lib, paneClickDistance*/
      262143) zoom_action.update.call(null, {
        viewport: (
          /*viewport*/
          ctx2[18]
        ),
        minZoom: (
          /*$minZoom*/
          ctx2[12]
        ),
        maxZoom: (
          /*$maxZoom*/
          ctx2[13]
        ),
        initialViewport: (
          /*viewPort*/
          ctx2[11]
        ),
        dragging: (
          /*dragging*/
          ctx2[23]
        ),
        panZoom: (
          /*panZoom*/
          ctx2[19]
        ),
        onPanZoomStart: (
          /*onMoveStart*/
          ctx2[0]
        ),
        onPanZoom: (
          /*onMove*/
          ctx2[1]
        ),
        onPanZoomEnd: (
          /*onMoveEnd*/
          ctx2[2]
        ),
        zoomOnScroll: (
          /*zoomOnScroll*/
          ctx2[5]
        ),
        zoomOnDoubleClick: (
          /*zoomOnDoubleClick*/
          ctx2[6]
        ),
        zoomOnPinch: (
          /*zoomOnPinch*/
          ctx2[7]
        ),
        panOnScroll: (
          /*_panOnScroll*/
          ctx2[9]
        ),
        panOnDrag: (
          /*_panOnDrag*/
          ctx2[10]
        ),
        panOnScrollSpeed: 0.5,
        panOnScrollMode: (
          /*panOnScrollMode*/
          ctx2[3] || PanOnScrollMode.Free
        ),
        zoomActivationKeyPressed: (
          /*$zoomActivationKeyPressed*/
          ctx2[14]
        ),
        preventScrolling: typeof /*preventScrolling*/
        ctx2[4] === "boolean" ? (
          /*preventScrolling*/
          ctx2[4]
        ) : true,
        noPanClassName: "nopan",
        noWheelClassName: "nowheel",
        userSelectionActive: !!/*$selectionRect*/
        ctx2[15],
        translateExtent: (
          /*$translateExtent*/
          ctx2[16]
        ),
        lib: (
          /*$lib*/
          ctx2[17]
        ),
        paneClickDistance: (
          /*paneClickDistance*/
          ctx2[8]
        ),
        onTransformChange: (
          /*onTransformChange*/
          ctx2[29]
        )
      });
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let viewPort;
  let _panOnDrag;
  let _panOnScroll;
  let $viewportInitialized;
  let $panActivationKeyPressed;
  let $minZoom;
  let $maxZoom;
  let $zoomActivationKeyPressed;
  let $selectionRect;
  let $translateExtent;
  let $lib;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Zoom", slots, ["default"]);
  let { initialViewport = void 0 } = $$props;
  let { onMoveStart = void 0 } = $$props;
  let { onMove = void 0 } = $$props;
  let { onMoveEnd = void 0 } = $$props;
  let { panOnScrollMode } = $$props;
  let { preventScrolling } = $$props;
  let { zoomOnScroll } = $$props;
  let { zoomOnDoubleClick } = $$props;
  let { zoomOnPinch } = $$props;
  let { panOnDrag } = $$props;
  let { panOnScroll } = $$props;
  let { paneClickDistance } = $$props;
  const { viewport, panZoom, selectionRect, minZoom, maxZoom, dragging, translateExtent, lib, panActivationKeyPressed, zoomActivationKeyPressed, viewportInitialized } = useStore();
  validate_store(selectionRect, "selectionRect");
  component_subscribe($$self, selectionRect, (value) => $$invalidate(15, $selectionRect = value));
  validate_store(minZoom, "minZoom");
  component_subscribe($$self, minZoom, (value) => $$invalidate(12, $minZoom = value));
  validate_store(maxZoom, "maxZoom");
  component_subscribe($$self, maxZoom, (value) => $$invalidate(13, $maxZoom = value));
  validate_store(translateExtent, "translateExtent");
  component_subscribe($$self, translateExtent, (value) => $$invalidate(16, $translateExtent = value));
  validate_store(lib, "lib");
  component_subscribe($$self, lib, (value) => $$invalidate(17, $lib = value));
  validate_store(panActivationKeyPressed, "panActivationKeyPressed");
  component_subscribe($$self, panActivationKeyPressed, (value) => $$invalidate(33, $panActivationKeyPressed = value));
  validate_store(zoomActivationKeyPressed, "zoomActivationKeyPressed");
  component_subscribe($$self, zoomActivationKeyPressed, (value) => $$invalidate(14, $zoomActivationKeyPressed = value));
  validate_store(viewportInitialized, "viewportInitialized");
  component_subscribe($$self, viewportInitialized, (value) => $$invalidate(36, $viewportInitialized = value));
  const onTransformChange = (transform2) => viewport.set({
    x: transform2[0],
    y: transform2[1],
    zoom: transform2[2]
  });
  onMount(() => {
    set_store_value(viewportInitialized, $viewportInitialized = true, $viewportInitialized);
  });
  $$self.$$.on_mount.push(function() {
    if (panOnScrollMode === void 0 && !("panOnScrollMode" in $$props || $$self.$$.bound[$$self.$$.props["panOnScrollMode"]])) {
      console.warn("<Zoom> was created without expected prop 'panOnScrollMode'");
    }
    if (preventScrolling === void 0 && !("preventScrolling" in $$props || $$self.$$.bound[$$self.$$.props["preventScrolling"]])) {
      console.warn("<Zoom> was created without expected prop 'preventScrolling'");
    }
    if (zoomOnScroll === void 0 && !("zoomOnScroll" in $$props || $$self.$$.bound[$$self.$$.props["zoomOnScroll"]])) {
      console.warn("<Zoom> was created without expected prop 'zoomOnScroll'");
    }
    if (zoomOnDoubleClick === void 0 && !("zoomOnDoubleClick" in $$props || $$self.$$.bound[$$self.$$.props["zoomOnDoubleClick"]])) {
      console.warn("<Zoom> was created without expected prop 'zoomOnDoubleClick'");
    }
    if (zoomOnPinch === void 0 && !("zoomOnPinch" in $$props || $$self.$$.bound[$$self.$$.props["zoomOnPinch"]])) {
      console.warn("<Zoom> was created without expected prop 'zoomOnPinch'");
    }
    if (panOnDrag === void 0 && !("panOnDrag" in $$props || $$self.$$.bound[$$self.$$.props["panOnDrag"]])) {
      console.warn("<Zoom> was created without expected prop 'panOnDrag'");
    }
    if (panOnScroll === void 0 && !("panOnScroll" in $$props || $$self.$$.bound[$$self.$$.props["panOnScroll"]])) {
      console.warn("<Zoom> was created without expected prop 'panOnScroll'");
    }
    if (paneClickDistance === void 0 && !("paneClickDistance" in $$props || $$self.$$.bound[$$self.$$.props["paneClickDistance"]])) {
      console.warn("<Zoom> was created without expected prop 'paneClickDistance'");
    }
  });
  const writable_props = [
    "initialViewport",
    "onMoveStart",
    "onMove",
    "onMoveEnd",
    "panOnScrollMode",
    "preventScrolling",
    "zoomOnScroll",
    "zoomOnDoubleClick",
    "zoomOnPinch",
    "panOnDrag",
    "panOnScroll",
    "paneClickDistance"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Zoom> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("initialViewport" in $$props2) $$invalidate(30, initialViewport = $$props2.initialViewport);
    if ("onMoveStart" in $$props2) $$invalidate(0, onMoveStart = $$props2.onMoveStart);
    if ("onMove" in $$props2) $$invalidate(1, onMove = $$props2.onMove);
    if ("onMoveEnd" in $$props2) $$invalidate(2, onMoveEnd = $$props2.onMoveEnd);
    if ("panOnScrollMode" in $$props2) $$invalidate(3, panOnScrollMode = $$props2.panOnScrollMode);
    if ("preventScrolling" in $$props2) $$invalidate(4, preventScrolling = $$props2.preventScrolling);
    if ("zoomOnScroll" in $$props2) $$invalidate(5, zoomOnScroll = $$props2.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$props2) $$invalidate(6, zoomOnDoubleClick = $$props2.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$props2) $$invalidate(7, zoomOnPinch = $$props2.zoomOnPinch);
    if ("panOnDrag" in $$props2) $$invalidate(31, panOnDrag = $$props2.panOnDrag);
    if ("panOnScroll" in $$props2) $$invalidate(32, panOnScroll = $$props2.panOnScroll);
    if ("paneClickDistance" in $$props2) $$invalidate(8, paneClickDistance = $$props2.paneClickDistance);
    if ("$$scope" in $$props2) $$invalidate(34, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    PanOnScrollMode,
    useStore,
    zoom,
    initialViewport,
    onMoveStart,
    onMove,
    onMoveEnd,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    panOnDrag,
    panOnScroll,
    paneClickDistance,
    viewport,
    panZoom,
    selectionRect,
    minZoom,
    maxZoom,
    dragging,
    translateExtent,
    lib,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    viewportInitialized,
    onTransformChange,
    _panOnScroll,
    _panOnDrag,
    viewPort,
    $viewportInitialized,
    $panActivationKeyPressed,
    $minZoom,
    $maxZoom,
    $zoomActivationKeyPressed,
    $selectionRect,
    $translateExtent,
    $lib
  });
  $$self.$inject_state = ($$props2) => {
    if ("initialViewport" in $$props2) $$invalidate(30, initialViewport = $$props2.initialViewport);
    if ("onMoveStart" in $$props2) $$invalidate(0, onMoveStart = $$props2.onMoveStart);
    if ("onMove" in $$props2) $$invalidate(1, onMove = $$props2.onMove);
    if ("onMoveEnd" in $$props2) $$invalidate(2, onMoveEnd = $$props2.onMoveEnd);
    if ("panOnScrollMode" in $$props2) $$invalidate(3, panOnScrollMode = $$props2.panOnScrollMode);
    if ("preventScrolling" in $$props2) $$invalidate(4, preventScrolling = $$props2.preventScrolling);
    if ("zoomOnScroll" in $$props2) $$invalidate(5, zoomOnScroll = $$props2.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$props2) $$invalidate(6, zoomOnDoubleClick = $$props2.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$props2) $$invalidate(7, zoomOnPinch = $$props2.zoomOnPinch);
    if ("panOnDrag" in $$props2) $$invalidate(31, panOnDrag = $$props2.panOnDrag);
    if ("panOnScroll" in $$props2) $$invalidate(32, panOnScroll = $$props2.panOnScroll);
    if ("paneClickDistance" in $$props2) $$invalidate(8, paneClickDistance = $$props2.paneClickDistance);
    if ("_panOnScroll" in $$props2) $$invalidate(9, _panOnScroll = $$props2._panOnScroll);
    if ("_panOnDrag" in $$props2) $$invalidate(10, _panOnDrag = $$props2._panOnDrag);
    if ("viewPort" in $$props2) $$invalidate(11, viewPort = $$props2.viewPort);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*initialViewport*/
    1073741824) {
      $: $$invalidate(11, viewPort = initialViewport || { x: 0, y: 0, zoom: 1 });
    }
    if ($$self.$$.dirty[1] & /*$panActivationKeyPressed, panOnDrag*/
    5) {
      $: $$invalidate(10, _panOnDrag = $panActivationKeyPressed || panOnDrag);
    }
    if ($$self.$$.dirty[1] & /*$panActivationKeyPressed, panOnScroll*/
    6) {
      $: $$invalidate(9, _panOnScroll = $panActivationKeyPressed || panOnScroll);
    }
  };
  return [
    onMoveStart,
    onMove,
    onMoveEnd,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    paneClickDistance,
    _panOnScroll,
    _panOnDrag,
    viewPort,
    $minZoom,
    $maxZoom,
    $zoomActivationKeyPressed,
    $selectionRect,
    $translateExtent,
    $lib,
    viewport,
    panZoom,
    selectionRect,
    minZoom,
    maxZoom,
    dragging,
    translateExtent,
    lib,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    viewportInitialized,
    onTransformChange,
    initialViewport,
    panOnDrag,
    panOnScroll,
    $panActivationKeyPressed,
    $$scope,
    slots
  ];
}
var Zoom = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        initialViewport: 30,
        onMoveStart: 0,
        onMove: 1,
        onMoveEnd: 2,
        panOnScrollMode: 3,
        preventScrolling: 4,
        zoomOnScroll: 5,
        zoomOnDoubleClick: 6,
        zoomOnPinch: 7,
        panOnDrag: 31,
        panOnScroll: 32,
        paneClickDistance: 8
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Zoom",
      options,
      id: create_fragment17.name
    });
  }
  get initialViewport() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialViewport(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveStart() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveStart(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMove() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMove(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveEnd() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveEnd(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScrollMode() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScrollMode(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScrolling() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScrolling(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnScroll() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnScroll(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnDoubleClick() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnDoubleClick(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnPinch() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnPinch(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnDrag() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnDrag(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScroll() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScroll(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paneClickDistance() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paneClickDistance(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Zoom_default = Zoom;

// node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte
var file6 = "node_modules\\@xyflow\\svelte\\dist\\lib\\container\\Pane\\Pane.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1esy7hx", ".svelte-flow__pane.svelte-1esy7hx{position:absolute;top:0;left:0;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFuZS5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhaXVzZXI5XFxEb2N1bWVudHNcXG11a2VzaFxcbmV3LXdvcmtpbmctd2ViLW1haW5cXG5ldy13b3JraW5nLXdlYi1tYWluXFxzcGVjdHJhLWxpdGVcXG5vZGVfbW9kdWxlc1xcQHh5Zmxvd1xcc3ZlbHRlXFxkaXN0XFxsaWJcXGNvbnRhaW5lclxcUGFuZVxcUGFuZS5zdmVsdGUiXX0= */");
}
function create_fragment18(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-flow__pane svelte-1esy7hx");
      toggle_class(
        div,
        "draggable",
        /*panOnDrag*/
        ctx[0] === true || Array.isArray(
          /*panOnDrag*/
          ctx[0]
        ) && /*panOnDrag*/
        ctx[0].includes(0)
      );
      toggle_class(
        div,
        "dragging",
        /*$dragging*/
        ctx[4]
      );
      toggle_class(
        div,
        "selection",
        /*isSelecting*/
        ctx[1]
      );
      add_location(div, file6, 131, 0, 5025);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[29](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[3] ? void 0 : wrapHandler(
                  /*onClick*/
                  ctx[15],
                  /*container*/
                  ctx[2]
                )
              )) /*hasActiveSelection*/
              (ctx[3] ? void 0 : wrapHandler(
                /*onClick*/
                ctx[15],
                /*container*/
                ctx[2]
              )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerdown",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[3] ? (
                  /*onPointerDown*/
                  ctx[16]
                ) : void 0
              )) /*hasActiveSelection*/
              (ctx[3] ? (
                /*onPointerDown*/
                ctx[16]
              ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointermove",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[3] ? (
                  /*onPointerMove*/
                  ctx[17]
                ) : void 0
              )) /*hasActiveSelection*/
              (ctx[3] ? (
                /*onPointerMove*/
                ctx[17]
              ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerup",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[3] ? (
                  /*onPointerUp*/
                  ctx[18]
                ) : void 0
              )) /*hasActiveSelection*/
              (ctx[3] ? (
                /*onPointerUp*/
                ctx[18]
              ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "contextmenu",
            function() {
              if (is_function(wrapHandler(
                /*onContextMenu*/
                ctx[19],
                /*container*/
                ctx[2]
              ))) wrapHandler(
                /*onContextMenu*/
                ctx[19],
                /*container*/
                ctx[2]
              ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[27],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*panOnDrag*/
      1) {
        toggle_class(
          div,
          "draggable",
          /*panOnDrag*/
          ctx[0] === true || Array.isArray(
            /*panOnDrag*/
            ctx[0]
          ) && /*panOnDrag*/
          ctx[0].includes(0)
        );
      }
      if (!current || dirty[0] & /*$dragging*/
      16) {
        toggle_class(
          div,
          "dragging",
          /*$dragging*/
          ctx[4]
        );
      }
      if (!current || dirty[0] & /*isSelecting*/
      2) {
        toggle_class(
          div,
          "selection",
          /*isSelecting*/
          ctx[1]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function wrapHandler(handler, container) {
  return (event) => {
    if (event.target !== container) {
      return;
    }
    handler == null ? void 0 : handler(event);
  };
}
function toggleSelected(ids) {
  return (item) => {
    const isSelected = ids.includes(item.id);
    if (item.selected !== isSelected) {
      item.selected = isSelected;
    }
    return item;
  };
}
function instance18($$self, $$props, $$invalidate) {
  let _panOnDrag;
  let isSelecting;
  let hasActiveSelection;
  let $selectionKeyPressed;
  let $selectionRectMode;
  let $edges;
  let $selectionMode;
  let $viewport;
  let $nodeLookup;
  let $selectionRect;
  let $elementsSelectable;
  let $panActivationKeyPressed;
  let $dragging;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pane", slots, ["default"]);
  let { panOnDrag = void 0 } = $$props;
  let { selectionOnDrag = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const { nodes, nodeLookup, edges, viewport, dragging, elementsSelectable, selectionRect, selectionRectMode, selectionKeyPressed, selectionMode, panActivationKeyPressed, unselectNodesAndEdges } = useStore();
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(36, $nodeLookup = value));
  validate_store(edges, "edges");
  component_subscribe($$self, edges, (value) => $$invalidate(33, $edges = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(35, $viewport = value));
  validate_store(dragging, "dragging");
  component_subscribe($$self, dragging, (value) => $$invalidate(4, $dragging = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(25, $elementsSelectable = value));
  validate_store(selectionRect, "selectionRect");
  component_subscribe($$self, selectionRect, (value) => $$invalidate(24, $selectionRect = value));
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(23, $selectionRectMode = value));
  validate_store(selectionKeyPressed, "selectionKeyPressed");
  component_subscribe($$self, selectionKeyPressed, (value) => $$invalidate(22, $selectionKeyPressed = value));
  validate_store(selectionMode, "selectionMode");
  component_subscribe($$self, selectionMode, (value) => $$invalidate(34, $selectionMode = value));
  validate_store(panActivationKeyPressed, "panActivationKeyPressed");
  component_subscribe($$self, panActivationKeyPressed, (value) => $$invalidate(26, $panActivationKeyPressed = value));
  let container;
  let containerBounds = null;
  let selectedNodes = [];
  let selectionInProgress = false;
  function onClick(event) {
    if (selectionInProgress) {
      selectionInProgress = false;
      return;
    }
    dispatch("paneclick", { event });
    unselectNodesAndEdges();
    selectionRectMode.set(null);
  }
  function onPointerDown2(event) {
    var _a, _b;
    containerBounds = container.getBoundingClientRect();
    if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container || !containerBounds) {
      return;
    }
    (_b = (_a = event.target) == null ? void 0 : _a.setPointerCapture) == null ? void 0 : _b.call(_a, event.pointerId);
    const { x, y } = getEventPosition(event, containerBounds);
    unselectNodesAndEdges();
    selectionRect.set({
      width: 0,
      height: 0,
      startX: x,
      startY: y,
      x,
      y
    });
  }
  function onPointerMove(event) {
    if (!isSelecting || !containerBounds || !$selectionRect) {
      return;
    }
    selectionInProgress = true;
    const mousePos = getEventPosition(event, containerBounds);
    const startX = $selectionRect.startX ?? 0;
    const startY = $selectionRect.startY ?? 0;
    const nextUserSelectRect = {
      ...$selectionRect,
      x: mousePos.x < startX ? mousePos.x : startX,
      y: mousePos.y < startY ? mousePos.y : startY,
      width: Math.abs(mousePos.x - startX),
      height: Math.abs(mousePos.y - startY)
    };
    const prevSelectedNodeIds = selectedNodes.map((n) => n.id);
    const prevSelectedEdgeIds = getConnectedEdges(selectedNodes, $edges).map((e) => e.id);
    selectedNodes = getNodesInside($nodeLookup, nextUserSelectRect, [$viewport.x, $viewport.y, $viewport.zoom], $selectionMode === SelectionMode.Partial, true);
    const selectedEdgeIds = getConnectedEdges(selectedNodes, $edges).map((e) => e.id);
    const selectedNodeIds = selectedNodes.map((n) => n.id);
    if (prevSelectedNodeIds.length !== selectedNodeIds.length || selectedNodeIds.some((id) => !prevSelectedNodeIds.includes(id))) {
      nodes.update((nodes2) => nodes2.map(toggleSelected(selectedNodeIds)));
    }
    if (prevSelectedEdgeIds.length !== selectedEdgeIds.length || selectedEdgeIds.some((id) => !prevSelectedEdgeIds.includes(id))) {
      edges.update((edges2) => edges2.map(toggleSelected(selectedEdgeIds)));
    }
    selectionRectMode.set("user");
    selectionRect.set(nextUserSelectRect);
  }
  function onPointerUp(event) {
    var _a, _b;
    if (event.button !== 0) {
      return;
    }
    (_b = (_a = event.target) == null ? void 0 : _a.releasePointerCapture) == null ? void 0 : _b.call(_a, event.pointerId);
    if (!isSelecting && $selectionRectMode === "user" && event.target === container) {
      onClick == null ? void 0 : onClick(event);
    }
    selectionRect.set(null);
    if (selectedNodes.length > 0) {
      set_store_value(selectionRectMode, $selectionRectMode = "nodes", $selectionRectMode);
    }
    if ($selectionKeyPressed) {
      selectionInProgress = false;
    }
  }
  const onContextMenu = (event) => {
    if (Array.isArray(_panOnDrag) && (_panOnDrag == null ? void 0 : _panOnDrag.includes(2))) {
      event.preventDefault();
      return;
    }
    dispatch("panecontextmenu", { event });
  };
  const writable_props = ["panOnDrag", "selectionOnDrag"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Pane> was created with unknown prop '${key2}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(2, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("panOnDrag" in $$props2) $$invalidate(0, panOnDrag = $$props2.panOnDrag);
    if ("selectionOnDrag" in $$props2) $$invalidate(20, selectionOnDrag = $$props2.selectionOnDrag);
    if ("$$scope" in $$props2) $$invalidate(27, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    wrapHandler,
    toggleSelected,
    createEventDispatcher,
    SelectionMode,
    getEventPosition,
    getNodesInside,
    getConnectedEdges,
    useStore,
    panOnDrag,
    selectionOnDrag,
    dispatch,
    nodes,
    nodeLookup,
    edges,
    viewport,
    dragging,
    elementsSelectable,
    selectionRect,
    selectionRectMode,
    selectionKeyPressed,
    selectionMode,
    panActivationKeyPressed,
    unselectNodesAndEdges,
    container,
    containerBounds,
    selectedNodes,
    selectionInProgress,
    onClick,
    onPointerDown: onPointerDown2,
    onPointerMove,
    onPointerUp,
    onContextMenu,
    _panOnDrag,
    isSelecting,
    hasActiveSelection,
    $selectionKeyPressed,
    $selectionRectMode,
    $edges,
    $selectionMode,
    $viewport,
    $nodeLookup,
    $selectionRect,
    $elementsSelectable,
    $panActivationKeyPressed,
    $dragging
  });
  $$self.$inject_state = ($$props2) => {
    if ("panOnDrag" in $$props2) $$invalidate(0, panOnDrag = $$props2.panOnDrag);
    if ("selectionOnDrag" in $$props2) $$invalidate(20, selectionOnDrag = $$props2.selectionOnDrag);
    if ("container" in $$props2) $$invalidate(2, container = $$props2.container);
    if ("containerBounds" in $$props2) containerBounds = $$props2.containerBounds;
    if ("selectedNodes" in $$props2) selectedNodes = $$props2.selectedNodes;
    if ("selectionInProgress" in $$props2) selectionInProgress = $$props2.selectionInProgress;
    if ("_panOnDrag" in $$props2) $$invalidate(21, _panOnDrag = $$props2._panOnDrag);
    if ("isSelecting" in $$props2) $$invalidate(1, isSelecting = $$props2.isSelecting);
    if ("hasActiveSelection" in $$props2) $$invalidate(3, hasActiveSelection = $$props2.hasActiveSelection);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$panActivationKeyPressed, panOnDrag*/
    67108865) {
      $: $$invalidate(21, _panOnDrag = $panActivationKeyPressed || panOnDrag);
    }
    if ($$self.$$.dirty[0] & /*$selectionKeyPressed, $selectionRect, selectionOnDrag, _panOnDrag*/
    24117248) {
      $: $$invalidate(1, isSelecting = $selectionKeyPressed || $selectionRect || selectionOnDrag && _panOnDrag !== true);
    }
    if ($$self.$$.dirty[0] & /*$elementsSelectable, isSelecting, $selectionRectMode*/
    41943042) {
      $: $$invalidate(3, hasActiveSelection = $elementsSelectable && (isSelecting || $selectionRectMode === "user"));
    }
  };
  return [
    panOnDrag,
    isSelecting,
    container,
    hasActiveSelection,
    $dragging,
    nodeLookup,
    edges,
    viewport,
    dragging,
    elementsSelectable,
    selectionRect,
    selectionRectMode,
    selectionKeyPressed,
    selectionMode,
    panActivationKeyPressed,
    onClick,
    onPointerDown2,
    onPointerMove,
    onPointerUp,
    onContextMenu,
    selectionOnDrag,
    _panOnDrag,
    $selectionKeyPressed,
    $selectionRectMode,
    $selectionRect,
    $elementsSelectable,
    $panActivationKeyPressed,
    $$scope,
    slots,
    div_binding
  ];
}
var Pane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { panOnDrag: 0, selectionOnDrag: 20 }, add_css2, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pane",
      options,
      id: create_fragment18.name
    });
  }
  get panOnDrag() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnDrag(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionOnDrag() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionOnDrag(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pane_default = Pane;

// node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte
var file7 = "node_modules\\@xyflow\\svelte\\dist\\lib\\container\\Viewport\\Viewport.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1floaup", ".svelte-flow__viewport.svelte-1floaup{width:100%;height:100%;position:absolute;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlld3BvcnQuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWl1c2VyOVxcRG9jdW1lbnRzXFxtdWtlc2hcXG5ldy13b3JraW5nLXdlYi1tYWluXFxuZXctd29ya2luZy13ZWItbWFpblxcc3BlY3RyYS1saXRlXFxub2RlX21vZHVsZXNcXEB4eWZsb3dcXHN2ZWx0ZVxcZGlzdFxcbGliXFxjb250YWluZXJcXFZpZXdwb3J0XFxWaWV3cG9ydC5zdmVsdGUiXX0= */");
}
function create_fragment19(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-flow__viewport xyflow__viewport svelte-1floaup");
      set_style(div, "transform", "translate(" + /*$viewport*/
      ctx[0].x + "px, " + /*$viewport*/
      ctx[0].y + "px) scale(" + /*$viewport*/
      ctx[0].zoom + ")");
      add_location(div, file7, 4, 0, 92);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$viewport*/
      1) {
        set_style(div, "transform", "translate(" + /*$viewport*/
        ctx2[0].x + "px, " + /*$viewport*/
        ctx2[0].y + "px) scale(" + /*$viewport*/
        ctx2[0].zoom + ")");
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let $viewport;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Viewport", slots, ["default"]);
  const { viewport } = useStore();
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(0, $viewport = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Viewport> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ useStore, viewport, $viewport });
  return [$viewport, viewport, $$scope, slots];
}
var Viewport = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {}, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Viewport",
      options,
      id: create_fragment19.name
    });
  }
};
var Viewport_default = Viewport;

// node_modules/@xyflow/svelte/dist/lib/actions/drag/index.js
function drag(domNode, params) {
  const { store, onDrag, onDragStart, onDragStop, onNodeMouseDown } = params;
  const dragInstance = XYDrag({
    onDrag,
    onDragStart,
    onDragStop,
    onNodeMouseDown,
    getStoreItems: () => {
      const snapGrid = get_store_value(store.snapGrid);
      const vp = get_store_value(store.viewport);
      return {
        nodes: get_store_value(store.nodes),
        nodeLookup: get_store_value(store.nodeLookup),
        edges: get_store_value(store.edges),
        nodeExtent: get_store_value(store.nodeExtent),
        snapGrid: snapGrid ? snapGrid : [0, 0],
        snapToGrid: !!snapGrid,
        nodeOrigin: get_store_value(store.nodeOrigin),
        multiSelectionActive: get_store_value(store.multiselectionKeyPressed),
        domNode: get_store_value(store.domNode),
        transform: [vp.x, vp.y, vp.zoom],
        autoPanOnNodeDrag: get_store_value(store.autoPanOnNodeDrag),
        nodesDraggable: get_store_value(store.nodesDraggable),
        selectNodesOnDrag: get_store_value(store.selectNodesOnDrag),
        nodeDragThreshold: get_store_value(store.nodeDragThreshold),
        unselectNodesAndEdges: store.unselectNodesAndEdges,
        updateNodePositions: store.updateNodePositions,
        panBy: store.panBy
      };
    }
  });
  function updateDrag(domNode2, params2) {
    if (params2.disabled) {
      dragInstance.destroy();
      return;
    }
    dragInstance.update({
      domNode: domNode2,
      noDragClassName: params2.noDragClass,
      handleSelector: params2.handleSelector,
      nodeId: params2.nodeId,
      isSelectable: params2.isSelectable,
      nodeClickDistance: params2.nodeClickDistance
    });
  }
  updateDrag(domNode, params);
  return {
    update(params2) {
      updateDrag(domNode, params2);
    },
    destroy() {
      dragInstance.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/utils.js
function getNodeInlineStyleDimensions({ width, height, initialWidth, initialHeight, measuredWidth, measuredHeight }) {
  if (measuredWidth === void 0 && measuredHeight === void 0) {
    const styleWidth = width ?? initialWidth;
    const styleHeight = height ?? initialHeight;
    return {
      width: styleWidth ? `width:${styleWidth}px;` : "",
      height: styleHeight ? `height:${styleHeight}px;` : ""
    };
  }
  return {
    width: width ? `width:${width}px;` : "",
    height: height ? `height:${height}px;` : ""
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte
var { console: console_1 } = globals;
var file8 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\NodeWrapper\\NodeWrapper.svelte";
function create_if_block2(ctx) {
  let div;
  let switch_instance;
  let div_class_value;
  let div_style_value;
  let drag_action;
  let style_transform = `translate(${/*positionX*/
  ctx[12]}px, ${/*positionY*/
  ctx[13]}px)`;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*nodeComponent*/
    ctx[27]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        data: (
          /*data*/
          ctx2[2]
        ),
        id: (
          /*id*/
          ctx2[1]
        ),
        selected: (
          /*selected*/
          ctx2[3]
        ),
        selectable: (
          /*selectable*/
          ctx2[5]
        ),
        deletable: (
          /*deletable*/
          ctx2[7]
        ),
        sourcePosition: (
          /*sourcePosition*/
          ctx2[14]
        ),
        targetPosition: (
          /*targetPosition*/
          ctx2[15]
        ),
        zIndex: (
          /*zIndex*/
          ctx2[16]
        ),
        dragging: (
          /*dragging*/
          ctx2[9]
        ),
        draggable: (
          /*draggable*/
          ctx2[4]
        ),
        dragHandle: (
          /*dragHandle*/
          ctx2[19]
        ),
        parentId: (
          /*parentId*/
          ctx2[21]
        ),
        type: (
          /*nodeType*/
          ctx2[25]
        ),
        isConnectable: (
          /*$connectableStore*/
          ctx2[28]
        ),
        positionAbsoluteX: (
          /*positionX*/
          ctx2[12]
        ),
        positionAbsoluteY: (
          /*positionY*/
          ctx2[13]
        ),
        width: (
          /*width*/
          ctx2[17]
        ),
        height: (
          /*height*/
          ctx2[18]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-id": true,
        class: true,
        style: true
      });
      var div_nodes = children(div);
      if (switch_instance) claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "data-id",
        /*id*/
        ctx[1]
      );
      attr_dev(div, "class", div_class_value = cc([
        "svelte-flow__node",
        `svelte-flow__node-${/*nodeType*/
        ctx[25]}`,
        /*className*/
        ctx[23]
      ]));
      attr_dev(div, "style", div_style_value = /*style*/
      (ctx[10] ?? "") + ";" + /*inlineStyleDimensions*/
      ctx[26].width + /*inlineStyleDimensions*/
      ctx[26].height);
      toggle_class(
        div,
        "dragging",
        /*dragging*/
        ctx[9]
      );
      toggle_class(
        div,
        "selected",
        /*selected*/
        ctx[3]
      );
      toggle_class(
        div,
        "draggable",
        /*draggable*/
        ctx[4]
      );
      toggle_class(
        div,
        "connectable",
        /*connectable*/
        ctx[6]
      );
      toggle_class(
        div,
        "selectable",
        /*selectable*/
        ctx[5]
      );
      toggle_class(
        div,
        "nopan",
        /*draggable*/
        ctx[4]
      );
      toggle_class(
        div,
        "parent",
        /*isParent*/
        ctx[11]
      );
      set_style(
        div,
        "z-index",
        /*zIndex*/
        ctx[16]
      );
      set_style(div, "transform", style_transform);
      set_style(
        div,
        "visibility",
        /*initialized*/
        ctx[20] ? "visible" : "hidden"
      );
      add_location(div, file8, 118, 2, 3874);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (switch_instance) mount_component(switch_instance, div, null);
      ctx[50](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(drag_action = drag.call(null, div, {
            nodeId: (
              /*id*/
              ctx[1]
            ),
            isSelectable: (
              /*selectable*/
              ctx[5]
            ),
            disabled: false,
            handleSelector: (
              /*dragHandle*/
              ctx[19]
            ),
            noDragClass: "nodrag",
            nodeClickDistance: (
              /*nodeClickDistance*/
              ctx[22]
            ),
            onNodeMouseDown: (
              /*handleNodeSelection*/
              ctx[31]
            ),
            onDrag: (
              /*drag_function*/
              ctx[47]
            ),
            onDragStart: (
              /*drag_function_1*/
              ctx[48]
            ),
            onDragStop: (
              /*drag_function_2*/
              ctx[49]
            ),
            store: (
              /*store*/
              ctx[29]
            )
          })),
          listen_dev(
            div,
            "click",
            /*onSelectNodeHandler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[51],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousemove",
            /*mousemove_handler*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[54],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nodeComponent*/
      134217728 && switch_value !== (switch_value = /*nodeComponent*/
      ctx2[27])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*data*/
        4) switch_instance_changes.data = /*data*/
        ctx2[2];
        if (dirty[0] & /*id*/
        2) switch_instance_changes.id = /*id*/
        ctx2[1];
        if (dirty[0] & /*selected*/
        8) switch_instance_changes.selected = /*selected*/
        ctx2[3];
        if (dirty[0] & /*selectable*/
        32) switch_instance_changes.selectable = /*selectable*/
        ctx2[5];
        if (dirty[0] & /*deletable*/
        128) switch_instance_changes.deletable = /*deletable*/
        ctx2[7];
        if (dirty[0] & /*sourcePosition*/
        16384) switch_instance_changes.sourcePosition = /*sourcePosition*/
        ctx2[14];
        if (dirty[0] & /*targetPosition*/
        32768) switch_instance_changes.targetPosition = /*targetPosition*/
        ctx2[15];
        if (dirty[0] & /*zIndex*/
        65536) switch_instance_changes.zIndex = /*zIndex*/
        ctx2[16];
        if (dirty[0] & /*dragging*/
        512) switch_instance_changes.dragging = /*dragging*/
        ctx2[9];
        if (dirty[0] & /*draggable*/
        16) switch_instance_changes.draggable = /*draggable*/
        ctx2[4];
        if (dirty[0] & /*dragHandle*/
        524288) switch_instance_changes.dragHandle = /*dragHandle*/
        ctx2[19];
        if (dirty[0] & /*parentId*/
        2097152) switch_instance_changes.parentId = /*parentId*/
        ctx2[21];
        if (dirty[0] & /*nodeType*/
        33554432) switch_instance_changes.type = /*nodeType*/
        ctx2[25];
        if (dirty[0] & /*$connectableStore*/
        268435456) switch_instance_changes.isConnectable = /*$connectableStore*/
        ctx2[28];
        if (dirty[0] & /*positionX*/
        4096) switch_instance_changes.positionAbsoluteX = /*positionX*/
        ctx2[12];
        if (dirty[0] & /*positionY*/
        8192) switch_instance_changes.positionAbsoluteY = /*positionY*/
        ctx2[13];
        if (dirty[0] & /*width*/
        131072) switch_instance_changes.width = /*width*/
        ctx2[17];
        if (dirty[0] & /*height*/
        262144) switch_instance_changes.height = /*height*/
        ctx2[18];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*id*/
      2) {
        attr_dev(
          div,
          "data-id",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*nodeType, className*/
      41943040 && div_class_value !== (div_class_value = cc([
        "svelte-flow__node",
        `svelte-flow__node-${/*nodeType*/
        ctx2[25]}`,
        /*className*/
        ctx2[23]
      ]))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*style, inlineStyleDimensions*/
      67109888 && div_style_value !== (div_style_value = /*style*/
      (ctx2[10] ?? "") + ";" + /*inlineStyleDimensions*/
      ctx2[26].width + /*inlineStyleDimensions*/
      ctx2[26].height)) {
        attr_dev(div, "style", div_style_value);
      }
      if (drag_action && is_function(drag_action.update) && dirty[0] & /*id, selectable, dragHandle, nodeClickDistance*/
      4718626) drag_action.update.call(null, {
        nodeId: (
          /*id*/
          ctx2[1]
        ),
        isSelectable: (
          /*selectable*/
          ctx2[5]
        ),
        disabled: false,
        handleSelector: (
          /*dragHandle*/
          ctx2[19]
        ),
        noDragClass: "nodrag",
        nodeClickDistance: (
          /*nodeClickDistance*/
          ctx2[22]
        ),
        onNodeMouseDown: (
          /*handleNodeSelection*/
          ctx2[31]
        ),
        onDrag: (
          /*drag_function*/
          ctx2[47]
        ),
        onDragStart: (
          /*drag_function_1*/
          ctx2[48]
        ),
        onDragStop: (
          /*drag_function_2*/
          ctx2[49]
        ),
        store: (
          /*store*/
          ctx2[29]
        )
      });
      if (!current || dirty[0] & /*nodeType, className, dragging*/
      41943552) {
        toggle_class(
          div,
          "dragging",
          /*dragging*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, selected*/
      41943048) {
        toggle_class(
          div,
          "selected",
          /*selected*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, draggable*/
      41943056) {
        toggle_class(
          div,
          "draggable",
          /*draggable*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, connectable*/
      41943104) {
        toggle_class(
          div,
          "connectable",
          /*connectable*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, selectable*/
      41943072) {
        toggle_class(
          div,
          "selectable",
          /*selectable*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, draggable*/
      41943056) {
        toggle_class(
          div,
          "nopan",
          /*draggable*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, isParent*/
      41945088) {
        toggle_class(
          div,
          "parent",
          /*isParent*/
          ctx2[11]
        );
      }
      const style_changed = dirty[0] & /*style, inlineStyleDimensions*/
      67109888;
      if (dirty[0] & /*zIndex, style, inlineStyleDimensions*/
      67175424 || style_changed) {
        set_style(
          div,
          "z-index",
          /*zIndex*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*positionX, positionY, style, inlineStyleDimensions*/
      67122176 && style_transform !== (style_transform = `translate(${/*positionX*/
      ctx2[12]}px, ${/*positionY*/
      ctx2[13]}px)`) || style_changed) {
        set_style(div, "transform", style_transform);
      }
      if (dirty[0] & /*initialized, style, inlineStyleDimensions*/
      68158464 || style_changed) {
        set_style(
          div,
          "visibility",
          /*initialized*/
          ctx2[20] ? "visible" : "hidden"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (switch_instance) destroy_component(switch_instance);
      ctx[50](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(118:0) {#if !hidden}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*hidden*/
  ctx[8] && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*hidden*/
      ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*hidden*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let nodeType;
  let nodeTypeValid;
  let nodeComponent;
  let inlineStyleDimensions;
  let $nodeTypes;
  let $connectableStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeWrapper", slots, []);
  let { node } = $$props;
  let { id } = $$props;
  let { data = {} } = $$props;
  let { selected = false } = $$props;
  let { draggable = void 0 } = $$props;
  let { selectable = void 0 } = $$props;
  let { connectable = true } = $$props;
  let { deletable = true } = $$props;
  let { hidden = false } = $$props;
  let { dragging = false } = $$props;
  let { resizeObserver = null } = $$props;
  let { style = void 0 } = $$props;
  let { type = "default" } = $$props;
  let { isParent = false } = $$props;
  let { positionX } = $$props;
  let { positionY } = $$props;
  let { sourcePosition = void 0 } = $$props;
  let { targetPosition = void 0 } = $$props;
  let { zIndex } = $$props;
  let { measuredWidth = void 0 } = $$props;
  let { measuredHeight = void 0 } = $$props;
  let { initialWidth = void 0 } = $$props;
  let { initialHeight = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { dragHandle = void 0 } = $$props;
  let { initialized = false } = $$props;
  let { parentId = void 0 } = $$props;
  let { nodeClickDistance = void 0 } = $$props;
  let { class: className = "" } = $$props;
  const store = useStore();
  const { nodeTypes, nodeDragThreshold, selectNodesOnDrag, handleNodeSelection, updateNodeInternals: updateNodeInternals2 } = store;
  validate_store(nodeTypes, "nodeTypes");
  component_subscribe($$self, nodeTypes, (value) => $$invalidate(46, $nodeTypes = value));
  let nodeRef;
  let prevNodeRef = null;
  const dispatchNodeEvent = createEventDispatcher();
  const connectableStore = writable(connectable);
  validate_store(connectableStore, "connectableStore");
  component_subscribe($$self, connectableStore, (value) => $$invalidate(28, $connectableStore = value));
  let prevType = void 0;
  let prevSourcePosition = void 0;
  let prevTargetPosition = void 0;
  setContext("svelteflow__node_id", id);
  setContext("svelteflow__node_connectable", connectableStore);
  onDestroy(() => {
    if (prevNodeRef) {
      resizeObserver == null ? void 0 : resizeObserver.unobserve(prevNodeRef);
    }
  });
  function onSelectNodeHandler(event) {
    if (selectable && (!get_store_value(selectNodesOnDrag) || !draggable || get_store_value(nodeDragThreshold) > 0)) {
      handleNodeSelection(id);
    }
    dispatchNodeEvent("nodeclick", { node: node.internals.userNode, event });
  }
  $$self.$$.on_mount.push(function() {
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'node'");
    }
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'id'");
    }
    if (positionX === void 0 && !("positionX" in $$props || $$self.$$.bound[$$self.$$.props["positionX"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'positionX'");
    }
    if (positionY === void 0 && !("positionY" in $$props || $$self.$$.bound[$$self.$$.props["positionY"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'positionY'");
    }
    if (zIndex === void 0 && !("zIndex" in $$props || $$self.$$.bound[$$self.$$.props["zIndex"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'zIndex'");
    }
  });
  const writable_props = [
    "node",
    "id",
    "data",
    "selected",
    "draggable",
    "selectable",
    "connectable",
    "deletable",
    "hidden",
    "dragging",
    "resizeObserver",
    "style",
    "type",
    "isParent",
    "positionX",
    "positionY",
    "sourcePosition",
    "targetPosition",
    "zIndex",
    "measuredWidth",
    "measuredHeight",
    "initialWidth",
    "initialHeight",
    "width",
    "height",
    "dragHandle",
    "initialized",
    "parentId",
    "nodeClickDistance",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console_1.warn(`<NodeWrapper> was created with unknown prop '${key2}'`);
  });
  const drag_function = (event, _, targetNode, nodes) => {
    dispatchNodeEvent("nodedrag", { event, targetNode, nodes });
  };
  const drag_function_1 = (event, _, targetNode, nodes) => {
    dispatchNodeEvent("nodedragstart", { event, targetNode, nodes });
  };
  const drag_function_2 = (event, _, targetNode, nodes) => {
    dispatchNodeEvent("nodedragstop", { event, targetNode, nodes });
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nodeRef = $$value;
      $$invalidate(24, nodeRef);
    });
  }
  const mouseenter_handler = (event) => dispatchNodeEvent("nodemouseenter", { node, event });
  const mouseleave_handler = (event) => dispatchNodeEvent("nodemouseleave", { node, event });
  const mousemove_handler = (event) => dispatchNodeEvent("nodemousemove", { node, event });
  const contextmenu_handler = (event) => dispatchNodeEvent("nodecontextmenu", { node, event });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2) $$invalidate(0, node = $$props2.node);
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("selected" in $$props2) $$invalidate(3, selected = $$props2.selected);
    if ("draggable" in $$props2) $$invalidate(4, draggable = $$props2.draggable);
    if ("selectable" in $$props2) $$invalidate(5, selectable = $$props2.selectable);
    if ("connectable" in $$props2) $$invalidate(6, connectable = $$props2.connectable);
    if ("deletable" in $$props2) $$invalidate(7, deletable = $$props2.deletable);
    if ("hidden" in $$props2) $$invalidate(8, hidden = $$props2.hidden);
    if ("dragging" in $$props2) $$invalidate(9, dragging = $$props2.dragging);
    if ("resizeObserver" in $$props2) $$invalidate(35, resizeObserver = $$props2.resizeObserver);
    if ("style" in $$props2) $$invalidate(10, style = $$props2.style);
    if ("type" in $$props2) $$invalidate(36, type = $$props2.type);
    if ("isParent" in $$props2) $$invalidate(11, isParent = $$props2.isParent);
    if ("positionX" in $$props2) $$invalidate(12, positionX = $$props2.positionX);
    if ("positionY" in $$props2) $$invalidate(13, positionY = $$props2.positionY);
    if ("sourcePosition" in $$props2) $$invalidate(14, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2) $$invalidate(15, targetPosition = $$props2.targetPosition);
    if ("zIndex" in $$props2) $$invalidate(16, zIndex = $$props2.zIndex);
    if ("measuredWidth" in $$props2) $$invalidate(37, measuredWidth = $$props2.measuredWidth);
    if ("measuredHeight" in $$props2) $$invalidate(38, measuredHeight = $$props2.measuredHeight);
    if ("initialWidth" in $$props2) $$invalidate(39, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2) $$invalidate(40, initialHeight = $$props2.initialHeight);
    if ("width" in $$props2) $$invalidate(17, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(18, height = $$props2.height);
    if ("dragHandle" in $$props2) $$invalidate(19, dragHandle = $$props2.dragHandle);
    if ("initialized" in $$props2) $$invalidate(20, initialized = $$props2.initialized);
    if ("parentId" in $$props2) $$invalidate(21, parentId = $$props2.parentId);
    if ("nodeClickDistance" in $$props2) $$invalidate(22, nodeClickDistance = $$props2.nodeClickDistance);
    if ("class" in $$props2) $$invalidate(23, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    setContext,
    onDestroy,
    createEventDispatcher,
    get: get_store_value,
    writable,
    cc,
    errorMessages,
    Position,
    drag,
    useStore,
    DefaultNode: DefaultNode_default,
    getNodeInlineStyleDimensions,
    node,
    id,
    data,
    selected,
    draggable,
    selectable,
    connectable,
    deletable,
    hidden,
    dragging,
    resizeObserver,
    style,
    type,
    isParent,
    positionX,
    positionY,
    sourcePosition,
    targetPosition,
    zIndex,
    measuredWidth,
    measuredHeight,
    initialWidth,
    initialHeight,
    width,
    height,
    dragHandle,
    initialized,
    parentId,
    nodeClickDistance,
    className,
    store,
    nodeTypes,
    nodeDragThreshold,
    selectNodesOnDrag,
    handleNodeSelection,
    updateNodeInternals: updateNodeInternals2,
    nodeRef,
    prevNodeRef,
    dispatchNodeEvent,
    connectableStore,
    prevType,
    prevSourcePosition,
    prevTargetPosition,
    onSelectNodeHandler,
    nodeType,
    inlineStyleDimensions,
    nodeTypeValid,
    nodeComponent,
    $nodeTypes,
    $connectableStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("node" in $$props2) $$invalidate(0, node = $$props2.node);
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("selected" in $$props2) $$invalidate(3, selected = $$props2.selected);
    if ("draggable" in $$props2) $$invalidate(4, draggable = $$props2.draggable);
    if ("selectable" in $$props2) $$invalidate(5, selectable = $$props2.selectable);
    if ("connectable" in $$props2) $$invalidate(6, connectable = $$props2.connectable);
    if ("deletable" in $$props2) $$invalidate(7, deletable = $$props2.deletable);
    if ("hidden" in $$props2) $$invalidate(8, hidden = $$props2.hidden);
    if ("dragging" in $$props2) $$invalidate(9, dragging = $$props2.dragging);
    if ("resizeObserver" in $$props2) $$invalidate(35, resizeObserver = $$props2.resizeObserver);
    if ("style" in $$props2) $$invalidate(10, style = $$props2.style);
    if ("type" in $$props2) $$invalidate(36, type = $$props2.type);
    if ("isParent" in $$props2) $$invalidate(11, isParent = $$props2.isParent);
    if ("positionX" in $$props2) $$invalidate(12, positionX = $$props2.positionX);
    if ("positionY" in $$props2) $$invalidate(13, positionY = $$props2.positionY);
    if ("sourcePosition" in $$props2) $$invalidate(14, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2) $$invalidate(15, targetPosition = $$props2.targetPosition);
    if ("zIndex" in $$props2) $$invalidate(16, zIndex = $$props2.zIndex);
    if ("measuredWidth" in $$props2) $$invalidate(37, measuredWidth = $$props2.measuredWidth);
    if ("measuredHeight" in $$props2) $$invalidate(38, measuredHeight = $$props2.measuredHeight);
    if ("initialWidth" in $$props2) $$invalidate(39, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2) $$invalidate(40, initialHeight = $$props2.initialHeight);
    if ("width" in $$props2) $$invalidate(17, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(18, height = $$props2.height);
    if ("dragHandle" in $$props2) $$invalidate(19, dragHandle = $$props2.dragHandle);
    if ("initialized" in $$props2) $$invalidate(20, initialized = $$props2.initialized);
    if ("parentId" in $$props2) $$invalidate(21, parentId = $$props2.parentId);
    if ("nodeClickDistance" in $$props2) $$invalidate(22, nodeClickDistance = $$props2.nodeClickDistance);
    if ("className" in $$props2) $$invalidate(23, className = $$props2.className);
    if ("nodeRef" in $$props2) $$invalidate(24, nodeRef = $$props2.nodeRef);
    if ("prevNodeRef" in $$props2) $$invalidate(41, prevNodeRef = $$props2.prevNodeRef);
    if ("prevType" in $$props2) $$invalidate(42, prevType = $$props2.prevType);
    if ("prevSourcePosition" in $$props2) $$invalidate(43, prevSourcePosition = $$props2.prevSourcePosition);
    if ("prevTargetPosition" in $$props2) $$invalidate(44, prevTargetPosition = $$props2.prevTargetPosition);
    if ("nodeType" in $$props2) $$invalidate(25, nodeType = $$props2.nodeType);
    if ("inlineStyleDimensions" in $$props2) $$invalidate(26, inlineStyleDimensions = $$props2.inlineStyleDimensions);
    if ("nodeTypeValid" in $$props2) $$invalidate(45, nodeTypeValid = $$props2.nodeTypeValid);
    if ("nodeComponent" in $$props2) $$invalidate(27, nodeComponent = $$props2.nodeComponent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*type*/
    32) {
      $: $$invalidate(25, nodeType = type || "default");
    }
    if ($$self.$$.dirty[0] & /*nodeType*/
    33554432 | $$self.$$.dirty[1] & /*$nodeTypes*/
    32768) {
      $: $$invalidate(45, nodeTypeValid = !!$nodeTypes[nodeType]);
    }
    if ($$self.$$.dirty[0] & /*nodeType*/
    33554432 | $$self.$$.dirty[1] & /*$nodeTypes*/
    32768) {
      $: $$invalidate(27, nodeComponent = $nodeTypes[nodeType] || DefaultNode_default);
    }
    if ($$self.$$.dirty[1] & /*nodeTypeValid, type*/
    16416) {
      $: {
        if (!nodeTypeValid) {
          console.warn("003", errorMessages["error003"](type));
        }
      }
    }
    if ($$self.$$.dirty[0] & /*width, height*/
    393216 | $$self.$$.dirty[1] & /*initialWidth, initialHeight, measuredWidth, measuredHeight*/
    960) {
      $: $$invalidate(26, inlineStyleDimensions = getNodeInlineStyleDimensions({
        width,
        height,
        initialWidth,
        initialHeight,
        measuredWidth,
        measuredHeight
      }));
    }
    if ($$self.$$.dirty[0] & /*connectable*/
    64) {
      $: {
        connectableStore.set(!!connectable);
      }
    }
    if ($$self.$$.dirty[0] & /*nodeType, sourcePosition, targetPosition, id, nodeRef*/
    50380802 | $$self.$$.dirty[1] & /*prevType, prevSourcePosition, prevTargetPosition*/
    14336) {
      $: {
        const doUpdate = prevType && nodeType !== prevType || prevSourcePosition && sourcePosition !== prevSourcePosition || prevTargetPosition && targetPosition !== prevTargetPosition;
        if (doUpdate) {
          requestAnimationFrame(() => updateNodeInternals2(/* @__PURE__ */ new Map([[id, { id, nodeElement: nodeRef, force: true }]])));
        }
        $$invalidate(42, prevType = nodeType);
        $$invalidate(43, prevSourcePosition = sourcePosition);
        $$invalidate(44, prevTargetPosition = targetPosition);
      }
    }
    if ($$self.$$.dirty[0] & /*nodeRef, initialized*/
    17825792 | $$self.$$.dirty[1] & /*resizeObserver, prevNodeRef*/
    1040) {
      $: {
        if (resizeObserver && (nodeRef !== prevNodeRef || !initialized)) {
          prevNodeRef && resizeObserver.unobserve(prevNodeRef);
          nodeRef && resizeObserver.observe(nodeRef);
          $$invalidate(41, prevNodeRef = nodeRef);
        }
      }
    }
  };
  return [
    node,
    id,
    data,
    selected,
    draggable,
    selectable,
    connectable,
    deletable,
    hidden,
    dragging,
    style,
    isParent,
    positionX,
    positionY,
    sourcePosition,
    targetPosition,
    zIndex,
    width,
    height,
    dragHandle,
    initialized,
    parentId,
    nodeClickDistance,
    className,
    nodeRef,
    nodeType,
    inlineStyleDimensions,
    nodeComponent,
    $connectableStore,
    store,
    nodeTypes,
    handleNodeSelection,
    dispatchNodeEvent,
    connectableStore,
    onSelectNodeHandler,
    resizeObserver,
    type,
    measuredWidth,
    measuredHeight,
    initialWidth,
    initialHeight,
    prevNodeRef,
    prevType,
    prevSourcePosition,
    prevTargetPosition,
    nodeTypeValid,
    $nodeTypes,
    drag_function,
    drag_function_1,
    drag_function_2,
    div_binding,
    mouseenter_handler,
    mouseleave_handler,
    mousemove_handler,
    contextmenu_handler
  ];
}
var NodeWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance20,
      create_fragment20,
      not_equal,
      {
        node: 0,
        id: 1,
        data: 2,
        selected: 3,
        draggable: 4,
        selectable: 5,
        connectable: 6,
        deletable: 7,
        hidden: 8,
        dragging: 9,
        resizeObserver: 35,
        style: 10,
        type: 36,
        isParent: 11,
        positionX: 12,
        positionY: 13,
        sourcePosition: 14,
        targetPosition: 15,
        zIndex: 16,
        measuredWidth: 37,
        measuredHeight: 38,
        initialWidth: 39,
        initialHeight: 40,
        width: 17,
        height: 18,
        dragHandle: 19,
        initialized: 20,
        parentId: 21,
        nodeClickDistance: 22,
        class: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeWrapper",
      options,
      id: create_fragment20.name
    });
  }
  get node() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get draggable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set draggable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deletable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deletable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizeObserver() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizeObserver(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isParent() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isParent(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionX() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionX(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionY() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionY(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get measuredWidth() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set measuredWidth(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get measuredHeight() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set measuredHeight(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialWidth() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialWidth(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialHeight() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialHeight(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragHandle() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragHandle(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialized() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialized(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parentId() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parentId(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeClickDistance() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeClickDistance(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeWrapper_default = NodeWrapper;

// node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte
var { Map: Map_1 } = globals;
var file9 = "node_modules\\@xyflow\\svelte\\dist\\lib\\container\\NodeRenderer\\NodeRenderer.svelte";
function add_css4(target) {
  append_styles(target, "svelte-tf4uy4", ".svelte-flow__nodes.svelte-tf4uy4{width:100%;height:100%;position:absolute;left:0;top:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZVJlbmRlcmVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFpdXNlcjlcXERvY3VtZW50c1xcbXVrZXNoXFxuZXctd29ya2luZy13ZWItbWFpblxcbmV3LXdvcmtpbmctd2ViLW1haW5cXHNwZWN0cmEtbGl0ZVxcbm9kZV9tb2R1bGVzXFxAeHlmbG93XFxzdmVsdGVcXGRpc3RcXGxpYlxcY29udGFpbmVyXFxOb2RlUmVuZGVyZXJcXE5vZGVSZW5kZXJlci5zdmVsdGUiXX0= */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  let first;
  let nodewrapper;
  let current;
  nodewrapper = new NodeWrapper_default({
    props: {
      node: (
        /*node*/
        ctx[21]
      ),
      id: (
        /*node*/
        ctx[21].id
      ),
      data: (
        /*node*/
        ctx[21].data
      ),
      selected: !!/*node*/
      ctx[21].selected,
      hidden: !!/*node*/
      ctx[21].hidden,
      draggable: !!/*node*/
      (ctx[21].draggable || /*$nodesDraggable*/
      ctx[2] && typeof /*node*/
      ctx[21].draggable === "undefined"),
      selectable: !!/*node*/
      (ctx[21].selectable || /*$elementsSelectable*/
      ctx[3] && typeof /*node*/
      ctx[21].selectable === "undefined"),
      connectable: !!/*node*/
      (ctx[21].connectable || /*$nodesConnectable*/
      ctx[4] && typeof /*node*/
      ctx[21].connectable === "undefined"),
      deletable: (
        /*node*/
        ctx[21].deletable ?? true
      ),
      positionX: (
        /*node*/
        ctx[21].internals.positionAbsolute.x
      ),
      positionY: (
        /*node*/
        ctx[21].internals.positionAbsolute.y
      ),
      isParent: (
        /*$parentLookup*/
        ctx[5].has(
          /*node*/
          ctx[21].id
        )
      ),
      style: (
        /*node*/
        ctx[21].style
      ),
      class: (
        /*node*/
        ctx[21].class
      ),
      type: (
        /*node*/
        ctx[21].type ?? "default"
      ),
      sourcePosition: (
        /*node*/
        ctx[21].sourcePosition
      ),
      targetPosition: (
        /*node*/
        ctx[21].targetPosition
      ),
      dragging: (
        /*node*/
        ctx[21].dragging
      ),
      zIndex: (
        /*node*/
        ctx[21].internals.z ?? 0
      ),
      dragHandle: (
        /*node*/
        ctx[21].dragHandle
      ),
      initialized: nodeHasDimensions(
        /*node*/
        ctx[21]
      ),
      width: (
        /*node*/
        ctx[21].width
      ),
      height: (
        /*node*/
        ctx[21].height
      ),
      initialWidth: (
        /*node*/
        ctx[21].initialWidth
      ),
      initialHeight: (
        /*node*/
        ctx[21].initialHeight
      ),
      measuredWidth: (
        /*node*/
        ctx[21].measured.width
      ),
      measuredHeight: (
        /*node*/
        ctx[21].measured.height
      ),
      parentId: (
        /*node*/
        ctx[21].parentId
      ),
      resizeObserver: (
        /*resizeObserver*/
        ctx[11]
      ),
      nodeClickDistance: (
        /*nodeClickDistance*/
        ctx[0]
      )
    },
    $$inline: true
  });
  nodewrapper.$on(
    "nodeclick",
    /*nodeclick_handler*/
    ctx[12]
  );
  nodewrapper.$on(
    "nodemouseenter",
    /*nodemouseenter_handler*/
    ctx[13]
  );
  nodewrapper.$on(
    "nodemousemove",
    /*nodemousemove_handler*/
    ctx[14]
  );
  nodewrapper.$on(
    "nodemouseleave",
    /*nodemouseleave_handler*/
    ctx[15]
  );
  nodewrapper.$on(
    "nodedrag",
    /*nodedrag_handler*/
    ctx[16]
  );
  nodewrapper.$on(
    "nodedragstart",
    /*nodedragstart_handler*/
    ctx[17]
  );
  nodewrapper.$on(
    "nodedragstop",
    /*nodedragstop_handler*/
    ctx[18]
  );
  nodewrapper.$on(
    "nodecontextmenu",
    /*nodecontextmenu_handler*/
    ctx[19]
  );
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(nodewrapper.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(nodewrapper.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(nodewrapper, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const nodewrapper_changes = {};
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.node = /*node*/
      ctx[21];
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.id = /*node*/
      ctx[21].id;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.data = /*node*/
      ctx[21].data;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.selected = !!/*node*/
      ctx[21].selected;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.hidden = !!/*node*/
      ctx[21].hidden;
      if (dirty & /*$visibleNodes, $nodesDraggable*/
      6) nodewrapper_changes.draggable = !!/*node*/
      (ctx[21].draggable || /*$nodesDraggable*/
      ctx[2] && typeof /*node*/
      ctx[21].draggable === "undefined");
      if (dirty & /*$visibleNodes, $elementsSelectable*/
      10) nodewrapper_changes.selectable = !!/*node*/
      (ctx[21].selectable || /*$elementsSelectable*/
      ctx[3] && typeof /*node*/
      ctx[21].selectable === "undefined");
      if (dirty & /*$visibleNodes, $nodesConnectable*/
      18) nodewrapper_changes.connectable = !!/*node*/
      (ctx[21].connectable || /*$nodesConnectable*/
      ctx[4] && typeof /*node*/
      ctx[21].connectable === "undefined");
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.deletable = /*node*/
      ctx[21].deletable ?? true;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.positionX = /*node*/
      ctx[21].internals.positionAbsolute.x;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.positionY = /*node*/
      ctx[21].internals.positionAbsolute.y;
      if (dirty & /*$parentLookup, $visibleNodes*/
      34) nodewrapper_changes.isParent = /*$parentLookup*/
      ctx[5].has(
        /*node*/
        ctx[21].id
      );
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.style = /*node*/
      ctx[21].style;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.class = /*node*/
      ctx[21].class;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.type = /*node*/
      ctx[21].type ?? "default";
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.sourcePosition = /*node*/
      ctx[21].sourcePosition;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.targetPosition = /*node*/
      ctx[21].targetPosition;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.dragging = /*node*/
      ctx[21].dragging;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.zIndex = /*node*/
      ctx[21].internals.z ?? 0;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.dragHandle = /*node*/
      ctx[21].dragHandle;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.initialized = nodeHasDimensions(
        /*node*/
        ctx[21]
      );
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.width = /*node*/
      ctx[21].width;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.height = /*node*/
      ctx[21].height;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.initialWidth = /*node*/
      ctx[21].initialWidth;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.initialHeight = /*node*/
      ctx[21].initialHeight;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.measuredWidth = /*node*/
      ctx[21].measured.width;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.measuredHeight = /*node*/
      ctx[21].measured.height;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.parentId = /*node*/
      ctx[21].parentId;
      if (dirty & /*nodeClickDistance*/
      1) nodewrapper_changes.nodeClickDistance = /*nodeClickDistance*/
      ctx[0];
      nodewrapper.$set(nodewrapper_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(nodewrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(nodewrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(nodewrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(27:2) {#each $visibleNodes as node (node.id)}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let current;
  let each_value = ensure_array_like_dev(
    /*$visibleNodes*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[21].id
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block(key2, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-flow__nodes svelte-tf4uy4");
      add_location(div, file9, 25, 0, 863);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$visibleNodes, $nodesDraggable, $elementsSelectable, $nodesConnectable, $parentLookup, resizeObserver, nodeClickDistance*/
      2111) {
        each_value = ensure_array_like_dev(
          /*$visibleNodes*/
          ctx2[1]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let $visibleNodes;
  let $nodesDraggable;
  let $elementsSelectable;
  let $nodesConnectable;
  let $parentLookup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeRenderer", slots, []);
  let { nodeClickDistance = 0 } = $$props;
  const { visibleNodes, nodesDraggable, nodesConnectable, elementsSelectable, updateNodeInternals: updateNodeInternals2, parentLookup } = useStore();
  validate_store(visibleNodes, "visibleNodes");
  component_subscribe($$self, visibleNodes, (value) => $$invalidate(1, $visibleNodes = value));
  validate_store(nodesDraggable, "nodesDraggable");
  component_subscribe($$self, nodesDraggable, (value) => $$invalidate(2, $nodesDraggable = value));
  validate_store(nodesConnectable, "nodesConnectable");
  component_subscribe($$self, nodesConnectable, (value) => $$invalidate(4, $nodesConnectable = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(3, $elementsSelectable = value));
  validate_store(parentLookup, "parentLookup");
  component_subscribe($$self, parentLookup, (value) => $$invalidate(5, $parentLookup = value));
  const resizeObserver = typeof ResizeObserver === "undefined" ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id = entry.target.getAttribute("data-id");
      updates.set(id, {
        id,
        nodeElement: entry.target,
        force: true
      });
    });
    updateNodeInternals2(updates);
  });
  onDestroy(() => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
  });
  const writable_props = ["nodeClickDistance"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<NodeRenderer> was created with unknown prop '${key2}'`);
  });
  function nodeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedrag_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("nodeClickDistance" in $$props2) $$invalidate(0, nodeClickDistance = $$props2.nodeClickDistance);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    nodeHasDimensions,
    NodeWrapper: NodeWrapper_default,
    useStore,
    nodeClickDistance,
    visibleNodes,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    updateNodeInternals: updateNodeInternals2,
    parentLookup,
    resizeObserver,
    $visibleNodes,
    $nodesDraggable,
    $elementsSelectable,
    $nodesConnectable,
    $parentLookup
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodeClickDistance" in $$props2) $$invalidate(0, nodeClickDistance = $$props2.nodeClickDistance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nodeClickDistance,
    $visibleNodes,
    $nodesDraggable,
    $elementsSelectable,
    $nodesConnectable,
    $parentLookup,
    visibleNodes,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    parentLookup,
    resizeObserver,
    nodeclick_handler,
    nodemouseenter_handler,
    nodemousemove_handler,
    nodemouseleave_handler,
    nodedrag_handler,
    nodedragstart_handler,
    nodedragstop_handler,
    nodecontextmenu_handler
  ];
}
var NodeRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { nodeClickDistance: 0 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeRenderer",
      options,
      id: create_fragment21.name
    });
  }
  get nodeClickDistance() {
    throw new Error("<NodeRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeClickDistance(value) {
    throw new Error("<NodeRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeRenderer_default = NodeRenderer;

// node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte
var file10 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\EdgeWrapper\\EdgeWrapper.svelte";
function create_if_block3(ctx) {
  let svg;
  let g;
  let switch_instance;
  let g_class_value;
  let g_aria_label_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*edgeComponent*/
    ctx[27]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        id: (
          /*id*/
          ctx2[0]
        ),
        source: (
          /*source*/
          ctx2[1]
        ),
        target: (
          /*target*/
          ctx2[2]
        ),
        sourceX: (
          /*sourceX*/
          ctx2[14]
        ),
        sourceY: (
          /*sourceY*/
          ctx2[15]
        ),
        targetX: (
          /*targetX*/
          ctx2[16]
        ),
        targetY: (
          /*targetY*/
          ctx2[17]
        ),
        sourcePosition: (
          /*sourcePosition*/
          ctx2[18]
        ),
        targetPosition: (
          /*targetPosition*/
          ctx2[19]
        ),
        animated: (
          /*animated*/
          ctx2[6]
        ),
        selected: (
          /*selected*/
          ctx2[7]
        ),
        label: (
          /*label*/
          ctx2[10]
        ),
        labelStyle: (
          /*labelStyle*/
          ctx2[11]
        ),
        data: (
          /*data*/
          ctx2[3]
        ),
        style: (
          /*style*/
          ctx2[4]
        ),
        interactionWidth: (
          /*interactionWidth*/
          ctx2[21]
        ),
        selectable: (
          /*isSelectable*/
          ctx2[24]
        ),
        deletable: (
          /*deletable*/
          ctx2[8] ?? true
        ),
        type: (
          /*edgeType*/
          ctx2[23]
        ),
        sourceHandleId: (
          /*sourceHandle*/
          ctx2[12]
        ),
        targetHandleId: (
          /*targetHandle*/
          ctx2[13]
        ),
        markerStart: (
          /*markerStartUrl*/
          ctx2[26]
        ),
        markerEnd: (
          /*markerEndUrl*/
          ctx2[25]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      g = svg_element("g");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {});
      var svg_nodes = children(svg);
      g = claim_svg_element(svg_nodes, "g", {
        class: true,
        "data-id": true,
        "aria-label": true,
        role: true
      });
      var g_nodes = children(g);
      if (switch_instance) claim_component(switch_instance.$$.fragment, g_nodes);
      g_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "class", g_class_value = cc([
        "svelte-flow__edge",
        /*className*/
        ctx[22]
      ]));
      attr_dev(
        g,
        "data-id",
        /*id*/
        ctx[0]
      );
      attr_dev(g, "aria-label", g_aria_label_value = /*ariaLabel*/
      ctx[20] === null ? void 0 : (
        /*ariaLabel*/
        ctx[20] ? (
          /*ariaLabel*/
          ctx[20]
        ) : `Edge from ${/*source*/
        ctx[1]} to ${/*target*/
        ctx[2]}`
      ));
      attr_dev(g, "role", "img");
      toggle_class(
        g,
        "animated",
        /*animated*/
        ctx[6]
      );
      toggle_class(
        g,
        "selected",
        /*selected*/
        ctx[7]
      );
      toggle_class(
        g,
        "selectable",
        /*isSelectable*/
        ctx[24]
      );
      add_location(g, file10, 65, 4, 2183);
      set_style(
        svg,
        "z-index",
        /*zIndex*/
        ctx[5]
      );
      add_location(svg, file10, 64, 2, 2150);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, g);
      if (switch_instance) mount_component(switch_instance, g, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            g,
            "click",
            /*onClick*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            g,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            g,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            g,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[43],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*edgeComponent*/
      134217728 && switch_value !== (switch_value = /*edgeComponent*/
      ctx2[27])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, g, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*id*/
        1) switch_instance_changes.id = /*id*/
        ctx2[0];
        if (dirty[0] & /*source*/
        2) switch_instance_changes.source = /*source*/
        ctx2[1];
        if (dirty[0] & /*target*/
        4) switch_instance_changes.target = /*target*/
        ctx2[2];
        if (dirty[0] & /*sourceX*/
        16384) switch_instance_changes.sourceX = /*sourceX*/
        ctx2[14];
        if (dirty[0] & /*sourceY*/
        32768) switch_instance_changes.sourceY = /*sourceY*/
        ctx2[15];
        if (dirty[0] & /*targetX*/
        65536) switch_instance_changes.targetX = /*targetX*/
        ctx2[16];
        if (dirty[0] & /*targetY*/
        131072) switch_instance_changes.targetY = /*targetY*/
        ctx2[17];
        if (dirty[0] & /*sourcePosition*/
        262144) switch_instance_changes.sourcePosition = /*sourcePosition*/
        ctx2[18];
        if (dirty[0] & /*targetPosition*/
        524288) switch_instance_changes.targetPosition = /*targetPosition*/
        ctx2[19];
        if (dirty[0] & /*animated*/
        64) switch_instance_changes.animated = /*animated*/
        ctx2[6];
        if (dirty[0] & /*selected*/
        128) switch_instance_changes.selected = /*selected*/
        ctx2[7];
        if (dirty[0] & /*label*/
        1024) switch_instance_changes.label = /*label*/
        ctx2[10];
        if (dirty[0] & /*labelStyle*/
        2048) switch_instance_changes.labelStyle = /*labelStyle*/
        ctx2[11];
        if (dirty[0] & /*data*/
        8) switch_instance_changes.data = /*data*/
        ctx2[3];
        if (dirty[0] & /*style*/
        16) switch_instance_changes.style = /*style*/
        ctx2[4];
        if (dirty[0] & /*interactionWidth*/
        2097152) switch_instance_changes.interactionWidth = /*interactionWidth*/
        ctx2[21];
        if (dirty[0] & /*isSelectable*/
        16777216) switch_instance_changes.selectable = /*isSelectable*/
        ctx2[24];
        if (dirty[0] & /*deletable*/
        256) switch_instance_changes.deletable = /*deletable*/
        ctx2[8] ?? true;
        if (dirty[0] & /*edgeType*/
        8388608) switch_instance_changes.type = /*edgeType*/
        ctx2[23];
        if (dirty[0] & /*sourceHandle*/
        4096) switch_instance_changes.sourceHandleId = /*sourceHandle*/
        ctx2[12];
        if (dirty[0] & /*targetHandle*/
        8192) switch_instance_changes.targetHandleId = /*targetHandle*/
        ctx2[13];
        if (dirty[0] & /*markerStartUrl*/
        67108864) switch_instance_changes.markerStart = /*markerStartUrl*/
        ctx2[26];
        if (dirty[0] & /*markerEndUrl*/
        33554432) switch_instance_changes.markerEnd = /*markerEndUrl*/
        ctx2[25];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*className*/
      4194304 && g_class_value !== (g_class_value = cc([
        "svelte-flow__edge",
        /*className*/
        ctx2[22]
      ]))) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr_dev(
          g,
          "data-id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*ariaLabel, source, target*/
      1048582 && g_aria_label_value !== (g_aria_label_value = /*ariaLabel*/
      ctx2[20] === null ? void 0 : (
        /*ariaLabel*/
        ctx2[20] ? (
          /*ariaLabel*/
          ctx2[20]
        ) : `Edge from ${/*source*/
        ctx2[1]} to ${/*target*/
        ctx2[2]}`
      ))) {
        attr_dev(g, "aria-label", g_aria_label_value);
      }
      if (!current || dirty[0] & /*className, animated*/
      4194368) {
        toggle_class(
          g,
          "animated",
          /*animated*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*className, selected*/
      4194432) {
        toggle_class(
          g,
          "selected",
          /*selected*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*className, isSelectable*/
      20971520) {
        toggle_class(
          g,
          "selectable",
          /*isSelectable*/
          ctx2[24]
        );
      }
      if (dirty[0] & /*zIndex*/
      32) {
        set_style(
          svg,
          "z-index",
          /*zIndex*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (switch_instance) destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(64:0) {#if !hidden}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*hidden*/
  ctx[9] && create_if_block3(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*hidden*/
      ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*hidden*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let edgeType;
  let edgeComponent;
  let markerStartUrl;
  let markerEndUrl;
  let isSelectable;
  let $edgeLookup;
  let $elementsSelectable;
  let $flowId;
  let $edgeTypes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeWrapper", slots, []);
  let { id } = $$props;
  let { type = "default" } = $$props;
  let { source = "" } = $$props;
  let { target = "" } = $$props;
  let { data = {} } = $$props;
  let { style = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { animated = false } = $$props;
  let { selected = false } = $$props;
  let { selectable = void 0 } = $$props;
  let { deletable = void 0 } = $$props;
  let { hidden = false } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { sourceHandle = void 0 } = $$props;
  let { targetHandle = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { sourcePosition } = $$props;
  let { targetPosition } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { class: className = "" } = $$props;
  setContext("svelteflow__edge_id", id);
  const { edgeLookup, edgeTypes, flowId, elementsSelectable } = useStore();
  validate_store(edgeLookup, "edgeLookup");
  component_subscribe($$self, edgeLookup, (value) => $$invalidate(44, $edgeLookup = value));
  validate_store(edgeTypes, "edgeTypes");
  component_subscribe($$self, edgeTypes, (value) => $$invalidate(40, $edgeTypes = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(39, $flowId = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(38, $elementsSelectable = value));
  const dispatch = createEventDispatcher();
  const handleEdgeSelect = useHandleEdgeSelect();
  function onClick(event) {
    const edge = $edgeLookup.get(id);
    if (edge) {
      handleEdgeSelect(id);
      dispatch("edgeclick", { event, edge });
    }
  }
  function onMouseEvent(event, type2) {
    const edge = $edgeLookup.get(id);
    if (edge) {
      dispatch(type2, { event, edge });
    }
  }
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'id'");
    }
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'sourceY'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'targetY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'sourcePosition'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'targetPosition'");
    }
  });
  const writable_props = [
    "id",
    "type",
    "source",
    "target",
    "data",
    "style",
    "zIndex",
    "animated",
    "selected",
    "selectable",
    "deletable",
    "hidden",
    "label",
    "labelStyle",
    "markerStart",
    "markerEnd",
    "sourceHandle",
    "targetHandle",
    "sourceX",
    "sourceY",
    "targetX",
    "targetY",
    "sourcePosition",
    "targetPosition",
    "ariaLabel",
    "interactionWidth",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<EdgeWrapper> was created with unknown prop '${key2}'`);
  });
  const contextmenu_handler = (e) => {
    onMouseEvent(e, "edgecontextmenu");
  };
  const mouseenter_handler = (e) => {
    onMouseEvent(e, "edgemouseenter");
  };
  const mouseleave_handler = (e) => {
    onMouseEvent(e, "edgemouseleave");
  };
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("type" in $$props2) $$invalidate(34, type = $$props2.type);
    if ("source" in $$props2) $$invalidate(1, source = $$props2.source);
    if ("target" in $$props2) $$invalidate(2, target = $$props2.target);
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
    if ("style" in $$props2) $$invalidate(4, style = $$props2.style);
    if ("zIndex" in $$props2) $$invalidate(5, zIndex = $$props2.zIndex);
    if ("animated" in $$props2) $$invalidate(6, animated = $$props2.animated);
    if ("selected" in $$props2) $$invalidate(7, selected = $$props2.selected);
    if ("selectable" in $$props2) $$invalidate(35, selectable = $$props2.selectable);
    if ("deletable" in $$props2) $$invalidate(8, deletable = $$props2.deletable);
    if ("hidden" in $$props2) $$invalidate(9, hidden = $$props2.hidden);
    if ("label" in $$props2) $$invalidate(10, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(11, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2) $$invalidate(36, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(37, markerEnd = $$props2.markerEnd);
    if ("sourceHandle" in $$props2) $$invalidate(12, sourceHandle = $$props2.sourceHandle);
    if ("targetHandle" in $$props2) $$invalidate(13, targetHandle = $$props2.targetHandle);
    if ("sourceX" in $$props2) $$invalidate(14, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(15, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2) $$invalidate(16, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(17, targetY = $$props2.targetY);
    if ("sourcePosition" in $$props2) $$invalidate(18, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2) $$invalidate(19, targetPosition = $$props2.targetPosition);
    if ("ariaLabel" in $$props2) $$invalidate(20, ariaLabel = $$props2.ariaLabel);
    if ("interactionWidth" in $$props2) $$invalidate(21, interactionWidth = $$props2.interactionWidth);
    if ("class" in $$props2) $$invalidate(22, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    cc,
    getMarkerId,
    useStore,
    BezierEdgeInternal: BezierEdgeInternal_default,
    useHandleEdgeSelect,
    id,
    type,
    source,
    target,
    data,
    style,
    zIndex,
    animated,
    selected,
    selectable,
    deletable,
    hidden,
    label,
    labelStyle,
    markerStart,
    markerEnd,
    sourceHandle,
    targetHandle,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    ariaLabel,
    interactionWidth,
    className,
    edgeLookup,
    edgeTypes,
    flowId,
    elementsSelectable,
    dispatch,
    handleEdgeSelect,
    onClick,
    onMouseEvent,
    isSelectable,
    markerEndUrl,
    markerStartUrl,
    edgeType,
    edgeComponent,
    $edgeLookup,
    $elementsSelectable,
    $flowId,
    $edgeTypes
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("type" in $$props2) $$invalidate(34, type = $$props2.type);
    if ("source" in $$props2) $$invalidate(1, source = $$props2.source);
    if ("target" in $$props2) $$invalidate(2, target = $$props2.target);
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
    if ("style" in $$props2) $$invalidate(4, style = $$props2.style);
    if ("zIndex" in $$props2) $$invalidate(5, zIndex = $$props2.zIndex);
    if ("animated" in $$props2) $$invalidate(6, animated = $$props2.animated);
    if ("selected" in $$props2) $$invalidate(7, selected = $$props2.selected);
    if ("selectable" in $$props2) $$invalidate(35, selectable = $$props2.selectable);
    if ("deletable" in $$props2) $$invalidate(8, deletable = $$props2.deletable);
    if ("hidden" in $$props2) $$invalidate(9, hidden = $$props2.hidden);
    if ("label" in $$props2) $$invalidate(10, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(11, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2) $$invalidate(36, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(37, markerEnd = $$props2.markerEnd);
    if ("sourceHandle" in $$props2) $$invalidate(12, sourceHandle = $$props2.sourceHandle);
    if ("targetHandle" in $$props2) $$invalidate(13, targetHandle = $$props2.targetHandle);
    if ("sourceX" in $$props2) $$invalidate(14, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(15, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2) $$invalidate(16, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(17, targetY = $$props2.targetY);
    if ("sourcePosition" in $$props2) $$invalidate(18, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2) $$invalidate(19, targetPosition = $$props2.targetPosition);
    if ("ariaLabel" in $$props2) $$invalidate(20, ariaLabel = $$props2.ariaLabel);
    if ("interactionWidth" in $$props2) $$invalidate(21, interactionWidth = $$props2.interactionWidth);
    if ("className" in $$props2) $$invalidate(22, className = $$props2.className);
    if ("isSelectable" in $$props2) $$invalidate(24, isSelectable = $$props2.isSelectable);
    if ("markerEndUrl" in $$props2) $$invalidate(25, markerEndUrl = $$props2.markerEndUrl);
    if ("markerStartUrl" in $$props2) $$invalidate(26, markerStartUrl = $$props2.markerStartUrl);
    if ("edgeType" in $$props2) $$invalidate(23, edgeType = $$props2.edgeType);
    if ("edgeComponent" in $$props2) $$invalidate(27, edgeComponent = $$props2.edgeComponent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*type*/
    8) {
      $: $$invalidate(23, edgeType = type || "default");
    }
    if ($$self.$$.dirty[0] & /*edgeType*/
    8388608 | $$self.$$.dirty[1] & /*$edgeTypes*/
    512) {
      $: $$invalidate(27, edgeComponent = $edgeTypes[edgeType] || BezierEdgeInternal_default);
    }
    if ($$self.$$.dirty[1] & /*markerStart, $flowId*/
    288) {
      $: $$invalidate(26, markerStartUrl = markerStart ? `url('#${getMarkerId(markerStart, $flowId)}')` : void 0);
    }
    if ($$self.$$.dirty[1] & /*markerEnd, $flowId*/
    320) {
      $: $$invalidate(25, markerEndUrl = markerEnd ? `url('#${getMarkerId(markerEnd, $flowId)}')` : void 0);
    }
    if ($$self.$$.dirty[1] & /*selectable, $elementsSelectable*/
    144) {
      $: $$invalidate(24, isSelectable = selectable ?? $elementsSelectable);
    }
  };
  return [
    id,
    source,
    target,
    data,
    style,
    zIndex,
    animated,
    selected,
    deletable,
    hidden,
    label,
    labelStyle,
    sourceHandle,
    targetHandle,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    ariaLabel,
    interactionWidth,
    className,
    edgeType,
    isSelectable,
    markerEndUrl,
    markerStartUrl,
    edgeComponent,
    edgeLookup,
    edgeTypes,
    flowId,
    elementsSelectable,
    onClick,
    onMouseEvent,
    type,
    selectable,
    markerStart,
    markerEnd,
    $elementsSelectable,
    $flowId,
    $edgeTypes,
    contextmenu_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var EdgeWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance22,
      create_fragment22,
      not_equal,
      {
        id: 0,
        type: 34,
        source: 1,
        target: 2,
        data: 3,
        style: 4,
        zIndex: 5,
        animated: 6,
        selected: 7,
        selectable: 35,
        deletable: 8,
        hidden: 9,
        label: 10,
        labelStyle: 11,
        markerStart: 36,
        markerEnd: 37,
        sourceHandle: 12,
        targetHandle: 13,
        sourceX: 14,
        sourceY: 15,
        targetX: 16,
        targetY: 17,
        sourcePosition: 18,
        targetPosition: 19,
        ariaLabel: 20,
        interactionWidth: 21,
        class: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeWrapper",
      options,
      id: create_fragment22.name
    });
  }
  get id() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animated() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animated(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deletable() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deletable(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceHandle() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceHandle(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetHandle() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetHandle(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeWrapper_default = EdgeWrapper;

// node_modules/@xyflow/svelte/dist/lib/components/CallOnMount/CallOnMount.svelte
function create_fragment23(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CallOnMount", slots, []);
  let { onMount: _onMount = void 0 } = $$props;
  let { onDestroy: _onDestroy = void 0 } = $$props;
  onMount(() => {
    _onMount == null ? void 0 : _onMount();
    return _onDestroy;
  });
  const writable_props = ["onMount", "onDestroy"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<CallOnMount> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("onMount" in $$props2) $$invalidate(0, _onMount = $$props2.onMount);
    if ("onDestroy" in $$props2) $$invalidate(1, _onDestroy = $$props2.onDestroy);
  };
  $$self.$capture_state = () => ({ onMount, _onMount, _onDestroy });
  $$self.$inject_state = ($$props2) => {
    if ("_onMount" in $$props2) $$invalidate(0, _onMount = $$props2._onMount);
    if ("_onDestroy" in $$props2) $$invalidate(1, _onDestroy = $$props2._onDestroy);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [_onMount, _onDestroy];
}
var CallOnMount = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { onMount: 0, onDestroy: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CallOnMount",
      options,
      id: create_fragment23.name
    });
  }
  get onMount() {
    throw new Error("<CallOnMount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMount(value) {
    throw new Error("<CallOnMount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDestroy() {
    throw new Error("<CallOnMount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDestroy(value) {
    throw new Error("<CallOnMount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CallOnMount_default = CallOnMount;

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte
var file11 = "node_modules\\@xyflow\\svelte\\dist\\lib\\container\\EdgeRenderer\\MarkerDefinition\\MarkerDefinition.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let marker_1;
  let current;
  const marker_1_spread_levels = [
    /*marker*/
    ctx[2]
  ];
  let marker_1_props = {};
  for (let i = 0; i < marker_1_spread_levels.length; i += 1) {
    marker_1_props = assign(marker_1_props, marker_1_spread_levels[i]);
  }
  marker_1 = new Marker_default({ props: marker_1_props, $$inline: true });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(marker_1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(marker_1.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(marker_1, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const marker_1_changes = dirty & /*$markers*/
      1 ? get_spread_update(marker_1_spread_levels, [get_spread_object(
        /*marker*/
        ctx[2]
      )]) : {};
      marker_1.$set(marker_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(marker_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(marker_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(marker_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(7:2) {#each $markers as marker (marker.id)}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let defs;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like_dev(
    /*$markers*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*marker*/
    ctx2[2].id
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block2(key2, child_ctx));
  }
  const block = {
    c: function create() {
      defs = svg_element("defs");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      defs = claim_svg_element(nodes, "defs", {});
      var defs_nodes = children(defs);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(defs_nodes);
      }
      defs_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(defs, file11, 5, 0, 123);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, defs, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(defs, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$markers*/
      1) {
        each_value = ensure_array_like_dev(
          /*$markers*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, defs, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(defs);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let $markers;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MarkerDefinition", slots, []);
  const { markers } = useStore();
  validate_store(markers, "markers");
  component_subscribe($$self, markers, (value) => $$invalidate(0, $markers = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<MarkerDefinition> was created with unknown prop '${key2}'`);
  });
  $$self.$capture_state = () => ({ useStore, Marker: Marker_default, markers, $markers });
  return [$markers, markers];
}
var MarkerDefinition = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MarkerDefinition",
      options,
      id: create_fragment24.name
    });
  }
};
var MarkerDefinition_default = MarkerDefinition;

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte
var file12 = "node_modules\\@xyflow\\svelte\\dist\\lib\\container\\EdgeRenderer\\MarkerDefinition\\Marker.svelte";
function create_if_block_12(ctx) {
  let polyline;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        stroke: true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        "stroke-width": true,
        fill: true,
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        polyline,
        "stroke",
        /*color*/
        ctx[6]
      );
      attr_dev(polyline, "stroke-linecap", "round");
      attr_dev(polyline, "stroke-linejoin", "round");
      attr_dev(
        polyline,
        "stroke-width",
        /*strokeWidth*/
        ctx[7]
      );
      attr_dev(
        polyline,
        "fill",
        /*color*/
        ctx[6]
      );
      attr_dev(polyline, "points", "-5,-4 0,0 -5,4 -5,-4");
      add_location(polyline, file12, 32, 4, 741);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*color*/
      64) {
        attr_dev(
          polyline,
          "stroke",
          /*color*/
          ctx2[6]
        );
      }
      if (dirty & /*strokeWidth*/
      128) {
        attr_dev(
          polyline,
          "stroke-width",
          /*strokeWidth*/
          ctx2[7]
        );
      }
      if (dirty & /*color*/
      64) {
        attr_dev(
          polyline,
          "fill",
          /*color*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(polyline);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(32:44) ",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let polyline;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        stroke: true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        "stroke-width": true,
        fill: true,
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        polyline,
        "stroke",
        /*color*/
        ctx[6]
      );
      attr_dev(polyline, "stroke-linecap", "round");
      attr_dev(polyline, "stroke-linejoin", "round");
      attr_dev(
        polyline,
        "stroke-width",
        /*strokeWidth*/
        ctx[7]
      );
      attr_dev(polyline, "fill", "none");
      attr_dev(polyline, "points", "-5,-4 0,0 -5,4");
      add_location(polyline, file12, 23, 4, 514);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*color*/
      64) {
        attr_dev(
          polyline,
          "stroke",
          /*color*/
          ctx2[6]
        );
      }
      if (dirty & /*strokeWidth*/
      128) {
        attr_dev(
          polyline,
          "stroke-width",
          /*strokeWidth*/
          ctx2[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(polyline);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(23:2) {#if type === MarkerType.Arrow}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let marker;
  let marker_markerWidth_value;
  let marker_markerHeight_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[1] === MarkerType.Arrow
    ) return create_if_block4;
    if (
      /*type*/
      ctx2[1] === MarkerType.ArrowClosed
    ) return create_if_block_12;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      marker = svg_element("marker");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      marker = claim_svg_element(nodes, "marker", {
        class: true,
        id: true,
        markerWidth: true,
        markerHeight: true,
        viewBox: true,
        markerUnits: true,
        orient: true,
        refX: true,
        refY: true
      });
      var marker_nodes = children(marker);
      if (if_block) if_block.l(marker_nodes);
      marker_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(marker, "class", "svelte-flow__arrowhead");
      attr_dev(
        marker,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(marker, "markerWidth", marker_markerWidth_value = `${/*width*/
      ctx[2]}`);
      attr_dev(marker, "markerHeight", marker_markerHeight_value = `${/*height*/
      ctx[3]}`);
      attr_dev(marker, "viewBox", "-10 -10 20 20");
      attr_dev(
        marker,
        "markerUnits",
        /*markerUnits*/
        ctx[4]
      );
      attr_dev(
        marker,
        "orient",
        /*orient*/
        ctx[5]
      );
      attr_dev(marker, "refX", "0");
      attr_dev(marker, "refY", "0");
      add_location(marker, file12, 11, 0, 295);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, marker, anchor);
      if (if_block) if_block.m(marker, null);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block) if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(marker, null);
        }
      }
      if (dirty & /*id*/
      1) {
        attr_dev(
          marker,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*width*/
      4 && marker_markerWidth_value !== (marker_markerWidth_value = `${/*width*/
      ctx2[2]}`)) {
        attr_dev(marker, "markerWidth", marker_markerWidth_value);
      }
      if (dirty & /*height*/
      8 && marker_markerHeight_value !== (marker_markerHeight_value = `${/*height*/
      ctx2[3]}`)) {
        attr_dev(marker, "markerHeight", marker_markerHeight_value);
      }
      if (dirty & /*markerUnits*/
      16) {
        attr_dev(
          marker,
          "markerUnits",
          /*markerUnits*/
          ctx2[4]
        );
      }
      if (dirty & /*orient*/
      32) {
        attr_dev(
          marker,
          "orient",
          /*orient*/
          ctx2[5]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(marker);
      }
      if (if_block) {
        if_block.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Marker", slots, []);
  let { id } = $$props;
  let { type } = $$props;
  let { width = 12.5 } = $$props;
  let { height = 12.5 } = $$props;
  let { markerUnits = "strokeWidth" } = $$props;
  let { orient = "auto-start-reverse" } = $$props;
  let { color = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Marker> was created without expected prop 'id'");
    }
    if (type === void 0 && !("type" in $$props || $$self.$$.bound[$$self.$$.props["type"]])) {
      console.warn("<Marker> was created without expected prop 'type'");
    }
  });
  const writable_props = [
    "id",
    "type",
    "width",
    "height",
    "markerUnits",
    "orient",
    "color",
    "strokeWidth"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Marker> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("type" in $$props2) $$invalidate(1, type = $$props2.type);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("markerUnits" in $$props2) $$invalidate(4, markerUnits = $$props2.markerUnits);
    if ("orient" in $$props2) $$invalidate(5, orient = $$props2.orient);
    if ("color" in $$props2) $$invalidate(6, color = $$props2.color);
    if ("strokeWidth" in $$props2) $$invalidate(7, strokeWidth = $$props2.strokeWidth);
  };
  $$self.$capture_state = () => ({
    MarkerType,
    id,
    type,
    width,
    height,
    markerUnits,
    orient,
    color,
    strokeWidth
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("type" in $$props2) $$invalidate(1, type = $$props2.type);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("markerUnits" in $$props2) $$invalidate(4, markerUnits = $$props2.markerUnits);
    if ("orient" in $$props2) $$invalidate(5, orient = $$props2.orient);
    if ("color" in $$props2) $$invalidate(6, color = $$props2.color);
    if ("strokeWidth" in $$props2) $$invalidate(7, strokeWidth = $$props2.strokeWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id, type, width, height, markerUnits, orient, color, strokeWidth];
}
var Marker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      id: 0,
      type: 1,
      width: 2,
      height: 3,
      markerUnits: 4,
      orient: 5,
      color: 6,
      strokeWidth: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Marker",
      options,
      id: create_fragment25.name
    });
  }
  get id() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerUnits() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerUnits(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orient() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orient(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Marker_default = Marker;

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte
var file13 = "node_modules\\@xyflow\\svelte\\dist\\lib\\container\\EdgeRenderer\\EdgeRenderer.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_each_block3(key_1, ctx) {
  let first;
  let edgewrapper;
  let current;
  edgewrapper = new EdgeWrapper_default({
    props: {
      id: (
        /*edge*/
        ctx[14].id
      ),
      source: (
        /*edge*/
        ctx[14].source
      ),
      target: (
        /*edge*/
        ctx[14].target
      ),
      data: (
        /*edge*/
        ctx[14].data
      ),
      style: (
        /*edge*/
        ctx[14].style
      ),
      animated: (
        /*edge*/
        ctx[14].animated
      ),
      selected: (
        /*edge*/
        ctx[14].selected
      ),
      selectable: (
        /*edge*/
        ctx[14].selectable ?? /*$elementsSelectable*/
        ctx[1]
      ),
      deletable: (
        /*edge*/
        ctx[14].deletable
      ),
      hidden: (
        /*edge*/
        ctx[14].hidden
      ),
      label: (
        /*edge*/
        ctx[14].label
      ),
      labelStyle: (
        /*edge*/
        ctx[14].labelStyle
      ),
      markerStart: (
        /*edge*/
        ctx[14].markerStart
      ),
      markerEnd: (
        /*edge*/
        ctx[14].markerEnd
      ),
      sourceHandle: (
        /*edge*/
        ctx[14].sourceHandle
      ),
      targetHandle: (
        /*edge*/
        ctx[14].targetHandle
      ),
      sourceX: (
        /*edge*/
        ctx[14].sourceX
      ),
      sourceY: (
        /*edge*/
        ctx[14].sourceY
      ),
      targetX: (
        /*edge*/
        ctx[14].targetX
      ),
      targetY: (
        /*edge*/
        ctx[14].targetY
      ),
      sourcePosition: (
        /*edge*/
        ctx[14].sourcePosition
      ),
      targetPosition: (
        /*edge*/
        ctx[14].targetPosition
      ),
      ariaLabel: (
        /*edge*/
        ctx[14].ariaLabel
      ),
      interactionWidth: (
        /*edge*/
        ctx[14].interactionWidth
      ),
      class: (
        /*edge*/
        ctx[14].class
      ),
      type: (
        /*edge*/
        ctx[14].type || "default"
      ),
      zIndex: (
        /*edge*/
        ctx[14].zIndex
      )
    },
    $$inline: true
  });
  edgewrapper.$on(
    "edgeclick",
    /*edgeclick_handler*/
    ctx[7]
  );
  edgewrapper.$on(
    "edgecontextmenu",
    /*edgecontextmenu_handler*/
    ctx[8]
  );
  edgewrapper.$on(
    "edgemouseenter",
    /*edgemouseenter_handler*/
    ctx[9]
  );
  edgewrapper.$on(
    "edgemouseleave",
    /*edgemouseleave_handler*/
    ctx[10]
  );
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(edgewrapper.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(edgewrapper.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(edgewrapper, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const edgewrapper_changes = {};
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.id = /*edge*/
      ctx[14].id;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.source = /*edge*/
      ctx[14].source;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.target = /*edge*/
      ctx[14].target;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.data = /*edge*/
      ctx[14].data;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.style = /*edge*/
      ctx[14].style;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.animated = /*edge*/
      ctx[14].animated;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.selected = /*edge*/
      ctx[14].selected;
      if (dirty & /*$visibleEdges, $elementsSelectable*/
      3) edgewrapper_changes.selectable = /*edge*/
      ctx[14].selectable ?? /*$elementsSelectable*/
      ctx[1];
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.deletable = /*edge*/
      ctx[14].deletable;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.hidden = /*edge*/
      ctx[14].hidden;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.label = /*edge*/
      ctx[14].label;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.labelStyle = /*edge*/
      ctx[14].labelStyle;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.markerStart = /*edge*/
      ctx[14].markerStart;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.markerEnd = /*edge*/
      ctx[14].markerEnd;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.sourceHandle = /*edge*/
      ctx[14].sourceHandle;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.targetHandle = /*edge*/
      ctx[14].targetHandle;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.sourceX = /*edge*/
      ctx[14].sourceX;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.sourceY = /*edge*/
      ctx[14].sourceY;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.targetX = /*edge*/
      ctx[14].targetX;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.targetY = /*edge*/
      ctx[14].targetY;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.sourcePosition = /*edge*/
      ctx[14].sourcePosition;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.targetPosition = /*edge*/
      ctx[14].targetPosition;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.ariaLabel = /*edge*/
      ctx[14].ariaLabel;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.interactionWidth = /*edge*/
      ctx[14].interactionWidth;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.class = /*edge*/
      ctx[14].class;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.type = /*edge*/
      ctx[14].type || "default";
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.zIndex = /*edge*/
      ctx[14].zIndex;
      edgewrapper.$set(edgewrapper_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(edgewrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(edgewrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(edgewrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(19:2) {#each $visibleEdges as edge (edge.id)}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let callonmount;
  let current;
  callonmount = new CallOnMount_default({
    props: {
      onMount: (
        /*func*/
        ctx[11]
      ),
      onDestroy: (
        /*func_1*/
        ctx[12]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(callonmount.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(callonmount.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(callonmount, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const callonmount_changes = {};
      if (dirty & /*$edgesInitialized*/
      4) callonmount_changes.onMount = /*func*/
      ctx2[11];
      if (dirty & /*$edgesInitialized*/
      4) callonmount_changes.onDestroy = /*func_1*/
      ctx2[12];
      callonmount.$set(callonmount_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(callonmount.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(callonmount.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(callonmount, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(55:2) {#if $visibleEdges.length > 0}",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let div;
  let svg;
  let markerdefinition;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let current;
  markerdefinition = new MarkerDefinition_default({ $$inline: true });
  let each_value = ensure_array_like_dev(
    /*$visibleEdges*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*edge*/
    ctx2[14].id
  );
  validate_each_keys(ctx, each_value, get_each_context3, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block3(key2, child_ctx));
  }
  let if_block = (
    /*$visibleEdges*/
    ctx[0].length > 0 && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      create_component(markerdefinition.$$.fragment);
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      svg = claim_svg_element(div_nodes, "svg", { class: true });
      var svg_nodes = children(svg);
      claim_component(markerdefinition.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      t0 = claim_space(div_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t1 = claim_space(div_nodes);
      if (if_block) if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "class", "svelte-flow__marker");
      add_location(svg, file13, 14, 2, 534);
      attr_dev(div, "class", "svelte-flow__edges");
      add_location(div, file13, 13, 0, 499);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, svg);
      mount_component(markerdefinition, svg, null);
      append_hydration_dev(div, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration_dev(div, t1);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$visibleEdges, $elementsSelectable*/
      3) {
        each_value = ensure_array_like_dev(
          /*$visibleEdges*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block3, t1, get_each_context3);
        check_outros();
      }
      if (
        /*$visibleEdges*/
        ctx2[0].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$visibleEdges*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(markerdefinition.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(markerdefinition.$$.fragment, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(markerdefinition);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let $visibleEdges;
  let $elementsSelectable;
  let $edgesInitialized;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeRenderer", slots, []);
  let { defaultEdgeOptions } = $$props;
  const { visibleEdges, edgesInitialized, edges: { setDefaultOptions }, elementsSelectable } = useStore();
  validate_store(visibleEdges, "visibleEdges");
  component_subscribe($$self, visibleEdges, (value) => $$invalidate(0, $visibleEdges = value));
  validate_store(edgesInitialized, "edgesInitialized");
  component_subscribe($$self, edgesInitialized, (value) => $$invalidate(2, $edgesInitialized = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(1, $elementsSelectable = value));
  onMount(() => {
    if (defaultEdgeOptions) setDefaultOptions(defaultEdgeOptions);
  });
  $$self.$$.on_mount.push(function() {
    if (defaultEdgeOptions === void 0 && !("defaultEdgeOptions" in $$props || $$self.$$.bound[$$self.$$.props["defaultEdgeOptions"]])) {
      console.warn("<EdgeRenderer> was created without expected prop 'defaultEdgeOptions'");
    }
  });
  const writable_props = ["defaultEdgeOptions"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<EdgeRenderer> was created with unknown prop '${key2}'`);
  });
  function edgeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  const func2 = () => {
    set_store_value(edgesInitialized, $edgesInitialized = true, $edgesInitialized);
  };
  const func_1 = () => {
    set_store_value(edgesInitialized, $edgesInitialized = false, $edgesInitialized);
  };
  $$self.$$set = ($$props2) => {
    if ("defaultEdgeOptions" in $$props2) $$invalidate(6, defaultEdgeOptions = $$props2.defaultEdgeOptions);
  };
  $$self.$capture_state = () => ({
    onMount,
    EdgeWrapper: EdgeWrapper_default,
    CallOnMount: CallOnMount_default,
    MarkerDefinition: MarkerDefinition_default,
    useStore,
    defaultEdgeOptions,
    visibleEdges,
    edgesInitialized,
    setDefaultOptions,
    elementsSelectable,
    $visibleEdges,
    $elementsSelectable,
    $edgesInitialized
  });
  $$self.$inject_state = ($$props2) => {
    if ("defaultEdgeOptions" in $$props2) $$invalidate(6, defaultEdgeOptions = $$props2.defaultEdgeOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $visibleEdges,
    $elementsSelectable,
    $edgesInitialized,
    visibleEdges,
    edgesInitialized,
    elementsSelectable,
    defaultEdgeOptions,
    edgeclick_handler,
    edgecontextmenu_handler,
    edgemouseenter_handler,
    edgemouseleave_handler,
    func2,
    func_1
  ];
}
var EdgeRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { defaultEdgeOptions: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeRenderer",
      options,
      id: create_fragment26.name
    });
  }
  get defaultEdgeOptions() {
    throw new Error("<EdgeRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultEdgeOptions(value) {
    throw new Error("<EdgeRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeRenderer_default = EdgeRenderer;

// node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte
var file14 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\Selection\\Selection.svelte";
function add_css5(target) {
  append_styles(target, "svelte-1iugwpu", ".svelte-flow__selection.svelte-1iugwpu{position:absolute;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0aW9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFpdXNlcjlcXERvY3VtZW50c1xcbXVrZXNoXFxuZXctd29ya2luZy13ZWItbWFpblxcbmV3LXdvcmtpbmctd2ViLW1haW5cXHNwZWN0cmEtbGl0ZVxcbm9kZV9tb2R1bGVzXFxAeHlmbG93XFxzdmVsdGVcXGRpc3RcXGxpYlxcY29tcG9uZW50c1xcU2VsZWN0aW9uXFxTZWxlY3Rpb24uc3ZlbHRlIl19 */");
}
function create_if_block6(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-flow__selection svelte-1iugwpu");
      set_style(div, "width", typeof /*width*/
      ctx[2] === "string" ? (
        /*width*/
        ctx[2]
      ) : `${/*width*/
      ctx[2]}px`);
      set_style(div, "height", typeof /*height*/
      ctx[3] === "string" ? (
        /*height*/
        ctx[3]
      ) : `${/*height*/
      ctx[3]}px`);
      set_style(div, "transform", `translate(${/*x*/
      ctx[0]}px, ${/*y*/
      ctx[1]}px)`);
      add_location(div, file14, 8, 2, 147);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*width*/
      4) {
        set_style(div, "width", typeof /*width*/
        ctx2[2] === "string" ? (
          /*width*/
          ctx2[2]
        ) : `${/*width*/
        ctx2[2]}px`);
      }
      if (dirty & /*height*/
      8) {
        set_style(div, "height", typeof /*height*/
        ctx2[3] === "string" ? (
          /*height*/
          ctx2[3]
        ) : `${/*height*/
        ctx2[3]}px`);
      }
      if (dirty & /*x, y*/
      3) {
        set_style(div, "transform", `translate(${/*x*/
        ctx2[0]}px, ${/*y*/
        ctx2[1]}px)`);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(8:0) {#if isVisible}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let if_block_anchor;
  let if_block = (
    /*isVisible*/
    ctx[4] && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isVisible*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Selection", slots, []);
  let { x = 0 } = $$props;
  let { y = 0 } = $$props;
  let { width = 0 } = $$props;
  let { height = 0 } = $$props;
  let { isVisible = true } = $$props;
  const writable_props = ["x", "y", "width", "height", "isVisible"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Selection> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("isVisible" in $$props2) $$invalidate(4, isVisible = $$props2.isVisible);
  };
  $$self.$capture_state = () => ({ x, y, width, height, isVisible });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("isVisible" in $$props2) $$invalidate(4, isVisible = $$props2.isVisible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [x, y, width, height, isVisible];
}
var Selection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance27,
      create_fragment27,
      safe_not_equal,
      {
        x: 0,
        y: 1,
        width: 2,
        height: 3,
        isVisible: 4
      },
      add_css5
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Selection",
      options,
      id: create_fragment27.name
    });
  }
  get x() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Selection_default = Selection;

// node_modules/@xyflow/svelte/dist/lib/components/UserSelection/UserSelection.svelte
function create_fragment28(ctx) {
  var _a, _b, _c, _d;
  let selection;
  let current;
  selection = new Selection_default({
    props: {
      isVisible: !!/*$selectionRect*/
      (ctx[0] && /*$selectionRectMode*/
      ctx[1] === "user"),
      width: (
        /*$selectionRect*/
        (_a = ctx[0]) == null ? void 0 : _a.width
      ),
      height: (
        /*$selectionRect*/
        (_b = ctx[0]) == null ? void 0 : _b.height
      ),
      x: (
        /*$selectionRect*/
        (_c = ctx[0]) == null ? void 0 : _c.x
      ),
      y: (
        /*$selectionRect*/
        (_d = ctx[0]) == null ? void 0 : _d.y
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(selection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(selection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(selection, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2;
      const selection_changes = {};
      if (dirty & /*$selectionRect, $selectionRectMode*/
      3) selection_changes.isVisible = !!/*$selectionRect*/
      (ctx2[0] && /*$selectionRectMode*/
      ctx2[1] === "user");
      if (dirty & /*$selectionRect*/
      1) selection_changes.width = /*$selectionRect*/
      (_a2 = ctx2[0]) == null ? void 0 : _a2.width;
      if (dirty & /*$selectionRect*/
      1) selection_changes.height = /*$selectionRect*/
      (_b2 = ctx2[0]) == null ? void 0 : _b2.height;
      if (dirty & /*$selectionRect*/
      1) selection_changes.x = /*$selectionRect*/
      (_c2 = ctx2[0]) == null ? void 0 : _c2.x;
      if (dirty & /*$selectionRect*/
      1) selection_changes.y = /*$selectionRect*/
      (_d2 = ctx2[0]) == null ? void 0 : _d2.y;
      selection.$set(selection_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(selection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(selection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let $selectionRect;
  let $selectionRectMode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UserSelection", slots, []);
  const { selectionRect, selectionRectMode } = useStore();
  validate_store(selectionRect, "selectionRect");
  component_subscribe($$self, selectionRect, (value) => $$invalidate(0, $selectionRect = value));
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(1, $selectionRectMode = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<UserSelection> was created with unknown prop '${key2}'`);
  });
  $$self.$capture_state = () => ({
    useStore,
    Selection: Selection_default,
    selectionRect,
    selectionRectMode,
    $selectionRect,
    $selectionRectMode
  });
  return [$selectionRect, $selectionRectMode, selectionRect, selectionRectMode];
}
var UserSelection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserSelection",
      options,
      id: create_fragment28.name
    });
  }
};
var UserSelection_default = UserSelection;

// node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte
var file15 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\NodeSelection\\NodeSelection.svelte";
function add_css6(target) {
  append_styles(target, "svelte-5pxri", ".selection-wrapper.svelte-5pxri{position:absolute;top:0;left:0;z-index:7;pointer-events:all}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZVNlbGVjdGlvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhaXVzZXI5XFxEb2N1bWVudHNcXG11a2VzaFxcbmV3LXdvcmtpbmctd2ViLW1haW5cXG5ldy13b3JraW5nLXdlYi1tYWluXFxzcGVjdHJhLWxpdGVcXG5vZGVfbW9kdWxlc1xcQHh5Zmxvd1xcc3ZlbHRlXFxkaXN0XFxsaWJcXGNvbXBvbmVudHNcXE5vZGVTZWxlY3Rpb25cXE5vZGVTZWxlY3Rpb24uc3ZlbHRlIl19 */");
}
function create_if_block7(ctx) {
  let div;
  let selection;
  let drag_action;
  let current;
  let mounted;
  let dispose;
  selection = new Selection_default({
    props: {
      width: "100%",
      height: "100%",
      x: 0,
      y: 0
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(selection.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        style: true,
        role: true,
        tabindex: true
      });
      var div_nodes = children(div);
      claim_component(selection.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "selection-wrapper nopan svelte-5pxri");
      set_style(
        div,
        "width",
        /*bounds*/
        ctx[1].width + "px"
      );
      set_style(
        div,
        "height",
        /*bounds*/
        ctx[1].height + "px"
      );
      set_style(div, "transform", "translate(" + /*bounds*/
      ctx[1].x + "px, " + /*bounds*/
      ctx[1].y + "px)");
      attr_dev(div, "role", "button");
      attr_dev(div, "tabindex", "-1");
      add_location(div, file15, 24, 2, 956);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(selection, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(drag_action = drag.call(null, div, {
            disabled: false,
            store: (
              /*store*/
              ctx[2]
            ),
            onDrag: (
              /*drag_function*/
              ctx[11]
            ),
            onDragStart: (
              /*drag_function_1*/
              ctx[12]
            ),
            onDragStop: (
              /*drag_function_2*/
              ctx[13]
            )
          })),
          listen_dev(
            div,
            "contextmenu",
            /*onContextMenu*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*onClick*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(div, "keyup", keyup_handler2, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*bounds*/
      2) {
        set_style(
          div,
          "width",
          /*bounds*/
          ctx2[1].width + "px"
        );
      }
      if (!current || dirty & /*bounds*/
      2) {
        set_style(
          div,
          "height",
          /*bounds*/
          ctx2[1].height + "px"
        );
      }
      if (!current || dirty & /*bounds*/
      2) {
        set_style(div, "transform", "translate(" + /*bounds*/
        ctx2[1].x + "px, " + /*bounds*/
        ctx2[1].y + "px)");
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(selection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(selection);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(24:0) {#if $selectionRectMode === 'nodes' && bounds && isNumeric(bounds.x) && isNumeric(bounds.y)}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let show_if = (
    /*$selectionRectMode*/
    ctx[0] === "nodes" && /*bounds*/
    ctx[1] && isNumeric(
      /*bounds*/
      ctx[1].x
    ) && isNumeric(
      /*bounds*/
      ctx[1].y
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block7(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$selectionRectMode, bounds*/
      3) show_if = /*$selectionRectMode*/
      ctx2[0] === "nodes" && /*bounds*/
      ctx2[1] && isNumeric(
        /*bounds*/
        ctx2[1].x
      ) && isNumeric(
        /*bounds*/
        ctx2[1].y
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$selectionRectMode, bounds*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keyup_handler2 = () => {
};
function instance29($$self, $$props, $$invalidate) {
  let $nodes;
  let $nodeLookup;
  let $selectionRectMode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeSelection", slots, []);
  const store = useStore();
  const { selectionRectMode, nodes, nodeLookup } = store;
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(0, $selectionRectMode = value));
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(9, $nodes = value));
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(10, $nodeLookup = value));
  const dispatch = createEventDispatcher();
  let bounds = null;
  function onContextMenu(event) {
    const selectedNodes = $nodes.filter((n) => n.selected);
    dispatch("selectioncontextmenu", { nodes: selectedNodes, event });
  }
  function onClick(event) {
    const selectedNodes = $nodes.filter((n) => n.selected);
    dispatch("selectionclick", { nodes: selectedNodes, event });
  }
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<NodeSelection> was created with unknown prop '${key2}'`);
  });
  const drag_function = (event, _, __, nodes2) => {
    dispatch("nodedrag", { event, targetNode: null, nodes: nodes2 });
  };
  const drag_function_1 = (event, _, __, nodes2) => {
    dispatch("nodedragstart", { event, targetNode: null, nodes: nodes2 });
  };
  const drag_function_2 = (event, _, __, nodes2) => {
    dispatch("nodedragstop", { event, targetNode: null, nodes: nodes2 });
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getInternalNodesBounds,
    isNumeric,
    useStore,
    Selection: Selection_default,
    drag,
    store,
    selectionRectMode,
    nodes,
    nodeLookup,
    dispatch,
    bounds,
    onContextMenu,
    onClick,
    $nodes,
    $nodeLookup,
    $selectionRectMode
  });
  $$self.$inject_state = ($$props2) => {
    if ("bounds" in $$props2) $$invalidate(1, bounds = $$props2.bounds);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectionRectMode, $nodeLookup, $nodes*/
    1537) {
      $: if ($selectionRectMode === "nodes") {
        $$invalidate(1, bounds = getInternalNodesBounds($nodeLookup, { filter: (node) => !!node.selected }));
        $nodes;
      }
    }
  };
  return [
    $selectionRectMode,
    bounds,
    store,
    selectionRectMode,
    nodes,
    nodeLookup,
    dispatch,
    onContextMenu,
    onClick,
    $nodes,
    $nodeLookup,
    drag_function,
    drag_function_1,
    drag_function_2
  ];
}
var NodeSelection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {}, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeSelection",
      options,
      id: create_fragment29.name
    });
  }
};
var NodeSelection_default = NodeSelection;

// node_modules/@svelte-put/shortcut/src/shortcut.js
function shortcut(node, param) {
  let { enabled = true, trigger, type = "keydown" } = param;
  function handler(event) {
    const normalizedTriggers = Array.isArray(trigger) ? trigger : [trigger];
    const modifiedMap = {
      alt: event.altKey,
      ctrl: event.ctrlKey,
      shift: event.shiftKey,
      meta: event.metaKey
    };
    for (const trigger2 of normalizedTriggers) {
      const mergedTrigger = {
        modifier: [],
        preventDefault: false,
        enabled: true,
        ...trigger2
      };
      const { modifier, key: key2, callback, preventDefault, enabled: triggerEnabled } = mergedTrigger;
      if (triggerEnabled) {
        if (modifier.length) {
          const modifierDefs = (Array.isArray(modifier) ? modifier : [modifier]).map(
            (def) => typeof def === "string" ? [def] : def
          );
          const modified = modifierDefs.some(
            (def) => def.every((modifier2) => modifiedMap[modifier2])
          );
          if (!modified) continue;
        }
        if (event.key === key2) {
          if (preventDefault) event.preventDefault();
          const detail = {
            node,
            trigger: mergedTrigger,
            originalEvent: event
          };
          node.dispatchEvent(new CustomEvent("shortcut", { detail }));
          callback == null ? void 0 : callback(detail);
        }
      }
    }
  }
  if (enabled) node.addEventListener(type, handler);
  return {
    update: (update) => {
      const { enabled: newEnabled = true, type: newType = "keydown" } = update;
      if (enabled && (!newEnabled || type !== newType)) {
        node.removeEventListener(type, handler);
      } else if (!enabled && newEnabled) {
        node.addEventListener(newType, handler);
      }
      enabled = newEnabled;
      type = newType;
      trigger = update.trigger;
    },
    destroy: () => {
      node.removeEventListener(type, handler);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/KeyHandler/KeyHandler.svelte
function create_fragment30(ctx) {
  let shortcut_action;
  let shortcut_action_1;
  let shortcut_action_2;
  let shortcut_action_3;
  let shortcut_action_4;
  let shortcut_action_5;
  let shortcut_action_6;
  let shortcut_action_7;
  let shortcut_action_8;
  let shortcut_action_9;
  let mounted;
  let dispose;
  const block = {
    c: noop,
    l: noop,
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = [
          action_destroyer(shortcut_action = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*selectionKey*/
              ctx[0],
              /*shortcut_function*/
              ctx[11]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_1 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*selectionKey*/
              ctx[0],
              /*shortcut_function_1*/
              ctx[12]
            ),
            type: "keyup"
          })),
          action_destroyer(shortcut_action_2 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*multiSelectionKey*/
              ctx[1],
              /*shortcut_function_2*/
              ctx[13]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_3 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*multiSelectionKey*/
              ctx[1],
              /*shortcut_function_3*/
              ctx[14]
            ),
            type: "keyup"
          })),
          action_destroyer(shortcut_action_4 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*deleteKey*/
              ctx[2],
              /*shortcut_function_4*/
              ctx[15]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_5 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*deleteKey*/
              ctx[2],
              /*shortcut_function_5*/
              ctx[16]
            ),
            type: "keyup"
          })),
          action_destroyer(shortcut_action_6 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*panActivationKey*/
              ctx[3],
              /*shortcut_function_6*/
              ctx[17]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_7 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*panActivationKey*/
              ctx[3],
              /*shortcut_function_7*/
              ctx[18]
            ),
            type: "keyup"
          })),
          action_destroyer(shortcut_action_8 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*zoomActivationKey*/
              ctx[4],
              /*shortcut_function_8*/
              ctx[19]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_9 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*zoomActivationKey*/
              ctx[4],
              /*shortcut_function_9*/
              ctx[20]
            ),
            type: "keyup"
          })),
          listen_dev(
            window,
            "blur",
            /*resetKeysAndSelection*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "contextmenu",
            /*resetKeysAndSelection*/
            ctx[10],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (shortcut_action && is_function(shortcut_action.update) && dirty & /*selectionKey*/
      1) shortcut_action.update.call(null, {
        trigger: getShortcutTrigger(
          /*selectionKey*/
          ctx2[0],
          /*shortcut_function*/
          ctx2[11]
        ),
        type: "keydown"
      });
      if (shortcut_action_1 && is_function(shortcut_action_1.update) && dirty & /*selectionKey*/
      1) shortcut_action_1.update.call(null, {
        trigger: getShortcutTrigger(
          /*selectionKey*/
          ctx2[0],
          /*shortcut_function_1*/
          ctx2[12]
        ),
        type: "keyup"
      });
      if (shortcut_action_2 && is_function(shortcut_action_2.update) && dirty & /*multiSelectionKey*/
      2) shortcut_action_2.update.call(null, {
        trigger: getShortcutTrigger(
          /*multiSelectionKey*/
          ctx2[1],
          /*shortcut_function_2*/
          ctx2[13]
        ),
        type: "keydown"
      });
      if (shortcut_action_3 && is_function(shortcut_action_3.update) && dirty & /*multiSelectionKey*/
      2) shortcut_action_3.update.call(null, {
        trigger: getShortcutTrigger(
          /*multiSelectionKey*/
          ctx2[1],
          /*shortcut_function_3*/
          ctx2[14]
        ),
        type: "keyup"
      });
      if (shortcut_action_4 && is_function(shortcut_action_4.update) && dirty & /*deleteKey*/
      4) shortcut_action_4.update.call(null, {
        trigger: getShortcutTrigger(
          /*deleteKey*/
          ctx2[2],
          /*shortcut_function_4*/
          ctx2[15]
        ),
        type: "keydown"
      });
      if (shortcut_action_5 && is_function(shortcut_action_5.update) && dirty & /*deleteKey*/
      4) shortcut_action_5.update.call(null, {
        trigger: getShortcutTrigger(
          /*deleteKey*/
          ctx2[2],
          /*shortcut_function_5*/
          ctx2[16]
        ),
        type: "keyup"
      });
      if (shortcut_action_6 && is_function(shortcut_action_6.update) && dirty & /*panActivationKey*/
      8) shortcut_action_6.update.call(null, {
        trigger: getShortcutTrigger(
          /*panActivationKey*/
          ctx2[3],
          /*shortcut_function_6*/
          ctx2[17]
        ),
        type: "keydown"
      });
      if (shortcut_action_7 && is_function(shortcut_action_7.update) && dirty & /*panActivationKey*/
      8) shortcut_action_7.update.call(null, {
        trigger: getShortcutTrigger(
          /*panActivationKey*/
          ctx2[3],
          /*shortcut_function_7*/
          ctx2[18]
        ),
        type: "keyup"
      });
      if (shortcut_action_8 && is_function(shortcut_action_8.update) && dirty & /*zoomActivationKey*/
      16) shortcut_action_8.update.call(null, {
        trigger: getShortcutTrigger(
          /*zoomActivationKey*/
          ctx2[4],
          /*shortcut_function_8*/
          ctx2[19]
        ),
        type: "keydown"
      });
      if (shortcut_action_9 && is_function(shortcut_action_9.update) && dirty & /*zoomActivationKey*/
      16) shortcut_action_9.update.call(null, {
        trigger: getShortcutTrigger(
          /*zoomActivationKey*/
          ctx2[4],
          /*shortcut_function_9*/
          ctx2[20]
        ),
        type: "keyup"
      });
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function isKeyObject(key2) {
  return key2 !== null && typeof key2 === "object";
}
function getModifier(key2) {
  return isKeyObject(key2) ? key2.modifier || [] : [];
}
function getKeyString(key2) {
  if (key2 === null || key2 === void 0) {
    return "";
  }
  return isKeyObject(key2) ? key2.key : key2;
}
function getShortcutTrigger(key2, callback) {
  const keys = Array.isArray(key2) ? key2 : [key2];
  return keys.map((_key) => {
    const keyString = getKeyString(_key);
    return {
      key: keyString,
      modifier: getModifier(_key),
      enabled: keyString !== null,
      callback
    };
  });
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("KeyHandler", slots, []);
  let { selectionKey = "Shift" } = $$props;
  let { multiSelectionKey = isMacOs() ? "Meta" : "Control" } = $$props;
  let { deleteKey = "Backspace" } = $$props;
  let { panActivationKey = " " } = $$props;
  let { zoomActivationKey = isMacOs() ? "Meta" : "Control" } = $$props;
  const { selectionKeyPressed, multiselectionKeyPressed, deleteKeyPressed, panActivationKeyPressed, zoomActivationKeyPressed, selectionRect } = useStore();
  function resetKeysAndSelection() {
    selectionRect.set(null);
    selectionKeyPressed.set(false);
    multiselectionKeyPressed.set(false);
    deleteKeyPressed.set(false);
    panActivationKeyPressed.set(false);
    zoomActivationKeyPressed.set(false);
  }
  const writable_props = [
    "selectionKey",
    "multiSelectionKey",
    "deleteKey",
    "panActivationKey",
    "zoomActivationKey"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<KeyHandler> was created with unknown prop '${key2}'`);
  });
  const shortcut_function = () => selectionKeyPressed.set(true);
  const shortcut_function_1 = () => selectionKeyPressed.set(false);
  const shortcut_function_2 = () => multiselectionKeyPressed.set(true);
  const shortcut_function_3 = () => multiselectionKeyPressed.set(false);
  const shortcut_function_4 = (detail) => {
    const isModifierKey = detail.originalEvent.ctrlKey || detail.originalEvent.metaKey || detail.originalEvent.shiftKey;
    if (!isModifierKey && !isInputDOMNode(detail.originalEvent)) {
      deleteKeyPressed.set(true);
    }
  };
  const shortcut_function_5 = () => deleteKeyPressed.set(false);
  const shortcut_function_6 = () => panActivationKeyPressed.set(true);
  const shortcut_function_7 = () => panActivationKeyPressed.set(false);
  const shortcut_function_8 = () => zoomActivationKeyPressed.set(true);
  const shortcut_function_9 = () => zoomActivationKeyPressed.set(false);
  $$self.$$set = ($$props2) => {
    if ("selectionKey" in $$props2) $$invalidate(0, selectionKey = $$props2.selectionKey);
    if ("multiSelectionKey" in $$props2) $$invalidate(1, multiSelectionKey = $$props2.multiSelectionKey);
    if ("deleteKey" in $$props2) $$invalidate(2, deleteKey = $$props2.deleteKey);
    if ("panActivationKey" in $$props2) $$invalidate(3, panActivationKey = $$props2.panActivationKey);
    if ("zoomActivationKey" in $$props2) $$invalidate(4, zoomActivationKey = $$props2.zoomActivationKey);
  };
  $$self.$capture_state = () => ({
    shortcut,
    isInputDOMNode,
    isMacOs,
    useStore,
    selectionKey,
    multiSelectionKey,
    deleteKey,
    panActivationKey,
    zoomActivationKey,
    selectionKeyPressed,
    multiselectionKeyPressed,
    deleteKeyPressed,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    selectionRect,
    isKeyObject,
    getModifier,
    getKeyString,
    getShortcutTrigger,
    resetKeysAndSelection
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectionKey" in $$props2) $$invalidate(0, selectionKey = $$props2.selectionKey);
    if ("multiSelectionKey" in $$props2) $$invalidate(1, multiSelectionKey = $$props2.multiSelectionKey);
    if ("deleteKey" in $$props2) $$invalidate(2, deleteKey = $$props2.deleteKey);
    if ("panActivationKey" in $$props2) $$invalidate(3, panActivationKey = $$props2.panActivationKey);
    if ("zoomActivationKey" in $$props2) $$invalidate(4, zoomActivationKey = $$props2.zoomActivationKey);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    selectionKey,
    multiSelectionKey,
    deleteKey,
    panActivationKey,
    zoomActivationKey,
    selectionKeyPressed,
    multiselectionKeyPressed,
    deleteKeyPressed,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    resetKeysAndSelection,
    shortcut_function,
    shortcut_function_1,
    shortcut_function_2,
    shortcut_function_3,
    shortcut_function_4,
    shortcut_function_5,
    shortcut_function_6,
    shortcut_function_7,
    shortcut_function_8,
    shortcut_function_9
  ];
}
var KeyHandler = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      selectionKey: 0,
      multiSelectionKey: 1,
      deleteKey: 2,
      panActivationKey: 3,
      zoomActivationKey: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "KeyHandler",
      options,
      id: create_fragment30.name
    });
  }
  get selectionKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiSelectionKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiSelectionKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panActivationKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panActivationKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomActivationKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomActivationKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var KeyHandler_default = KeyHandler;

// node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte
var file16 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\ConnectionLine\\ConnectionLine.svelte";
var get_connectionLine_slot_changes = (dirty) => ({});
var get_connectionLine_slot_context = (ctx) => ({});
function create_if_block8(ctx) {
  let svg;
  let g;
  let g_class_value;
  let current;
  const connectionLine_slot_template = (
    /*#slots*/
    ctx[13].connectionLine
  );
  const connectionLine_slot = create_slot(
    connectionLine_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_connectionLine_slot_context
  );
  let if_block = !/*isCustomComponent*/
  ctx[2] && create_if_block_13(ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      g = svg_element("g");
      if (connectionLine_slot) connectionLine_slot.c();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        class: true,
        style: true
      });
      var svg_nodes = children(svg);
      g = claim_svg_element(svg_nodes, "g", { class: true });
      var g_nodes = children(g);
      if (connectionLine_slot) connectionLine_slot.l(g_nodes);
      if (if_block) if_block.l(g_nodes);
      g_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "class", g_class_value = cc([
        "svelte-flow__connection",
        getConnectionStatus(
          /*$connection*/
          ctx[3].isValid
        )
      ]));
      add_location(g, file16, 39, 4, 1352);
      attr_dev(
        svg,
        "width",
        /*$width*/
        ctx[5]
      );
      attr_dev(
        svg,
        "height",
        /*$height*/
        ctx[6]
      );
      attr_dev(svg, "class", "svelte-flow__connectionline");
      attr_dev(
        svg,
        "style",
        /*containerStyle*/
        ctx[0]
      );
      add_location(svg, file16, 38, 2, 1251);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, g);
      if (connectionLine_slot) {
        connectionLine_slot.m(g, null);
      }
      if (if_block) if_block.m(g, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (connectionLine_slot) {
        if (connectionLine_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            connectionLine_slot,
            connectionLine_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              connectionLine_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_connectionLine_slot_changes
            ),
            get_connectionLine_slot_context
          );
        }
      }
      if (!/*isCustomComponent*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          if_block.m(g, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*$connection*/
      8 && g_class_value !== (g_class_value = cc([
        "svelte-flow__connection",
        getConnectionStatus(
          /*$connection*/
          ctx2[3].isValid
        )
      ]))) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty & /*$width*/
      32) {
        attr_dev(
          svg,
          "width",
          /*$width*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*$height*/
      64) {
        attr_dev(
          svg,
          "height",
          /*$height*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*containerStyle*/
      1) {
        attr_dev(
          svg,
          "style",
          /*containerStyle*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(connectionLine_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(connectionLine_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (connectionLine_slot) connectionLine_slot.d(detaching);
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(38:0) {#if $connection.inProgress}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let path_1;
  const block = {
    c: function create() {
      path_1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path_1 = claim_svg_element(nodes, "path", {
        d: true,
        style: true,
        fill: true,
        class: true
      });
      children(path_1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[4]
      );
      attr_dev(
        path_1,
        "style",
        /*style*/
        ctx[1]
      );
      attr_dev(path_1, "fill", "none");
      attr_dev(path_1, "class", "svelte-flow__connection-path");
      add_location(path_1, file16, 43, 8, 1589);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*path*/
      16) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[4]
        );
      }
      if (dirty & /*style*/
      2) {
        attr_dev(
          path_1,
          "style",
          /*style*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(43:6) {#if !isCustomComponent}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$connection*/
    ctx[3].inProgress && create_if_block8(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$connection*/
        ctx2[3].inProgress
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$connection*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let $connectionLineType;
  let $connection;
  let $width;
  let $height;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ConnectionLine", slots, ["connectionLine"]);
  let { containerStyle = "" } = $$props;
  let { style = "" } = $$props;
  let { isCustomComponent = false } = $$props;
  const { width, height, connection, connectionLineType } = useStore();
  validate_store(width, "width");
  component_subscribe($$self, width, (value) => $$invalidate(5, $width = value));
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(6, $height = value));
  validate_store(connection, "connection");
  component_subscribe($$self, connection, (value) => $$invalidate(3, $connection = value));
  validate_store(connectionLineType, "connectionLineType");
  component_subscribe($$self, connectionLineType, (value) => $$invalidate(11, $connectionLineType = value));
  let path = null;
  const writable_props = ["containerStyle", "style", "isCustomComponent"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<ConnectionLine> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("containerStyle" in $$props2) $$invalidate(0, containerStyle = $$props2.containerStyle);
    if ("style" in $$props2) $$invalidate(1, style = $$props2.style);
    if ("isCustomComponent" in $$props2) $$invalidate(2, isCustomComponent = $$props2.isCustomComponent);
    if ("$$scope" in $$props2) $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    useStore,
    ConnectionLineType,
    getBezierPath,
    getConnectionStatus,
    getSmoothStepPath,
    getStraightPath,
    containerStyle,
    style,
    isCustomComponent,
    width,
    height,
    connection,
    connectionLineType,
    path,
    $connectionLineType,
    $connection,
    $width,
    $height
  });
  $$self.$inject_state = ($$props2) => {
    if ("containerStyle" in $$props2) $$invalidate(0, containerStyle = $$props2.containerStyle);
    if ("style" in $$props2) $$invalidate(1, style = $$props2.style);
    if ("isCustomComponent" in $$props2) $$invalidate(2, isCustomComponent = $$props2.isCustomComponent);
    if ("path" in $$props2) $$invalidate(4, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$connection, isCustomComponent, $connectionLineType*/
    2060) {
      $: if ($connection.inProgress && !isCustomComponent) {
        const { from, to, fromPosition, toPosition } = $connection;
        const pathParams = {
          sourceX: from.x,
          sourceY: from.y,
          sourcePosition: fromPosition,
          targetX: to.x,
          targetY: to.y,
          targetPosition: toPosition
        };
        switch ($connectionLineType) {
          case ConnectionLineType.Bezier:
            $$invalidate(4, [path] = getBezierPath(pathParams), path);
            break;
          case ConnectionLineType.Step:
            $$invalidate(4, [path] = getSmoothStepPath({ ...pathParams, borderRadius: 0 }), path);
            break;
          case ConnectionLineType.SmoothStep:
            $$invalidate(4, [path] = getSmoothStepPath(pathParams), path);
            break;
          default:
            $$invalidate(4, [path] = getStraightPath(pathParams), path);
        }
      }
    }
  };
  return [
    containerStyle,
    style,
    isCustomComponent,
    $connection,
    path,
    $width,
    $height,
    width,
    height,
    connection,
    connectionLineType,
    $connectionLineType,
    $$scope,
    slots
  ];
}
var ConnectionLine = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      containerStyle: 0,
      style: 1,
      isCustomComponent: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ConnectionLine",
      options,
      id: create_fragment31.name
    });
  }
  get containerStyle() {
    throw new Error("<ConnectionLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerStyle(value) {
    throw new Error("<ConnectionLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<ConnectionLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<ConnectionLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustomComponent() {
    throw new Error("<ConnectionLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustomComponent(value) {
    throw new Error("<ConnectionLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ConnectionLine_default = ConnectionLine;

// node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte
var file17 = "node_modules\\@xyflow\\svelte\\dist\\lib\\container\\Panel\\Panel.svelte";
function create_fragment32(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    {
      class: div_class_value = cc([
        "svelte-flow__panel",
        /*className*/
        ctx[1],
        .../*positionClasses*/
        ctx[2]
      ])
    },
    { style: (
      /*style*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      set_style(
        div,
        "pointer-events",
        /*$selectionRectMode*/
        ctx[3] ? "none" : ""
      );
      add_location(div, file17, 10, 0, 298);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className, positionClasses*/
        6 && div_class_value !== (div_class_value = cc([
          "svelte-flow__panel",
          /*className*/
          ctx2[1],
          .../*positionClasses*/
          ctx2[2]
        ]))) && { class: div_class_value },
        (!current || dirty & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      set_style(
        div,
        "pointer-events",
        /*$selectionRectMode*/
        ctx2[3] ? "none" : ""
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let positionClasses;
  const omit_props_names = ["position", "style", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectionRectMode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Panel", slots, ["default"]);
  let { position = "top-right" } = $$props;
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  const { selectionRectMode } = useStore();
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(3, $selectionRectMode = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("position" in $$new_props) $$invalidate(6, position = $$new_props.position);
    if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
    if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    useStore,
    position,
    style,
    className,
    selectionRectMode,
    positionClasses,
    $selectionRectMode
  });
  $$self.$inject_state = ($$new_props) => {
    if ("position" in $$props) $$invalidate(6, position = $$new_props.position);
    if ("style" in $$props) $$invalidate(0, style = $$new_props.style);
    if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    if ("positionClasses" in $$props) $$invalidate(2, positionClasses = $$new_props.positionClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*position*/
    64) {
      $: $$invalidate(2, positionClasses = `${position}`.split("-"));
    }
  };
  return [
    style,
    className,
    positionClasses,
    $selectionRectMode,
    selectionRectMode,
    $$restProps,
    position,
    $$scope,
    slots
  ];
}
var Panel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { position: 6, style: 0, class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Panel",
      options,
      id: create_fragment32.name
    });
  }
  get position() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Panel_default = Panel;

// node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte
var file18 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\Attribution\\Attribution.svelte";
function create_if_block9(ctx) {
  let panel;
  let current;
  panel = new Panel_default({
    props: {
      position: (
        /*position*/
        ctx[1]
      ),
      class: "svelte-flow__attribution",
      "data-message": "Feel free to remove the attribution or check out how you could support us: https://svelteflow.dev/support-us",
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(panel.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(panel.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty & /*position*/
      2) panel_changes.position = /*position*/
      ctx2[1];
      if (dirty & /*$$scope*/
      4) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(panel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(panel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(6:0) {#if !proOptions?.hideAttribution}",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let a;
  let textContent = "Svelte Flow";
  const block = {
    c: function create() {
      a = element("a");
      a.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        href: true,
        target: true,
        rel: true,
        "aria-label": true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(a) !== "svelte-2vm8e4") a.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", "https://svelteflow.dev");
      attr_dev(a, "target", "_blank");
      attr_dev(a, "rel", "noopener noreferrer");
      attr_dev(a, "aria-label", "Svelte Flow attribution");
      add_location(a, file18, 11, 4, 371);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: '(7:2) <Panel     {position}     class=\\"svelte-flow__attribution\\"     data-message=\\"Feel free to remove the attribution or check out how you could support us: https://svelteflow.dev/support-us\\"   >',
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  var _a;
  let if_block_anchor;
  let current;
  let if_block = !/*proOptions*/
  ((_a = ctx[0]) == null ? void 0 : _a.hideAttribution) && create_if_block9(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      if (!/*proOptions*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.hideAttribution)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*proOptions*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Attribution", slots, []);
  let { proOptions = void 0 } = $$props;
  let { position = "bottom-right" } = $$props;
  const writable_props = ["proOptions", "position"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Attribution> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("proOptions" in $$props2) $$invalidate(0, proOptions = $$props2.proOptions);
    if ("position" in $$props2) $$invalidate(1, position = $$props2.position);
  };
  $$self.$capture_state = () => ({ Panel: Panel_default, proOptions, position });
  $$self.$inject_state = ($$props2) => {
    if ("proOptions" in $$props2) $$invalidate(0, proOptions = $$props2.proOptions);
    if ("position" in $$props2) $$invalidate(1, position = $$props2.position);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [proOptions, position];
}
var Attribution = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { proOptions: 0, position: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Attribution",
      options,
      id: create_fragment33.name
    });
  }
  get proOptions() {
    throw new Error("<Attribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set proOptions(value) {
    throw new Error("<Attribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Attribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Attribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Attribution_default = Attribution;

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/utils.js
function updateStore(store, { nodeTypes, edgeTypes, minZoom, maxZoom, translateExtent, paneClickDistance }) {
  if (nodeTypes !== void 0) {
    store.setNodeTypes(nodeTypes);
  }
  if (edgeTypes !== void 0) {
    store.setEdgeTypes(edgeTypes);
  }
  if (minZoom !== void 0) {
    store.setMinZoom(minZoom);
  }
  if (maxZoom !== void 0) {
    store.setMaxZoom(maxZoom);
  }
  if (translateExtent !== void 0) {
    store.setTranslateExtent(translateExtent);
  }
  if (paneClickDistance !== void 0) {
    store.setPaneClickDistance(paneClickDistance);
  }
}
var getKeys = (obj) => Object.keys(obj);
function updateStoreByKeys(store, keys) {
  getKeys(keys).forEach((prop) => {
    const update = keys[prop];
    if (update !== void 0) {
      store[prop].set(update);
    }
  });
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useColorModeClass.js
function getMediaQuery() {
  if (typeof window === "undefined" || !window.matchMedia) {
    return null;
  }
  return window.matchMedia("(prefers-color-scheme: dark)");
}
function useColorModeClass(colorMode = "light") {
  const colorModeClass = readable("light", (set) => {
    if (colorMode !== "system") {
      set(colorMode);
      return;
    }
    const mediaQuery = getMediaQuery();
    const updateColorModeClass = () => set((mediaQuery == null ? void 0 : mediaQuery.matches) ? "dark" : "light");
    set((mediaQuery == null ? void 0 : mediaQuery.matches) ? "dark" : "light");
    mediaQuery == null ? void 0 : mediaQuery.addEventListener("change", updateColorModeClass);
    return () => {
      mediaQuery == null ? void 0 : mediaQuery.removeEventListener("change", updateColorModeClass);
    };
  });
  return colorModeClass;
}

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte
var file19 = "node_modules\\@xyflow\\svelte\\dist\\lib\\container\\SvelteFlow\\SvelteFlow.svelte";
function add_css7(target) {
  append_styles(target, "svelte-12wlba6", ".svelte-flow.svelte-12wlba6{width:100%;height:100%;overflow:hidden;position:relative;z-index:0;background-color:var(--background-color, var(--background-color-default))}:root{--background-color-default:#fff;--background-pattern-color-default:#ddd;--minimap-mask-color-default:rgb(240, 240, 240, 0.6);--minimap-mask-stroke-color-default:none;--minimap-mask-stroke-width-default:1;--controls-button-background-color-default:#fefefe;--controls-button-background-color-hover-default:#f4f4f4;--controls-button-color-default:inherit;--controls-button-color-hover-default:inherit;--controls-button-border-color-default:#eee}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbHRlRmxvdy5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhaXVzZXI5XFxEb2N1bWVudHNcXG11a2VzaFxcbmV3LXdvcmtpbmctd2ViLW1haW5cXG5ldy13b3JraW5nLXdlYi1tYWluXFxzcGVjdHJhLWxpdGVcXG5vZGVfbW9kdWxlc1xcQHh5Zmxvd1xcc3ZlbHRlXFxkaXN0XFxsaWJcXGNvbnRhaW5lclxcU3ZlbHRlRmxvd1xcU3ZlbHRlRmxvdy5zdmVsdGUiXX0= */");
}
var get_connectionLine_slot_changes2 = (dirty) => ({});
var get_connectionLine_slot_context2 = (ctx) => ({ slot: "connectionLine" });
function create_connectionLine_slot(ctx) {
  let current;
  const connectionLine_slot_template = (
    /*#slots*/
    ctx[75].connectionLine
  );
  const connectionLine_slot = create_slot(
    connectionLine_slot_template,
    ctx,
    /*$$scope*/
    ctx[99],
    get_connectionLine_slot_context2
  );
  const block = {
    c: function create() {
      if (connectionLine_slot) connectionLine_slot.c();
    },
    l: function claim(nodes) {
      if (connectionLine_slot) connectionLine_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (connectionLine_slot) {
        connectionLine_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (connectionLine_slot) {
        if (connectionLine_slot.p && (!current || dirty[3] & /*$$scope*/
        64)) {
          update_slot_base(
            connectionLine_slot,
            connectionLine_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[99],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[99]
            ) : get_slot_changes(
              connectionLine_slot_template,
              /*$$scope*/
              ctx2[99],
              dirty,
              get_connectionLine_slot_changes2
            ),
            get_connectionLine_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(connectionLine_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(connectionLine_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (connectionLine_slot) connectionLine_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_connectionLine_slot.name,
    type: "slot",
    source: "(232:10) ",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let edgerenderer;
  let t0;
  let connectionline;
  let t1;
  let div0;
  let t2;
  let div1;
  let t3;
  let noderenderer;
  let t4;
  let nodeselection;
  let current;
  edgerenderer = new EdgeRenderer_default({
    props: {
      defaultEdgeOptions: (
        /*defaultEdgeOptions*/
        ctx[21]
      )
    },
    $$inline: true
  });
  edgerenderer.$on(
    "edgeclick",
    /*edgeclick_handler*/
    ctx[78]
  );
  edgerenderer.$on(
    "edgecontextmenu",
    /*edgecontextmenu_handler*/
    ctx[79]
  );
  edgerenderer.$on(
    "edgemouseenter",
    /*edgemouseenter_handler*/
    ctx[80]
  );
  edgerenderer.$on(
    "edgemouseleave",
    /*edgemouseleave_handler*/
    ctx[81]
  );
  connectionline = new ConnectionLine_default({
    props: {
      containerStyle: (
        /*connectionLineContainerStyle*/
        ctx[7]
      ),
      style: (
        /*connectionLineStyle*/
        ctx[6]
      ),
      isCustomComponent: (
        /*$$slots*/
        ctx[34].connectionLine
      ),
      $$slots: {
        connectionLine: [create_connectionLine_slot]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  noderenderer = new NodeRenderer_default({
    props: {
      nodeClickDistance: (
        /*nodeClickDistance*/
        ctx[23]
      )
    },
    $$inline: true
  });
  noderenderer.$on(
    "nodeclick",
    /*nodeclick_handler*/
    ctx[82]
  );
  noderenderer.$on(
    "nodemouseenter",
    /*nodemouseenter_handler*/
    ctx[83]
  );
  noderenderer.$on(
    "nodemousemove",
    /*nodemousemove_handler*/
    ctx[84]
  );
  noderenderer.$on(
    "nodemouseleave",
    /*nodemouseleave_handler*/
    ctx[85]
  );
  noderenderer.$on(
    "nodedragstart",
    /*nodedragstart_handler*/
    ctx[86]
  );
  noderenderer.$on(
    "nodedrag",
    /*nodedrag_handler*/
    ctx[87]
  );
  noderenderer.$on(
    "nodedragstop",
    /*nodedragstop_handler*/
    ctx[88]
  );
  noderenderer.$on(
    "nodecontextmenu",
    /*nodecontextmenu_handler*/
    ctx[89]
  );
  nodeselection = new NodeSelection_default({ $$inline: true });
  nodeselection.$on(
    "selectionclick",
    /*selectionclick_handler*/
    ctx[90]
  );
  nodeselection.$on(
    "selectioncontextmenu",
    /*selectioncontextmenu_handler*/
    ctx[91]
  );
  nodeselection.$on(
    "nodedragstart",
    /*nodedragstart_handler_1*/
    ctx[92]
  );
  nodeselection.$on(
    "nodedrag",
    /*nodedrag_handler_1*/
    ctx[93]
  );
  nodeselection.$on(
    "nodedragstop",
    /*nodedragstop_handler_1*/
    ctx[94]
  );
  const block = {
    c: function create() {
      create_component(edgerenderer.$$.fragment);
      t0 = space();
      create_component(connectionline.$$.fragment);
      t1 = space();
      div0 = element("div");
      t2 = space();
      div1 = element("div");
      t3 = space();
      create_component(noderenderer.$$.fragment);
      t4 = space();
      create_component(nodeselection.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      claim_component(edgerenderer.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(connectionline.$$.fragment, nodes);
      t1 = claim_space(nodes);
      div0 = claim_element(nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      t3 = claim_space(nodes);
      claim_component(noderenderer.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(nodeselection.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "svelte-flow__edgelabel-renderer");
      add_location(div0, file19, 233, 8, 7149);
      attr_dev(div1, "class", "svelte-flow__viewport-portal");
      add_location(div1, file19, 234, 8, 7205);
    },
    m: function mount(target, anchor) {
      mount_component(edgerenderer, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(connectionline, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div0, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, div1, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(noderenderer, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(nodeselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const edgerenderer_changes = {};
      if (dirty[0] & /*defaultEdgeOptions*/
      2097152) edgerenderer_changes.defaultEdgeOptions = /*defaultEdgeOptions*/
      ctx2[21];
      edgerenderer.$set(edgerenderer_changes);
      const connectionline_changes = {};
      if (dirty[0] & /*connectionLineContainerStyle*/
      128) connectionline_changes.containerStyle = /*connectionLineContainerStyle*/
      ctx2[7];
      if (dirty[0] & /*connectionLineStyle*/
      64) connectionline_changes.style = /*connectionLineStyle*/
      ctx2[6];
      if (dirty[1] & /*$$slots*/
      8) connectionline_changes.isCustomComponent = /*$$slots*/
      ctx2[34].connectionLine;
      if (dirty[3] & /*$$scope*/
      64) {
        connectionline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      connectionline.$set(connectionline_changes);
      const noderenderer_changes = {};
      if (dirty[0] & /*nodeClickDistance*/
      8388608) noderenderer_changes.nodeClickDistance = /*nodeClickDistance*/
      ctx2[23];
      noderenderer.$set(noderenderer_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(edgerenderer.$$.fragment, local);
      transition_in(connectionline.$$.fragment, local);
      transition_in(noderenderer.$$.fragment, local);
      transition_in(nodeselection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(edgerenderer.$$.fragment, local);
      transition_out(connectionline.$$.fragment, local);
      transition_out(noderenderer.$$.fragment, local);
      transition_out(nodeselection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(div0);
        detach_dev(t2);
        detach_dev(div1);
        detach_dev(t3);
        detach_dev(t4);
      }
      destroy_component(edgerenderer, detaching);
      destroy_component(connectionline, detaching);
      destroy_component(noderenderer, detaching);
      destroy_component(nodeselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(219:6) <ViewportComponent>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let viewportcomponent;
  let t;
  let userselection;
  let current;
  viewportcomponent = new Viewport_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  userselection = new UserSelection_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(viewportcomponent.$$.fragment);
      t = space();
      create_component(userselection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(viewportcomponent.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(userselection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(viewportcomponent, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(userselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const viewportcomponent_changes = {};
      if (dirty[0] & /*nodeClickDistance, connectionLineContainerStyle, connectionLineStyle, defaultEdgeOptions*/
      10485952 | dirty[1] & /*$$slots*/
      8 | dirty[3] & /*$$scope*/
      64) {
        viewportcomponent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewportcomponent.$set(viewportcomponent_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(viewportcomponent.$$.fragment, local);
      transition_in(userselection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(viewportcomponent.$$.fragment, local);
      transition_out(userselection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(viewportcomponent, detaching);
      destroy_component(userselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(213:4) <Pane       on:paneclick       on:panecontextmenu       panOnDrag={panOnDrag === undefined ? true : panOnDrag}       {selectionOnDrag}     >",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let pane;
  let current;
  pane = new Pane_default({
    props: {
      panOnDrag: (
        /*panOnDrag*/
        ctx[17] === void 0 ? true : (
          /*panOnDrag*/
          ctx[17]
        )
      ),
      selectionOnDrag: (
        /*selectionOnDrag*/
        ctx[18]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pane.$on(
    "paneclick",
    /*paneclick_handler*/
    ctx[95]
  );
  pane.$on(
    "panecontextmenu",
    /*panecontextmenu_handler*/
    ctx[96]
  );
  const block = {
    c: function create() {
      create_component(pane.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(pane.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(pane, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const pane_changes = {};
      if (dirty[0] & /*panOnDrag*/
      131072) pane_changes.panOnDrag = /*panOnDrag*/
      ctx2[17] === void 0 ? true : (
        /*panOnDrag*/
        ctx2[17]
      );
      if (dirty[0] & /*selectionOnDrag*/
      262144) pane_changes.selectionOnDrag = /*selectionOnDrag*/
      ctx2[18];
      if (dirty[0] & /*nodeClickDistance, connectionLineContainerStyle, connectionLineStyle, defaultEdgeOptions*/
      10485952 | dirty[1] & /*$$slots*/
      8 | dirty[3] & /*$$scope*/
      64) {
        pane_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pane.$set(pane_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(pane.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pane.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pane, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(199:2) <Zoom     initialViewport={initViewport}     {onMoveStart}     {onMove}     {onMoveEnd}     panOnScrollMode={panOnScrollMode === undefined ? PanOnScrollMode.Free : panOnScrollMode}     preventScrolling={preventScrolling === undefined ? true : preventScrolling}     zoomOnScroll={zoomOnScroll === undefined ? true : zoomOnScroll}     zoomOnDoubleClick={zoomOnDoubleClick === undefined ? true : zoomOnDoubleClick}     zoomOnPinch={zoomOnPinch === undefined ? true : zoomOnPinch}     panOnScroll={panOnScroll === undefined ? false : panOnScroll}     panOnDrag={panOnDrag === undefined ? true : panOnDrag}     paneClickDistance={paneClickDistance === undefined ? 0 : paneClickDistance}   >",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let div;
  let keyhandler;
  let t0;
  let zoom2;
  let t1;
  let attribution;
  let t2;
  let div_class_value;
  let div_resize_listener;
  let current;
  let mounted;
  let dispose;
  keyhandler = new KeyHandler_default({
    props: {
      selectionKey: (
        /*selectionKey*/
        ctx[1]
      ),
      deleteKey: (
        /*deleteKey*/
        ctx[5]
      ),
      panActivationKey: (
        /*panActivationKey*/
        ctx[2]
      ),
      multiSelectionKey: (
        /*multiSelectionKey*/
        ctx[3]
      ),
      zoomActivationKey: (
        /*zoomActivationKey*/
        ctx[4]
      )
    },
    $$inline: true
  });
  zoom2 = new Zoom_default({
    props: {
      initialViewport: (
        /*initViewport*/
        ctx[31]
      ),
      onMoveStart: (
        /*onMoveStart*/
        ctx[8]
      ),
      onMove: (
        /*onMove*/
        ctx[9]
      ),
      onMoveEnd: (
        /*onMoveEnd*/
        ctx[10]
      ),
      panOnScrollMode: (
        /*panOnScrollMode*/
        ctx[11] === void 0 ? PanOnScrollMode.Free : (
          /*panOnScrollMode*/
          ctx[11]
        )
      ),
      preventScrolling: (
        /*preventScrolling*/
        ctx[12] === void 0 ? true : (
          /*preventScrolling*/
          ctx[12]
        )
      ),
      zoomOnScroll: (
        /*zoomOnScroll*/
        ctx[13] === void 0 ? true : (
          /*zoomOnScroll*/
          ctx[13]
        )
      ),
      zoomOnDoubleClick: (
        /*zoomOnDoubleClick*/
        ctx[14] === void 0 ? true : (
          /*zoomOnDoubleClick*/
          ctx[14]
        )
      ),
      zoomOnPinch: (
        /*zoomOnPinch*/
        ctx[15] === void 0 ? true : (
          /*zoomOnPinch*/
          ctx[15]
        )
      ),
      panOnScroll: (
        /*panOnScroll*/
        ctx[16] === void 0 ? false : (
          /*panOnScroll*/
          ctx[16]
        )
      ),
      panOnDrag: (
        /*panOnDrag*/
        ctx[17] === void 0 ? true : (
          /*panOnDrag*/
          ctx[17]
        )
      ),
      paneClickDistance: (
        /*paneClickDistance*/
        ctx[22] === void 0 ? 0 : (
          /*paneClickDistance*/
          ctx[22]
        )
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  attribution = new Attribution_default({
    props: {
      proOptions: (
        /*proOptions*/
        ctx[20]
      ),
      position: (
        /*attributionPosition*/
        ctx[19]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[75].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[99],
    null
  );
  let div_levels = [
    { style: (
      /*style*/
      ctx[24]
    ) },
    {
      class: div_class_value = cc([
        "svelte-flow",
        /*className*/
        ctx[25],
        /*$colorModeClass*/
        ctx[30]
      ])
    },
    { "data-testid": "svelte-flow__wrapper" },
    /*$$restProps*/
    ctx[33],
    { role: "application" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(keyhandler.$$.fragment);
      t0 = space();
      create_component(zoom2.$$.fragment);
      t1 = space();
      create_component(attribution.$$.fragment);
      t2 = space();
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        style: true,
        class: true,
        "data-testid": true,
        role: true
      });
      var div_nodes = children(div);
      claim_component(keyhandler.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(zoom2.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      claim_component(attribution.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[98].call(div)
      ));
      toggle_class(div, "svelte-12wlba6", true);
      add_location(div, file19, 179, 0, 5478);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(keyhandler, div, null);
      append_hydration_dev(div, t0);
      mount_component(zoom2, div, null);
      append_hydration_dev(div, t1);
      mount_component(attribution, div, null);
      append_hydration_dev(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[97](div);
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[98].bind(div)
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "dragover",
            /*dragover_handler*/
            ctx[76],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "drop",
            /*drop_handler*/
            ctx[77],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const keyhandler_changes = {};
      if (dirty[0] & /*selectionKey*/
      2) keyhandler_changes.selectionKey = /*selectionKey*/
      ctx2[1];
      if (dirty[0] & /*deleteKey*/
      32) keyhandler_changes.deleteKey = /*deleteKey*/
      ctx2[5];
      if (dirty[0] & /*panActivationKey*/
      4) keyhandler_changes.panActivationKey = /*panActivationKey*/
      ctx2[2];
      if (dirty[0] & /*multiSelectionKey*/
      8) keyhandler_changes.multiSelectionKey = /*multiSelectionKey*/
      ctx2[3];
      if (dirty[0] & /*zoomActivationKey*/
      16) keyhandler_changes.zoomActivationKey = /*zoomActivationKey*/
      ctx2[4];
      keyhandler.$set(keyhandler_changes);
      const zoom_changes = {};
      if (dirty[0] & /*onMoveStart*/
      256) zoom_changes.onMoveStart = /*onMoveStart*/
      ctx2[8];
      if (dirty[0] & /*onMove*/
      512) zoom_changes.onMove = /*onMove*/
      ctx2[9];
      if (dirty[0] & /*onMoveEnd*/
      1024) zoom_changes.onMoveEnd = /*onMoveEnd*/
      ctx2[10];
      if (dirty[0] & /*panOnScrollMode*/
      2048) zoom_changes.panOnScrollMode = /*panOnScrollMode*/
      ctx2[11] === void 0 ? PanOnScrollMode.Free : (
        /*panOnScrollMode*/
        ctx2[11]
      );
      if (dirty[0] & /*preventScrolling*/
      4096) zoom_changes.preventScrolling = /*preventScrolling*/
      ctx2[12] === void 0 ? true : (
        /*preventScrolling*/
        ctx2[12]
      );
      if (dirty[0] & /*zoomOnScroll*/
      8192) zoom_changes.zoomOnScroll = /*zoomOnScroll*/
      ctx2[13] === void 0 ? true : (
        /*zoomOnScroll*/
        ctx2[13]
      );
      if (dirty[0] & /*zoomOnDoubleClick*/
      16384) zoom_changes.zoomOnDoubleClick = /*zoomOnDoubleClick*/
      ctx2[14] === void 0 ? true : (
        /*zoomOnDoubleClick*/
        ctx2[14]
      );
      if (dirty[0] & /*zoomOnPinch*/
      32768) zoom_changes.zoomOnPinch = /*zoomOnPinch*/
      ctx2[15] === void 0 ? true : (
        /*zoomOnPinch*/
        ctx2[15]
      );
      if (dirty[0] & /*panOnScroll*/
      65536) zoom_changes.panOnScroll = /*panOnScroll*/
      ctx2[16] === void 0 ? false : (
        /*panOnScroll*/
        ctx2[16]
      );
      if (dirty[0] & /*panOnDrag*/
      131072) zoom_changes.panOnDrag = /*panOnDrag*/
      ctx2[17] === void 0 ? true : (
        /*panOnDrag*/
        ctx2[17]
      );
      if (dirty[0] & /*paneClickDistance*/
      4194304) zoom_changes.paneClickDistance = /*paneClickDistance*/
      ctx2[22] === void 0 ? 0 : (
        /*paneClickDistance*/
        ctx2[22]
      );
      if (dirty[0] & /*panOnDrag, selectionOnDrag, nodeClickDistance, connectionLineContainerStyle, connectionLineStyle, defaultEdgeOptions*/
      10879168 | dirty[1] & /*$$slots*/
      8 | dirty[3] & /*$$scope*/
      64) {
        zoom_changes.$$scope = { dirty, ctx: ctx2 };
      }
      zoom2.$set(zoom_changes);
      const attribution_changes = {};
      if (dirty[0] & /*proOptions*/
      1048576) attribution_changes.proOptions = /*proOptions*/
      ctx2[20];
      if (dirty[0] & /*attributionPosition*/
      524288) attribution_changes.position = /*attributionPosition*/
      ctx2[19];
      attribution.$set(attribution_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[3] & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[99],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[99]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[99],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*style*/
        16777216) && { style: (
          /*style*/
          ctx2[24]
        ) },
        (!current || dirty[0] & /*className, $colorModeClass*/
        1107296256 && div_class_value !== (div_class_value = cc([
          "svelte-flow",
          /*className*/
          ctx2[25],
          /*$colorModeClass*/
          ctx2[30]
        ]))) && { class: div_class_value },
        { "data-testid": "svelte-flow__wrapper" },
        dirty[1] & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[33],
        { role: "application" }
      ]));
      toggle_class(div, "svelte-12wlba6", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(keyhandler.$$.fragment, local);
      transition_in(zoom2.$$.fragment, local);
      transition_in(attribution.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(keyhandler.$$.fragment, local);
      transition_out(zoom2.$$.fragment, local);
      transition_out(attribution.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(keyhandler);
      destroy_component(zoom2);
      destroy_component(attribution);
      if (default_slot) default_slot.d(detaching);
      ctx[97](null);
      div_resize_listener();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let colorModeClass;
  const omit_props_names = [
    "id",
    "nodes",
    "edges",
    "fitView",
    "fitViewOptions",
    "minZoom",
    "maxZoom",
    "initialViewport",
    "viewport",
    "nodeTypes",
    "edgeTypes",
    "selectionKey",
    "selectionMode",
    "panActivationKey",
    "multiSelectionKey",
    "zoomActivationKey",
    "nodesDraggable",
    "nodesConnectable",
    "nodeDragThreshold",
    "elementsSelectable",
    "snapGrid",
    "deleteKey",
    "connectionRadius",
    "connectionLineType",
    "connectionMode",
    "connectionLineStyle",
    "connectionLineContainerStyle",
    "onMoveStart",
    "onMove",
    "onMoveEnd",
    "isValidConnection",
    "translateExtent",
    "nodeExtent",
    "onlyRenderVisibleElements",
    "panOnScrollMode",
    "preventScrolling",
    "zoomOnScroll",
    "zoomOnDoubleClick",
    "zoomOnPinch",
    "panOnScroll",
    "panOnDrag",
    "selectionOnDrag",
    "autoPanOnConnect",
    "autoPanOnNodeDrag",
    "onerror",
    "ondelete",
    "onedgecreate",
    "attributionPosition",
    "proOptions",
    "defaultEdgeOptions",
    "width",
    "height",
    "colorMode",
    "onconnect",
    "onconnectstart",
    "onconnectend",
    "onbeforedelete",
    "oninit",
    "nodeOrigin",
    "paneClickDistance",
    "nodeClickDistance",
    "defaultMarkerColor",
    "style",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $initialized;
  let $viewport, $$unsubscribe_viewport = noop, $$subscribe_viewport = () => ($$unsubscribe_viewport(), $$unsubscribe_viewport = subscribe(viewport, ($$value) => $$invalidate(100, $viewport = $$value)), viewport);
  let $colorModeClass, $$unsubscribe_colorModeClass = noop, $$subscribe_colorModeClass = () => ($$unsubscribe_colorModeClass(), $$unsubscribe_colorModeClass = subscribe(colorModeClass, ($$value) => $$invalidate(30, $colorModeClass = $$value)), colorModeClass);
  $$self.$$.on_destroy.push(() => $$unsubscribe_viewport());
  $$self.$$.on_destroy.push(() => $$unsubscribe_colorModeClass());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteFlow", slots, ["connectionLine", "default"]);
  const $$slots = compute_slots(slots);
  let { id = "1" } = $$props;
  let { nodes } = $$props;
  let { edges } = $$props;
  let { fitView: fitView2 = void 0 } = $$props;
  let { fitViewOptions = void 0 } = $$props;
  let { minZoom = void 0 } = $$props;
  let { maxZoom = void 0 } = $$props;
  let { initialViewport = void 0 } = $$props;
  let { viewport = void 0 } = $$props;
  validate_store(viewport, "viewport");
  $$subscribe_viewport();
  let { nodeTypes = void 0 } = $$props;
  let { edgeTypes = void 0 } = $$props;
  let { selectionKey = void 0 } = $$props;
  let { selectionMode = void 0 } = $$props;
  let { panActivationKey = void 0 } = $$props;
  let { multiSelectionKey = void 0 } = $$props;
  let { zoomActivationKey = void 0 } = $$props;
  let { nodesDraggable = void 0 } = $$props;
  let { nodesConnectable = void 0 } = $$props;
  let { nodeDragThreshold = void 0 } = $$props;
  let { elementsSelectable = void 0 } = $$props;
  let { snapGrid = void 0 } = $$props;
  let { deleteKey = void 0 } = $$props;
  let { connectionRadius = void 0 } = $$props;
  let { connectionLineType = void 0 } = $$props;
  let { connectionMode = ConnectionMode.Strict } = $$props;
  let { connectionLineStyle = "" } = $$props;
  let { connectionLineContainerStyle = "" } = $$props;
  let { onMoveStart = void 0 } = $$props;
  let { onMove = void 0 } = $$props;
  let { onMoveEnd = void 0 } = $$props;
  let { isValidConnection = void 0 } = $$props;
  let { translateExtent = void 0 } = $$props;
  let { nodeExtent = void 0 } = $$props;
  let { onlyRenderVisibleElements = void 0 } = $$props;
  let { panOnScrollMode = PanOnScrollMode.Free } = $$props;
  let { preventScrolling = true } = $$props;
  let { zoomOnScroll = true } = $$props;
  let { zoomOnDoubleClick = true } = $$props;
  let { zoomOnPinch = true } = $$props;
  let { panOnScroll = false } = $$props;
  let { panOnDrag = true } = $$props;
  let { selectionOnDrag = void 0 } = $$props;
  let { autoPanOnConnect = true } = $$props;
  let { autoPanOnNodeDrag = true } = $$props;
  let { onerror = void 0 } = $$props;
  let { ondelete = void 0 } = $$props;
  let { onedgecreate = void 0 } = $$props;
  let { attributionPosition = void 0 } = $$props;
  let { proOptions = void 0 } = $$props;
  let { defaultEdgeOptions = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { colorMode = "light" } = $$props;
  let { onconnect = void 0 } = $$props;
  let { onconnectstart = void 0 } = $$props;
  let { onconnectend = void 0 } = $$props;
  let { onbeforedelete = void 0 } = $$props;
  let { oninit = void 0 } = $$props;
  let { nodeOrigin = void 0 } = $$props;
  let { paneClickDistance = 0 } = $$props;
  let { nodeClickDistance = 0 } = $$props;
  let { defaultMarkerColor = "#b1b1b7" } = $$props;
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let domNode;
  let clientWidth;
  let clientHeight;
  const initViewport = $viewport || initialViewport;
  const store = hasContext(key) ? useStore() : createStoreContext({
    nodes: get_store_value(nodes),
    edges: get_store_value(edges),
    width,
    height,
    fitView: fitView2,
    nodeOrigin,
    nodeExtent
  });
  onMount(() => {
    store.width.set(clientWidth);
    store.height.set(clientHeight);
    store.domNode.set(domNode);
    store.syncNodeStores(nodes);
    store.syncEdgeStores(edges);
    store.syncViewport(viewport);
    if (fitView2 !== void 0) {
      store.fitViewOnInit.set(fitView2);
    }
    if (fitViewOptions) {
      store.fitViewOptions.set(fitViewOptions);
    }
    updateStore(store, {
      nodeTypes,
      edgeTypes,
      minZoom,
      maxZoom,
      translateExtent,
      paneClickDistance
    });
    return () => {
      store.reset();
    };
  });
  const { initialized } = store;
  validate_store(initialized, "initialized");
  component_subscribe($$self, initialized, (value) => $$invalidate(74, $initialized = value));
  let onInitCalled = false;
  $$self.$$.on_mount.push(function() {
    if (nodes === void 0 && !("nodes" in $$props || $$self.$$.bound[$$self.$$.props["nodes"]])) {
      console.warn("<SvelteFlow> was created without expected prop 'nodes'");
    }
    if (edges === void 0 && !("edges" in $$props || $$self.$$.bound[$$self.$$.props["edges"]])) {
      console.warn("<SvelteFlow> was created without expected prop 'edges'");
    }
  });
  function dragover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function drop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedrag_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function selectionclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function selectioncontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstart_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function nodedrag_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstop_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function paneclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function panecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      domNode = $$value;
      $$invalidate(28, domNode);
    });
  }
  function div_elementresize_handler() {
    clientWidth = this.clientWidth;
    clientHeight = this.clientHeight;
    $$invalidate(26, clientWidth);
    $$invalidate(27, clientHeight);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(35, id = $$new_props.id);
    if ("nodes" in $$new_props) $$invalidate(36, nodes = $$new_props.nodes);
    if ("edges" in $$new_props) $$invalidate(37, edges = $$new_props.edges);
    if ("fitView" in $$new_props) $$invalidate(38, fitView2 = $$new_props.fitView);
    if ("fitViewOptions" in $$new_props) $$invalidate(39, fitViewOptions = $$new_props.fitViewOptions);
    if ("minZoom" in $$new_props) $$invalidate(40, minZoom = $$new_props.minZoom);
    if ("maxZoom" in $$new_props) $$invalidate(41, maxZoom = $$new_props.maxZoom);
    if ("initialViewport" in $$new_props) $$invalidate(42, initialViewport = $$new_props.initialViewport);
    if ("viewport" in $$new_props) $$subscribe_viewport($$invalidate(0, viewport = $$new_props.viewport));
    if ("nodeTypes" in $$new_props) $$invalidate(43, nodeTypes = $$new_props.nodeTypes);
    if ("edgeTypes" in $$new_props) $$invalidate(44, edgeTypes = $$new_props.edgeTypes);
    if ("selectionKey" in $$new_props) $$invalidate(1, selectionKey = $$new_props.selectionKey);
    if ("selectionMode" in $$new_props) $$invalidate(45, selectionMode = $$new_props.selectionMode);
    if ("panActivationKey" in $$new_props) $$invalidate(2, panActivationKey = $$new_props.panActivationKey);
    if ("multiSelectionKey" in $$new_props) $$invalidate(3, multiSelectionKey = $$new_props.multiSelectionKey);
    if ("zoomActivationKey" in $$new_props) $$invalidate(4, zoomActivationKey = $$new_props.zoomActivationKey);
    if ("nodesDraggable" in $$new_props) $$invalidate(46, nodesDraggable = $$new_props.nodesDraggable);
    if ("nodesConnectable" in $$new_props) $$invalidate(47, nodesConnectable = $$new_props.nodesConnectable);
    if ("nodeDragThreshold" in $$new_props) $$invalidate(48, nodeDragThreshold = $$new_props.nodeDragThreshold);
    if ("elementsSelectable" in $$new_props) $$invalidate(49, elementsSelectable = $$new_props.elementsSelectable);
    if ("snapGrid" in $$new_props) $$invalidate(50, snapGrid = $$new_props.snapGrid);
    if ("deleteKey" in $$new_props) $$invalidate(5, deleteKey = $$new_props.deleteKey);
    if ("connectionRadius" in $$new_props) $$invalidate(51, connectionRadius = $$new_props.connectionRadius);
    if ("connectionLineType" in $$new_props) $$invalidate(52, connectionLineType = $$new_props.connectionLineType);
    if ("connectionMode" in $$new_props) $$invalidate(53, connectionMode = $$new_props.connectionMode);
    if ("connectionLineStyle" in $$new_props) $$invalidate(6, connectionLineStyle = $$new_props.connectionLineStyle);
    if ("connectionLineContainerStyle" in $$new_props) $$invalidate(7, connectionLineContainerStyle = $$new_props.connectionLineContainerStyle);
    if ("onMoveStart" in $$new_props) $$invalidate(8, onMoveStart = $$new_props.onMoveStart);
    if ("onMove" in $$new_props) $$invalidate(9, onMove = $$new_props.onMove);
    if ("onMoveEnd" in $$new_props) $$invalidate(10, onMoveEnd = $$new_props.onMoveEnd);
    if ("isValidConnection" in $$new_props) $$invalidate(54, isValidConnection = $$new_props.isValidConnection);
    if ("translateExtent" in $$new_props) $$invalidate(55, translateExtent = $$new_props.translateExtent);
    if ("nodeExtent" in $$new_props) $$invalidate(56, nodeExtent = $$new_props.nodeExtent);
    if ("onlyRenderVisibleElements" in $$new_props) $$invalidate(57, onlyRenderVisibleElements = $$new_props.onlyRenderVisibleElements);
    if ("panOnScrollMode" in $$new_props) $$invalidate(11, panOnScrollMode = $$new_props.panOnScrollMode);
    if ("preventScrolling" in $$new_props) $$invalidate(12, preventScrolling = $$new_props.preventScrolling);
    if ("zoomOnScroll" in $$new_props) $$invalidate(13, zoomOnScroll = $$new_props.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$new_props) $$invalidate(14, zoomOnDoubleClick = $$new_props.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$new_props) $$invalidate(15, zoomOnPinch = $$new_props.zoomOnPinch);
    if ("panOnScroll" in $$new_props) $$invalidate(16, panOnScroll = $$new_props.panOnScroll);
    if ("panOnDrag" in $$new_props) $$invalidate(17, panOnDrag = $$new_props.panOnDrag);
    if ("selectionOnDrag" in $$new_props) $$invalidate(18, selectionOnDrag = $$new_props.selectionOnDrag);
    if ("autoPanOnConnect" in $$new_props) $$invalidate(58, autoPanOnConnect = $$new_props.autoPanOnConnect);
    if ("autoPanOnNodeDrag" in $$new_props) $$invalidate(59, autoPanOnNodeDrag = $$new_props.autoPanOnNodeDrag);
    if ("onerror" in $$new_props) $$invalidate(60, onerror = $$new_props.onerror);
    if ("ondelete" in $$new_props) $$invalidate(61, ondelete = $$new_props.ondelete);
    if ("onedgecreate" in $$new_props) $$invalidate(62, onedgecreate = $$new_props.onedgecreate);
    if ("attributionPosition" in $$new_props) $$invalidate(19, attributionPosition = $$new_props.attributionPosition);
    if ("proOptions" in $$new_props) $$invalidate(20, proOptions = $$new_props.proOptions);
    if ("defaultEdgeOptions" in $$new_props) $$invalidate(21, defaultEdgeOptions = $$new_props.defaultEdgeOptions);
    if ("width" in $$new_props) $$invalidate(63, width = $$new_props.width);
    if ("height" in $$new_props) $$invalidate(64, height = $$new_props.height);
    if ("colorMode" in $$new_props) $$invalidate(65, colorMode = $$new_props.colorMode);
    if ("onconnect" in $$new_props) $$invalidate(66, onconnect = $$new_props.onconnect);
    if ("onconnectstart" in $$new_props) $$invalidate(67, onconnectstart = $$new_props.onconnectstart);
    if ("onconnectend" in $$new_props) $$invalidate(68, onconnectend = $$new_props.onconnectend);
    if ("onbeforedelete" in $$new_props) $$invalidate(69, onbeforedelete = $$new_props.onbeforedelete);
    if ("oninit" in $$new_props) $$invalidate(70, oninit = $$new_props.oninit);
    if ("nodeOrigin" in $$new_props) $$invalidate(71, nodeOrigin = $$new_props.nodeOrigin);
    if ("paneClickDistance" in $$new_props) $$invalidate(22, paneClickDistance = $$new_props.paneClickDistance);
    if ("nodeClickDistance" in $$new_props) $$invalidate(23, nodeClickDistance = $$new_props.nodeClickDistance);
    if ("defaultMarkerColor" in $$new_props) $$invalidate(72, defaultMarkerColor = $$new_props.defaultMarkerColor);
    if ("style" in $$new_props) $$invalidate(24, style = $$new_props.style);
    if ("class" in $$new_props) $$invalidate(25, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(99, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    hasContext,
    get: get_store_value,
    cc,
    ConnectionMode,
    PanOnScrollMode,
    Zoom: Zoom_default,
    Pane: Pane_default,
    ViewportComponent: Viewport_default,
    NodeRenderer: NodeRenderer_default,
    EdgeRenderer: EdgeRenderer_default,
    UserSelection: UserSelection_default,
    NodeSelection: NodeSelection_default,
    KeyHandler: KeyHandler_default,
    ConnectionLine: ConnectionLine_default,
    Attribution: Attribution_default,
    key,
    useStore,
    createStoreContext,
    updateStore,
    updateStoreByKeys,
    useColorModeClass,
    id,
    nodes,
    edges,
    fitView: fitView2,
    fitViewOptions,
    minZoom,
    maxZoom,
    initialViewport,
    viewport,
    nodeTypes,
    edgeTypes,
    selectionKey,
    selectionMode,
    panActivationKey,
    multiSelectionKey,
    zoomActivationKey,
    nodesDraggable,
    nodesConnectable,
    nodeDragThreshold,
    elementsSelectable,
    snapGrid,
    deleteKey,
    connectionRadius,
    connectionLineType,
    connectionMode,
    connectionLineStyle,
    connectionLineContainerStyle,
    onMoveStart,
    onMove,
    onMoveEnd,
    isValidConnection,
    translateExtent,
    nodeExtent,
    onlyRenderVisibleElements,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    panOnScroll,
    panOnDrag,
    selectionOnDrag,
    autoPanOnConnect,
    autoPanOnNodeDrag,
    onerror,
    ondelete,
    onedgecreate,
    attributionPosition,
    proOptions,
    defaultEdgeOptions,
    width,
    height,
    colorMode,
    onconnect,
    onconnectstart,
    onconnectend,
    onbeforedelete,
    oninit,
    nodeOrigin,
    paneClickDistance,
    nodeClickDistance,
    defaultMarkerColor,
    style,
    className,
    domNode,
    clientWidth,
    clientHeight,
    initViewport,
    store,
    initialized,
    onInitCalled,
    colorModeClass,
    $initialized,
    $viewport,
    $colorModeClass
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(35, id = $$new_props.id);
    if ("nodes" in $$props) $$invalidate(36, nodes = $$new_props.nodes);
    if ("edges" in $$props) $$invalidate(37, edges = $$new_props.edges);
    if ("fitView" in $$props) $$invalidate(38, fitView2 = $$new_props.fitView);
    if ("fitViewOptions" in $$props) $$invalidate(39, fitViewOptions = $$new_props.fitViewOptions);
    if ("minZoom" in $$props) $$invalidate(40, minZoom = $$new_props.minZoom);
    if ("maxZoom" in $$props) $$invalidate(41, maxZoom = $$new_props.maxZoom);
    if ("initialViewport" in $$props) $$invalidate(42, initialViewport = $$new_props.initialViewport);
    if ("viewport" in $$props) $$subscribe_viewport($$invalidate(0, viewport = $$new_props.viewport));
    if ("nodeTypes" in $$props) $$invalidate(43, nodeTypes = $$new_props.nodeTypes);
    if ("edgeTypes" in $$props) $$invalidate(44, edgeTypes = $$new_props.edgeTypes);
    if ("selectionKey" in $$props) $$invalidate(1, selectionKey = $$new_props.selectionKey);
    if ("selectionMode" in $$props) $$invalidate(45, selectionMode = $$new_props.selectionMode);
    if ("panActivationKey" in $$props) $$invalidate(2, panActivationKey = $$new_props.panActivationKey);
    if ("multiSelectionKey" in $$props) $$invalidate(3, multiSelectionKey = $$new_props.multiSelectionKey);
    if ("zoomActivationKey" in $$props) $$invalidate(4, zoomActivationKey = $$new_props.zoomActivationKey);
    if ("nodesDraggable" in $$props) $$invalidate(46, nodesDraggable = $$new_props.nodesDraggable);
    if ("nodesConnectable" in $$props) $$invalidate(47, nodesConnectable = $$new_props.nodesConnectable);
    if ("nodeDragThreshold" in $$props) $$invalidate(48, nodeDragThreshold = $$new_props.nodeDragThreshold);
    if ("elementsSelectable" in $$props) $$invalidate(49, elementsSelectable = $$new_props.elementsSelectable);
    if ("snapGrid" in $$props) $$invalidate(50, snapGrid = $$new_props.snapGrid);
    if ("deleteKey" in $$props) $$invalidate(5, deleteKey = $$new_props.deleteKey);
    if ("connectionRadius" in $$props) $$invalidate(51, connectionRadius = $$new_props.connectionRadius);
    if ("connectionLineType" in $$props) $$invalidate(52, connectionLineType = $$new_props.connectionLineType);
    if ("connectionMode" in $$props) $$invalidate(53, connectionMode = $$new_props.connectionMode);
    if ("connectionLineStyle" in $$props) $$invalidate(6, connectionLineStyle = $$new_props.connectionLineStyle);
    if ("connectionLineContainerStyle" in $$props) $$invalidate(7, connectionLineContainerStyle = $$new_props.connectionLineContainerStyle);
    if ("onMoveStart" in $$props) $$invalidate(8, onMoveStart = $$new_props.onMoveStart);
    if ("onMove" in $$props) $$invalidate(9, onMove = $$new_props.onMove);
    if ("onMoveEnd" in $$props) $$invalidate(10, onMoveEnd = $$new_props.onMoveEnd);
    if ("isValidConnection" in $$props) $$invalidate(54, isValidConnection = $$new_props.isValidConnection);
    if ("translateExtent" in $$props) $$invalidate(55, translateExtent = $$new_props.translateExtent);
    if ("nodeExtent" in $$props) $$invalidate(56, nodeExtent = $$new_props.nodeExtent);
    if ("onlyRenderVisibleElements" in $$props) $$invalidate(57, onlyRenderVisibleElements = $$new_props.onlyRenderVisibleElements);
    if ("panOnScrollMode" in $$props) $$invalidate(11, panOnScrollMode = $$new_props.panOnScrollMode);
    if ("preventScrolling" in $$props) $$invalidate(12, preventScrolling = $$new_props.preventScrolling);
    if ("zoomOnScroll" in $$props) $$invalidate(13, zoomOnScroll = $$new_props.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$props) $$invalidate(14, zoomOnDoubleClick = $$new_props.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$props) $$invalidate(15, zoomOnPinch = $$new_props.zoomOnPinch);
    if ("panOnScroll" in $$props) $$invalidate(16, panOnScroll = $$new_props.panOnScroll);
    if ("panOnDrag" in $$props) $$invalidate(17, panOnDrag = $$new_props.panOnDrag);
    if ("selectionOnDrag" in $$props) $$invalidate(18, selectionOnDrag = $$new_props.selectionOnDrag);
    if ("autoPanOnConnect" in $$props) $$invalidate(58, autoPanOnConnect = $$new_props.autoPanOnConnect);
    if ("autoPanOnNodeDrag" in $$props) $$invalidate(59, autoPanOnNodeDrag = $$new_props.autoPanOnNodeDrag);
    if ("onerror" in $$props) $$invalidate(60, onerror = $$new_props.onerror);
    if ("ondelete" in $$props) $$invalidate(61, ondelete = $$new_props.ondelete);
    if ("onedgecreate" in $$props) $$invalidate(62, onedgecreate = $$new_props.onedgecreate);
    if ("attributionPosition" in $$props) $$invalidate(19, attributionPosition = $$new_props.attributionPosition);
    if ("proOptions" in $$props) $$invalidate(20, proOptions = $$new_props.proOptions);
    if ("defaultEdgeOptions" in $$props) $$invalidate(21, defaultEdgeOptions = $$new_props.defaultEdgeOptions);
    if ("width" in $$props) $$invalidate(63, width = $$new_props.width);
    if ("height" in $$props) $$invalidate(64, height = $$new_props.height);
    if ("colorMode" in $$props) $$invalidate(65, colorMode = $$new_props.colorMode);
    if ("onconnect" in $$props) $$invalidate(66, onconnect = $$new_props.onconnect);
    if ("onconnectstart" in $$props) $$invalidate(67, onconnectstart = $$new_props.onconnectstart);
    if ("onconnectend" in $$props) $$invalidate(68, onconnectend = $$new_props.onconnectend);
    if ("onbeforedelete" in $$props) $$invalidate(69, onbeforedelete = $$new_props.onbeforedelete);
    if ("oninit" in $$props) $$invalidate(70, oninit = $$new_props.oninit);
    if ("nodeOrigin" in $$props) $$invalidate(71, nodeOrigin = $$new_props.nodeOrigin);
    if ("paneClickDistance" in $$props) $$invalidate(22, paneClickDistance = $$new_props.paneClickDistance);
    if ("nodeClickDistance" in $$props) $$invalidate(23, nodeClickDistance = $$new_props.nodeClickDistance);
    if ("defaultMarkerColor" in $$props) $$invalidate(72, defaultMarkerColor = $$new_props.defaultMarkerColor);
    if ("style" in $$props) $$invalidate(24, style = $$new_props.style);
    if ("className" in $$props) $$invalidate(25, className = $$new_props.className);
    if ("domNode" in $$props) $$invalidate(28, domNode = $$new_props.domNode);
    if ("clientWidth" in $$props) $$invalidate(26, clientWidth = $$new_props.clientWidth);
    if ("clientHeight" in $$props) $$invalidate(27, clientHeight = $$new_props.clientHeight);
    if ("onInitCalled" in $$props) $$invalidate(73, onInitCalled = $$new_props.onInitCalled);
    if ("colorModeClass" in $$props) $$subscribe_colorModeClass($$invalidate(29, colorModeClass = $$new_props.colorModeClass));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*clientWidth, clientHeight*/
    201326592) {
      $: {
        if (clientWidth !== void 0 && clientHeight !== void 0) {
          store.width.set(clientWidth);
          store.height.set(clientHeight);
        }
      }
    }
    if ($$self.$$.dirty[2] & /*onInitCalled, $initialized, oninit*/
    6400) {
      $: {
        if (!onInitCalled && $initialized) {
          oninit == null ? void 0 : oninit();
          $$invalidate(73, onInitCalled = true);
        }
      }
    }
    if ($$self.$$.dirty[1] & /*id, connectionLineType, connectionRadius, selectionMode, snapGrid, nodesDraggable, nodesConnectable, elementsSelectable, onlyRenderVisibleElements, isValidConnection, autoPanOnConnect, autoPanOnNodeDrag, onerror, ondelete, connectionMode, nodeDragThreshold*/
    2097135632 | $$self.$$.dirty[2] & /*defaultMarkerColor, onedgecreate, onconnect, onconnectstart, onconnectend, onbeforedelete, nodeOrigin*/
    1777) {
      $: {
        const updatableProps = {
          flowId: id,
          connectionLineType,
          connectionRadius,
          selectionMode,
          snapGrid,
          defaultMarkerColor,
          nodesDraggable,
          nodesConnectable,
          elementsSelectable,
          onlyRenderVisibleElements,
          isValidConnection,
          autoPanOnConnect,
          autoPanOnNodeDrag,
          onerror,
          ondelete,
          onedgecreate,
          connectionMode,
          nodeDragThreshold,
          onconnect,
          onconnectstart,
          onconnectend,
          onbeforedelete,
          nodeOrigin
        };
        updateStoreByKeys(store, updatableProps);
      }
    }
    if ($$self.$$.dirty[0] & /*paneClickDistance*/
    4194304 | $$self.$$.dirty[1] & /*nodeTypes, edgeTypes, minZoom, maxZoom, translateExtent*/
    16791040) {
      $: updateStore(store, {
        nodeTypes,
        edgeTypes,
        minZoom,
        maxZoom,
        translateExtent,
        paneClickDistance
      });
    }
    if ($$self.$$.dirty[2] & /*colorMode*/
    8) {
      $: $$subscribe_colorModeClass($$invalidate(29, colorModeClass = useColorModeClass(colorMode)));
    }
  };
  return [
    viewport,
    selectionKey,
    panActivationKey,
    multiSelectionKey,
    zoomActivationKey,
    deleteKey,
    connectionLineStyle,
    connectionLineContainerStyle,
    onMoveStart,
    onMove,
    onMoveEnd,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    panOnScroll,
    panOnDrag,
    selectionOnDrag,
    attributionPosition,
    proOptions,
    defaultEdgeOptions,
    paneClickDistance,
    nodeClickDistance,
    style,
    className,
    clientWidth,
    clientHeight,
    domNode,
    colorModeClass,
    $colorModeClass,
    initViewport,
    initialized,
    $$restProps,
    $$slots,
    id,
    nodes,
    edges,
    fitView2,
    fitViewOptions,
    minZoom,
    maxZoom,
    initialViewport,
    nodeTypes,
    edgeTypes,
    selectionMode,
    nodesDraggable,
    nodesConnectable,
    nodeDragThreshold,
    elementsSelectable,
    snapGrid,
    connectionRadius,
    connectionLineType,
    connectionMode,
    isValidConnection,
    translateExtent,
    nodeExtent,
    onlyRenderVisibleElements,
    autoPanOnConnect,
    autoPanOnNodeDrag,
    onerror,
    ondelete,
    onedgecreate,
    width,
    height,
    colorMode,
    onconnect,
    onconnectstart,
    onconnectend,
    onbeforedelete,
    oninit,
    nodeOrigin,
    defaultMarkerColor,
    onInitCalled,
    $initialized,
    slots,
    dragover_handler,
    drop_handler,
    edgeclick_handler,
    edgecontextmenu_handler,
    edgemouseenter_handler,
    edgemouseleave_handler,
    nodeclick_handler,
    nodemouseenter_handler,
    nodemousemove_handler,
    nodemouseleave_handler,
    nodedragstart_handler,
    nodedrag_handler,
    nodedragstop_handler,
    nodecontextmenu_handler,
    selectionclick_handler,
    selectioncontextmenu_handler,
    nodedragstart_handler_1,
    nodedrag_handler_1,
    nodedragstop_handler_1,
    paneclick_handler,
    panecontextmenu_handler,
    div_binding,
    div_elementresize_handler,
    $$scope
  ];
}
var SvelteFlow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance34,
      create_fragment34,
      safe_not_equal,
      {
        id: 35,
        nodes: 36,
        edges: 37,
        fitView: 38,
        fitViewOptions: 39,
        minZoom: 40,
        maxZoom: 41,
        initialViewport: 42,
        viewport: 0,
        nodeTypes: 43,
        edgeTypes: 44,
        selectionKey: 1,
        selectionMode: 45,
        panActivationKey: 2,
        multiSelectionKey: 3,
        zoomActivationKey: 4,
        nodesDraggable: 46,
        nodesConnectable: 47,
        nodeDragThreshold: 48,
        elementsSelectable: 49,
        snapGrid: 50,
        deleteKey: 5,
        connectionRadius: 51,
        connectionLineType: 52,
        connectionMode: 53,
        connectionLineStyle: 6,
        connectionLineContainerStyle: 7,
        onMoveStart: 8,
        onMove: 9,
        onMoveEnd: 10,
        isValidConnection: 54,
        translateExtent: 55,
        nodeExtent: 56,
        onlyRenderVisibleElements: 57,
        panOnScrollMode: 11,
        preventScrolling: 12,
        zoomOnScroll: 13,
        zoomOnDoubleClick: 14,
        zoomOnPinch: 15,
        panOnScroll: 16,
        panOnDrag: 17,
        selectionOnDrag: 18,
        autoPanOnConnect: 58,
        autoPanOnNodeDrag: 59,
        onerror: 60,
        ondelete: 61,
        onedgecreate: 62,
        attributionPosition: 19,
        proOptions: 20,
        defaultEdgeOptions: 21,
        width: 63,
        height: 64,
        colorMode: 65,
        onconnect: 66,
        onconnectstart: 67,
        onconnectend: 68,
        onbeforedelete: 69,
        oninit: 70,
        nodeOrigin: 71,
        paneClickDistance: 22,
        nodeClickDistance: 23,
        defaultMarkerColor: 72,
        style: 24,
        class: 25
      },
      add_css7,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteFlow",
      options,
      id: create_fragment34.name
    });
  }
  get id() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodes() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get edges() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edges(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitView() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitView(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitViewOptions() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitViewOptions(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minZoom() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minZoom(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxZoom() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxZoom(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialViewport() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialViewport(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewport() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewport(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeTypes() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeTypes(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get edgeTypes() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edgeTypes(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panActivationKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panActivationKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiSelectionKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiSelectionKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomActivationKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomActivationKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodesDraggable() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodesDraggable(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodesConnectable() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodesConnectable(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeDragThreshold() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeDragThreshold(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get elementsSelectable() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elementsSelectable(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get snapGrid() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set snapGrid(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionRadius() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionRadius(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionLineType() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionLineType(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionLineStyle() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionLineStyle(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionLineContainerStyle() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionLineContainerStyle(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveStart() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveStart(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMove() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMove(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveEnd() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveEnd(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isValidConnection() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isValidConnection(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateExtent() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateExtent(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeExtent() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeExtent(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onlyRenderVisibleElements() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onlyRenderVisibleElements(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScrollMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScrollMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScrolling() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScrolling(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnScroll() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnScroll(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnDoubleClick() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnDoubleClick(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnPinch() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnPinch(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScroll() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScroll(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnDrag() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnDrag(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionOnDrag() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionOnDrag(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoPanOnConnect() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPanOnConnect(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoPanOnNodeDrag() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPanOnNodeDrag(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onerror() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onerror(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ondelete() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ondelete(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onedgecreate() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onedgecreate(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attributionPosition() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attributionPosition(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get proOptions() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set proOptions(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultEdgeOptions() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultEdgeOptions(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onconnect() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onconnect(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onconnectstart() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onconnectstart(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onconnectend() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onconnectend(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onbeforedelete() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onbeforedelete(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get oninit() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set oninit(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeOrigin() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeOrigin(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paneClickDistance() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paneClickDistance(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeClickDistance() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeClickDistance(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultMarkerColor() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultMarkerColor(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteFlow_default = SvelteFlow;

// node_modules/@xyflow/svelte/dist/lib/components/SvelteFlowProvider/SvelteFlowProvider.svelte
function create_fragment35(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteFlowProvider", slots, ["default"]);
  let { initialNodes = void 0 } = $$props;
  let { initialEdges = void 0 } = $$props;
  let { initialWidth = void 0 } = $$props;
  let { initialHeight = void 0 } = $$props;
  let { fitView: fitView2 = void 0 } = $$props;
  let { nodeOrigin = void 0 } = $$props;
  const store = createStore({
    nodes: initialNodes,
    edges: initialEdges,
    width: initialWidth,
    height: initialHeight,
    nodeOrigin,
    fitView: fitView2
  });
  setContext(key, { getStore: () => store });
  onDestroy(() => {
    store.reset();
  });
  const writable_props = [
    "initialNodes",
    "initialEdges",
    "initialWidth",
    "initialHeight",
    "fitView",
    "nodeOrigin"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<SvelteFlowProvider> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("initialNodes" in $$props2) $$invalidate(0, initialNodes = $$props2.initialNodes);
    if ("initialEdges" in $$props2) $$invalidate(1, initialEdges = $$props2.initialEdges);
    if ("initialWidth" in $$props2) $$invalidate(2, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2) $$invalidate(3, initialHeight = $$props2.initialHeight);
    if ("fitView" in $$props2) $$invalidate(4, fitView2 = $$props2.fitView);
    if ("nodeOrigin" in $$props2) $$invalidate(5, nodeOrigin = $$props2.nodeOrigin);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    setContext,
    createStore,
    key,
    initialNodes,
    initialEdges,
    initialWidth,
    initialHeight,
    fitView: fitView2,
    nodeOrigin,
    store
  });
  $$self.$inject_state = ($$props2) => {
    if ("initialNodes" in $$props2) $$invalidate(0, initialNodes = $$props2.initialNodes);
    if ("initialEdges" in $$props2) $$invalidate(1, initialEdges = $$props2.initialEdges);
    if ("initialWidth" in $$props2) $$invalidate(2, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2) $$invalidate(3, initialHeight = $$props2.initialHeight);
    if ("fitView" in $$props2) $$invalidate(4, fitView2 = $$props2.fitView);
    if ("nodeOrigin" in $$props2) $$invalidate(5, nodeOrigin = $$props2.nodeOrigin);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    initialNodes,
    initialEdges,
    initialWidth,
    initialHeight,
    fitView2,
    nodeOrigin,
    $$scope,
    slots
  ];
}
var SvelteFlowProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      initialNodes: 0,
      initialEdges: 1,
      initialWidth: 2,
      initialHeight: 3,
      fitView: 4,
      nodeOrigin: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteFlowProvider",
      options,
      id: create_fragment35.name
    });
  }
  get initialNodes() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialNodes(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialEdges() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialEdges(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialWidth() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialWidth(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialHeight() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialHeight(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitView() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitView(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeOrigin() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeOrigin(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteFlowProvider_default = SvelteFlowProvider;

// node_modules/@xyflow/svelte/dist/lib/components/ViewportPortal/ViewportPortal.svelte
var file20 = "node_modules\\@xyflow\\svelte\\dist\\lib\\components\\ViewportPortal\\ViewportPortal.svelte";
function create_fragment36(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file20, 5, 0, 134);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal_default.call(null, div, {
          target: ".svelte-flow__viewport-portal",
          domNode: (
            /*$domNode*/
            ctx[0]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*$domNode*/
      1) portal_action.update.call(null, {
        target: ".svelte-flow__viewport-portal",
        domNode: (
          /*$domNode*/
          ctx2[0]
        )
      });
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let $domNode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ViewportPortal", slots, ["default"]);
  const { domNode } = useStore();
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(0, $domNode = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<ViewportPortal> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ portal: portal_default, useStore, domNode, $domNode });
  return [$domNode, domNode, $$scope, slots];
}
var ViewportPortal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ViewportPortal",
      options,
      id: create_fragment36.name
    });
  }
};
var ViewportPortal_default = ViewportPortal;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte
var file21 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Controls\\ControlButton.svelte";
var get_default_slot_changes = (dirty) => ({});
var get_default_slot_context = (ctx) => ({ class: "button-svg" });
function create_fragment37(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context
  );
  let button_levels = [
    { type: "button" },
    {
      class: button_class_value = cc([
        "svelte-flow__controls-button",
        /*className*/
        ctx[0]
      ])
    },
    /*$$restProps*/
    ctx[6]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      set_style(
        button,
        "--xy-controls-button-background-color-props",
        /*bgColor*/
        ctx[1]
      );
      set_style(
        button,
        "--xy-controls-button-background-color-hover-props",
        /*bgColorHover*/
        ctx[2]
      );
      set_style(
        button,
        "--xy-controls-button-color-props",
        /*color*/
        ctx[3]
      );
      set_style(
        button,
        "--xy-controls-button-color-hover-props",
        /*colorHover*/
        ctx[4]
      );
      set_style(
        button,
        "--xy-controls-button-border-color-props",
        /*borderColor*/
        ctx[5]
      );
      add_location(button, file21, 10, 0, 239);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[9],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*className*/
        1 && button_class_value !== (button_class_value = cc([
          "svelte-flow__controls-button",
          /*className*/
          ctx2[0]
        ]))) && { class: button_class_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      set_style(
        button,
        "--xy-controls-button-background-color-props",
        /*bgColor*/
        ctx2[1]
      );
      set_style(
        button,
        "--xy-controls-button-background-color-hover-props",
        /*bgColorHover*/
        ctx2[2]
      );
      set_style(
        button,
        "--xy-controls-button-color-props",
        /*color*/
        ctx2[3]
      );
      set_style(
        button,
        "--xy-controls-button-color-hover-props",
        /*colorHover*/
        ctx2[4]
      );
      set_style(
        button,
        "--xy-controls-button-border-color-props",
        /*borderColor*/
        ctx2[5]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ControlButton", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let bgColor = void 0;
  let bgColorHover = void 0;
  let color = void 0;
  let colorHover = void 0;
  let borderColor = void 0;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    className,
    bgColor,
    bgColorHover,
    color,
    colorHover,
    borderColor
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    if ("bgColor" in $$props) $$invalidate(1, bgColor = $$new_props.bgColor);
    if ("bgColorHover" in $$props) $$invalidate(2, bgColorHover = $$new_props.bgColorHover);
    if ("color" in $$props) $$invalidate(3, color = $$new_props.color);
    if ("colorHover" in $$props) $$invalidate(4, colorHover = $$new_props.colorHover);
    if ("borderColor" in $$props) $$invalidate(5, borderColor = $$new_props.borderColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    bgColor,
    bgColorHover,
    color,
    colorHover,
    borderColor,
    $$restProps,
    $$scope,
    slots,
    click_handler
  ];
}
var ControlButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { class: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ControlButton",
      options,
      id: create_fragment37.name
    });
  }
  get class() {
    throw new Error("<ControlButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ControlButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ControlButton_default = ControlButton;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte
var file22 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Controls\\Icons\\Plus.svelte";
function create_fragment38(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z");
      add_location(path, file22, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 32 32");
      add_location(svg, file22, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Plus", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Plus> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Plus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Plus",
      options,
      id: create_fragment38.name
    });
  }
};
var Plus_default = Plus;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte
var file23 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Controls\\Icons\\Minus.svelte";
function create_fragment39(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M0 0h32v4.2H0z");
      add_location(path, file23, 1, 2, 62);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 32 5");
      add_location(svg, file23, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Minus", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Minus> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Minus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minus",
      options,
      id: create_fragment39.name
    });
  }
};
var Minus_default = Minus;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte
var file24 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Controls\\Icons\\Fit.svelte";
function create_fragment40(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z");
      add_location(path, file24, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 32 30");
      add_location(svg, file24, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fit", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Fit> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Fit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fit",
      options,
      id: create_fragment40.name
    });
  }
};
var Fit_default = Fit;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte
var file25 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Controls\\Icons\\Lock.svelte";
function create_fragment41(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z");
      add_location(path, file25, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 25 32");
      add_location(svg, file25, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Lock", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Lock> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Lock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Lock",
      options,
      id: create_fragment41.name
    });
  }
};
var Lock_default = Lock;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte
var file26 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Controls\\Icons\\Unlock.svelte";
function create_fragment42(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z");
      add_location(path, file26, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 25 32");
      add_location(svg, file26, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Unlock", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Unlock> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Unlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Unlock",
      options,
      id: create_fragment42.name
    });
  }
};
var Unlock_default = Unlock;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Controls.svelte
var get_after_slot_changes = (dirty) => ({});
var get_after_slot_context = (ctx) => ({});
var get_before_slot_changes = (dirty) => ({});
var get_before_slot_context = (ctx) => ({});
function create_if_block_3(ctx) {
  let controlbutton0;
  let t;
  let controlbutton1;
  let current;
  const controlbutton0_spread_levels = [
    { class: "svelte-flow__controls-zoomin" },
    { title: "zoom in" },
    { "aria-label": "zoom in" },
    { disabled: (
      /*maxZoomReached*/
      ctx[9]
    ) },
    /*buttonProps*/
    ctx[17]
  ];
  let controlbutton0_props = {
    $$slots: { default: [create_default_slot_4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton0_spread_levels.length; i += 1) {
    controlbutton0_props = assign(controlbutton0_props, controlbutton0_spread_levels[i]);
  }
  controlbutton0 = new ControlButton_default({
    props: controlbutton0_props,
    $$inline: true
  });
  controlbutton0.$on(
    "click",
    /*onZoomInHandler*/
    ctx[18]
  );
  const controlbutton1_spread_levels = [
    { class: "svelte-flow__controls-zoomout" },
    { title: "zoom out" },
    { "aria-label": "zoom out" },
    { disabled: (
      /*minZoomReached*/
      ctx[10]
    ) },
    /*buttonProps*/
    ctx[17]
  ];
  let controlbutton1_props = {
    $$slots: { default: [create_default_slot_3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton1_spread_levels.length; i += 1) {
    controlbutton1_props = assign(controlbutton1_props, controlbutton1_spread_levels[i]);
  }
  controlbutton1 = new ControlButton_default({
    props: controlbutton1_props,
    $$inline: true
  });
  controlbutton1.$on(
    "click",
    /*onZoomOutHandler*/
    ctx[19]
  );
  const block = {
    c: function create() {
      create_component(controlbutton0.$$.fragment);
      t = space();
      create_component(controlbutton1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(controlbutton0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(controlbutton1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(controlbutton0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(controlbutton1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const controlbutton0_changes = dirty[0] & /*maxZoomReached, buttonProps*/
      131584 ? get_spread_update(controlbutton0_spread_levels, [
        controlbutton0_spread_levels[0],
        controlbutton0_spread_levels[1],
        controlbutton0_spread_levels[2],
        dirty[0] & /*maxZoomReached*/
        512 && { disabled: (
          /*maxZoomReached*/
          ctx2[9]
        ) },
        dirty[0] & /*buttonProps*/
        131072 && get_spread_object(
          /*buttonProps*/
          ctx2[17]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      32) {
        controlbutton0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton0.$set(controlbutton0_changes);
      const controlbutton1_changes = dirty[0] & /*minZoomReached, buttonProps*/
      132096 ? get_spread_update(controlbutton1_spread_levels, [
        controlbutton1_spread_levels[0],
        controlbutton1_spread_levels[1],
        controlbutton1_spread_levels[2],
        dirty[0] & /*minZoomReached*/
        1024 && { disabled: (
          /*minZoomReached*/
          ctx2[10]
        ) },
        dirty[0] & /*buttonProps*/
        131072 && get_spread_object(
          /*buttonProps*/
          ctx2[17]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      32) {
        controlbutton1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton1.$set(controlbutton1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(controlbutton0.$$.fragment, local);
      transition_in(controlbutton1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(controlbutton0.$$.fragment, local);
      transition_out(controlbutton1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(controlbutton0, detaching);
      destroy_component(controlbutton1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(62:2) {#if showZoom}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let plusicon;
  let current;
  plusicon = new Plus_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(plusicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(plusicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(plusicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(plusicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(plusicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(plusicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: '(63:4) <ControlButton       on:click={onZoomInHandler}       class=\\"svelte-flow__controls-zoomin\\"       title=\\"zoom in\\"       aria-label=\\"zoom in\\"       disabled={maxZoomReached}       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let minusicon;
  let current;
  minusicon = new Minus_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(minusicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(minusicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(minusicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(minusicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(minusicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(minusicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(73:4) <ControlButton       on:click={onZoomOutHandler}       class=\\"svelte-flow__controls-zoomout\\"       title=\\"zoom out\\"       aria-label=\\"zoom out\\"       disabled={minZoomReached}       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let controlbutton;
  let current;
  const controlbutton_spread_levels = [
    { class: "svelte-flow__controls-fitview" },
    { title: "fit view" },
    { "aria-label": "fit view" },
    /*buttonProps*/
    ctx[17]
  ];
  let controlbutton_props = {
    $$slots: { default: [create_default_slot_22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton_spread_levels.length; i += 1) {
    controlbutton_props = assign(controlbutton_props, controlbutton_spread_levels[i]);
  }
  controlbutton = new ControlButton_default({
    props: controlbutton_props,
    $$inline: true
  });
  controlbutton.$on(
    "click",
    /*onFitViewHandler*/
    ctx[20]
  );
  const block = {
    c: function create() {
      create_component(controlbutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(controlbutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(controlbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const controlbutton_changes = dirty[0] & /*buttonProps*/
      131072 ? get_spread_update(controlbutton_spread_levels, [
        controlbutton_spread_levels[0],
        controlbutton_spread_levels[1],
        controlbutton_spread_levels[2],
        get_spread_object(
          /*buttonProps*/
          ctx2[17]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      32) {
        controlbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton.$set(controlbutton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(controlbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(controlbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(controlbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(84:2) {#if showFitView}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let fitviewicon;
  let current;
  fitviewicon = new Fit_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(fitviewicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(fitviewicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(fitviewicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(fitviewicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fitviewicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(fitviewicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: '(85:4) <ControlButton       class=\\"svelte-flow__controls-fitview\\"       on:click={onFitViewHandler}       title=\\"fit view\\"       aria-label=\\"fit view\\"       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let controlbutton;
  let current;
  const controlbutton_spread_levels = [
    {
      class: "svelte-flow__controls-interactive"
    },
    { title: "toggle interactivity" },
    { "aria-label": "toggle interactivity" },
    /*buttonProps*/
    ctx[17]
  ];
  let controlbutton_props = {
    $$slots: { default: [create_default_slot_12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton_spread_levels.length; i += 1) {
    controlbutton_props = assign(controlbutton_props, controlbutton_spread_levels[i]);
  }
  controlbutton = new ControlButton_default({
    props: controlbutton_props,
    $$inline: true
  });
  controlbutton.$on(
    "click",
    /*onToggleInteractivity*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(controlbutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(controlbutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(controlbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const controlbutton_changes = dirty[0] & /*buttonProps*/
      131072 ? get_spread_update(controlbutton_spread_levels, [
        controlbutton_spread_levels[0],
        controlbutton_spread_levels[1],
        controlbutton_spread_levels[2],
        get_spread_object(
          /*buttonProps*/
          ctx2[17]
        )
      ]) : {};
      if (dirty[0] & /*isInteractive*/
      256 | dirty[1] & /*$$scope*/
      32) {
        controlbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton.$set(controlbutton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(controlbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(controlbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(controlbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(95:2) {#if showLock}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let lockicon;
  let current;
  lockicon = new Lock_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(lockicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lockicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lockicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(lockicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lockicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lockicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(103:39) {:else}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let unlockicon;
  let current;
  unlockicon = new Unlock_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(unlockicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(unlockicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(unlockicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(unlockicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(unlockicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(unlockicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(103:6) {#if isInteractive}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_14, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isInteractive*/
      ctx2[8]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(96:4) <ControlButton       class=\\"svelte-flow__controls-interactive\\"       on:click={onToggleInteractivity}       title=\\"toggle interactivity\\"       aria-label=\\"toggle interactivity\\"       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let current;
  const before_slot_template = (
    /*#slots*/
    ctx[35].before
  );
  const before_slot = create_slot(
    before_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_before_slot_context
  );
  let if_block0 = (
    /*showZoom*/
    ctx[1] && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*showFitView*/
    ctx[2] && create_if_block_2(ctx)
  );
  let if_block2 = (
    /*showLock*/
    ctx[3] && create_if_block10(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[35].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    null
  );
  const after_slot_template = (
    /*#slots*/
    ctx[35].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_after_slot_context
  );
  const block = {
    c: function create() {
      if (before_slot) before_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (default_slot) default_slot.c();
      t4 = space();
      if (after_slot) after_slot.c();
    },
    l: function claim(nodes) {
      if (before_slot) before_slot.l(nodes);
      t0 = claim_space(nodes);
      if (if_block0) if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      t3 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
      t4 = claim_space(nodes);
      if (after_slot) after_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (before_slot) {
        before_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t4, anchor);
      if (after_slot) {
        after_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_slot) {
        if (before_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            before_slot,
            before_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              before_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_before_slot_changes
            ),
            get_before_slot_context
          );
        }
      }
      if (
        /*showZoom*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*showZoom*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showFitView*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*showFitView*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*showLock*/
        ctx2[3]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*showLock*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block10(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_after_slot_changes
            ),
            get_after_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(before_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(default_slot, local);
      transition_in(after_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(default_slot, local);
      transition_out(after_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
      }
      if (before_slot) before_slot.d(detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (default_slot) default_slot.d(detaching);
      if (after_slot) after_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: `(54:0) <Panel   class={cc(['svelte-flow__controls', orientationClass, className])}   {position}   data-testid=\\"svelte-flow__controls\\"   aria-label={ariaLabel ?? 'Svelte Flow controls'}   {style} >`,
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let panel;
  let current;
  panel = new Panel_default({
    props: {
      class: cc([
        "svelte-flow__controls",
        /*orientationClass*/
        ctx[7],
        /*className*/
        ctx[6]
      ]),
      position: (
        /*position*/
        ctx[0]
      ),
      "data-testid": "svelte-flow__controls",
      "aria-label": (
        /*ariaLabel*/
        ctx[4] ?? "Svelte Flow controls"
      ),
      style: (
        /*style*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(panel.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(panel.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty[0] & /*orientationClass, className*/
      192) panel_changes.class = cc([
        "svelte-flow__controls",
        /*orientationClass*/
        ctx2[7],
        /*className*/
        ctx2[6]
      ]);
      if (dirty[0] & /*position*/
      1) panel_changes.position = /*position*/
      ctx2[0];
      if (dirty[0] & /*ariaLabel*/
      16) panel_changes["aria-label"] = /*ariaLabel*/
      ctx2[4] ?? "Svelte Flow controls";
      if (dirty[0] & /*style*/
      32) panel_changes.style = /*style*/
      ctx2[5];
      if (dirty[0] & /*isInteractive, showLock, showFitView, minZoomReached, maxZoomReached, showZoom*/
      1806 | dirty[1] & /*$$scope*/
      32) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(panel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(panel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let isInteractive;
  let minZoomReached;
  let maxZoomReached;
  let orientationClass;
  let $maxZoom;
  let $viewport;
  let $minZoom;
  let $elementsSelectable;
  let $nodesConnectable;
  let $nodesDraggable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Controls", slots, ["before", "default", "after"]);
  let { position = "bottom-left" } = $$props;
  let { showZoom = true } = $$props;
  let { showFitView = true } = $$props;
  let { showLock = true } = $$props;
  let { buttonBgColor = void 0 } = $$props;
  let { buttonBgColorHover = void 0 } = $$props;
  let { buttonColor = void 0 } = $$props;
  let { buttonColorHover = void 0 } = $$props;
  let { buttonBorderColor = void 0 } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { orientation = "vertical" } = $$props;
  let { fitViewOptions = void 0 } = $$props;
  let { class: className = "" } = $$props;
  const { zoomIn, zoomOut, fitView: fitView2, viewport, minZoom, maxZoom, nodesDraggable, nodesConnectable, elementsSelectable } = useStore();
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(30, $viewport = value));
  validate_store(minZoom, "minZoom");
  component_subscribe($$self, minZoom, (value) => $$invalidate(31, $minZoom = value));
  validate_store(maxZoom, "maxZoom");
  component_subscribe($$self, maxZoom, (value) => $$invalidate(29, $maxZoom = value));
  validate_store(nodesDraggable, "nodesDraggable");
  component_subscribe($$self, nodesDraggable, (value) => $$invalidate(34, $nodesDraggable = value));
  validate_store(nodesConnectable, "nodesConnectable");
  component_subscribe($$self, nodesConnectable, (value) => $$invalidate(33, $nodesConnectable = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(32, $elementsSelectable = value));
  const buttonProps = {
    bgColor: buttonBgColor,
    bgColorHover: buttonBgColorHover,
    color: buttonColor,
    colorHover: buttonColorHover,
    borderColor: buttonBorderColor
  };
  const onZoomInHandler = () => {
    zoomIn();
  };
  const onZoomOutHandler = () => {
    zoomOut();
  };
  const onFitViewHandler = () => {
    fitView2(fitViewOptions);
  };
  const onToggleInteractivity = () => {
    $$invalidate(8, isInteractive = !isInteractive);
    nodesDraggable.set(isInteractive);
    nodesConnectable.set(isInteractive);
    elementsSelectable.set(isInteractive);
  };
  const writable_props = [
    "position",
    "showZoom",
    "showFitView",
    "showLock",
    "buttonBgColor",
    "buttonBgColorHover",
    "buttonColor",
    "buttonColorHover",
    "buttonBorderColor",
    "ariaLabel",
    "style",
    "orientation",
    "fitViewOptions",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Controls> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2) $$invalidate(0, position = $$props2.position);
    if ("showZoom" in $$props2) $$invalidate(1, showZoom = $$props2.showZoom);
    if ("showFitView" in $$props2) $$invalidate(2, showFitView = $$props2.showFitView);
    if ("showLock" in $$props2) $$invalidate(3, showLock = $$props2.showLock);
    if ("buttonBgColor" in $$props2) $$invalidate(22, buttonBgColor = $$props2.buttonBgColor);
    if ("buttonBgColorHover" in $$props2) $$invalidate(23, buttonBgColorHover = $$props2.buttonBgColorHover);
    if ("buttonColor" in $$props2) $$invalidate(24, buttonColor = $$props2.buttonColor);
    if ("buttonColorHover" in $$props2) $$invalidate(25, buttonColorHover = $$props2.buttonColorHover);
    if ("buttonBorderColor" in $$props2) $$invalidate(26, buttonBorderColor = $$props2.buttonBorderColor);
    if ("ariaLabel" in $$props2) $$invalidate(4, ariaLabel = $$props2.ariaLabel);
    if ("style" in $$props2) $$invalidate(5, style = $$props2.style);
    if ("orientation" in $$props2) $$invalidate(27, orientation = $$props2.orientation);
    if ("fitViewOptions" in $$props2) $$invalidate(28, fitViewOptions = $$props2.fitViewOptions);
    if ("class" in $$props2) $$invalidate(6, className = $$props2.class);
    if ("$$scope" in $$props2) $$invalidate(36, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    Panel: Panel_default,
    useStore,
    ControlButton: ControlButton_default,
    PlusIcon: Plus_default,
    MinusIcon: Minus_default,
    FitViewIcon: Fit_default,
    LockIcon: Lock_default,
    UnlockIcon: Unlock_default,
    position,
    showZoom,
    showFitView,
    showLock,
    buttonBgColor,
    buttonBgColorHover,
    buttonColor,
    buttonColorHover,
    buttonBorderColor,
    ariaLabel,
    style,
    orientation,
    fitViewOptions,
    className,
    zoomIn,
    zoomOut,
    fitView: fitView2,
    viewport,
    minZoom,
    maxZoom,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    buttonProps,
    onZoomInHandler,
    onZoomOutHandler,
    onFitViewHandler,
    onToggleInteractivity,
    orientationClass,
    isInteractive,
    maxZoomReached,
    minZoomReached,
    $maxZoom,
    $viewport,
    $minZoom,
    $elementsSelectable,
    $nodesConnectable,
    $nodesDraggable
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2) $$invalidate(0, position = $$props2.position);
    if ("showZoom" in $$props2) $$invalidate(1, showZoom = $$props2.showZoom);
    if ("showFitView" in $$props2) $$invalidate(2, showFitView = $$props2.showFitView);
    if ("showLock" in $$props2) $$invalidate(3, showLock = $$props2.showLock);
    if ("buttonBgColor" in $$props2) $$invalidate(22, buttonBgColor = $$props2.buttonBgColor);
    if ("buttonBgColorHover" in $$props2) $$invalidate(23, buttonBgColorHover = $$props2.buttonBgColorHover);
    if ("buttonColor" in $$props2) $$invalidate(24, buttonColor = $$props2.buttonColor);
    if ("buttonColorHover" in $$props2) $$invalidate(25, buttonColorHover = $$props2.buttonColorHover);
    if ("buttonBorderColor" in $$props2) $$invalidate(26, buttonBorderColor = $$props2.buttonBorderColor);
    if ("ariaLabel" in $$props2) $$invalidate(4, ariaLabel = $$props2.ariaLabel);
    if ("style" in $$props2) $$invalidate(5, style = $$props2.style);
    if ("orientation" in $$props2) $$invalidate(27, orientation = $$props2.orientation);
    if ("fitViewOptions" in $$props2) $$invalidate(28, fitViewOptions = $$props2.fitViewOptions);
    if ("className" in $$props2) $$invalidate(6, className = $$props2.className);
    if ("orientationClass" in $$props2) $$invalidate(7, orientationClass = $$props2.orientationClass);
    if ("isInteractive" in $$props2) $$invalidate(8, isInteractive = $$props2.isInteractive);
    if ("maxZoomReached" in $$props2) $$invalidate(9, maxZoomReached = $$props2.maxZoomReached);
    if ("minZoomReached" in $$props2) $$invalidate(10, minZoomReached = $$props2.minZoomReached);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*$nodesDraggable, $nodesConnectable, $elementsSelectable*/
    14) {
      $: $$invalidate(8, isInteractive = $nodesDraggable || $nodesConnectable || $elementsSelectable);
    }
    if ($$self.$$.dirty[0] & /*$viewport*/
    1073741824 | $$self.$$.dirty[1] & /*$minZoom*/
    1) {
      $: $$invalidate(10, minZoomReached = $viewport.zoom <= $minZoom);
    }
    if ($$self.$$.dirty[0] & /*$viewport, $maxZoom*/
    1610612736) {
      $: $$invalidate(9, maxZoomReached = $viewport.zoom >= $maxZoom);
    }
    if ($$self.$$.dirty[0] & /*orientation*/
    134217728) {
      $: $$invalidate(7, orientationClass = orientation === "horizontal" ? "horizontal" : "vertical");
    }
  };
  return [
    position,
    showZoom,
    showFitView,
    showLock,
    ariaLabel,
    style,
    className,
    orientationClass,
    isInteractive,
    maxZoomReached,
    minZoomReached,
    viewport,
    minZoom,
    maxZoom,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    buttonProps,
    onZoomInHandler,
    onZoomOutHandler,
    onFitViewHandler,
    onToggleInteractivity,
    buttonBgColor,
    buttonBgColorHover,
    buttonColor,
    buttonColorHover,
    buttonBorderColor,
    orientation,
    fitViewOptions,
    $maxZoom,
    $viewport,
    $minZoom,
    $elementsSelectable,
    $nodesConnectable,
    $nodesDraggable,
    slots,
    $$scope
  ];
}
var Controls = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance43,
      create_fragment43,
      safe_not_equal,
      {
        position: 0,
        showZoom: 1,
        showFitView: 2,
        showLock: 3,
        buttonBgColor: 22,
        buttonBgColorHover: 23,
        buttonColor: 24,
        buttonColorHover: 25,
        buttonBorderColor: 26,
        ariaLabel: 4,
        style: 5,
        orientation: 27,
        fitViewOptions: 28,
        class: 6
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Controls",
      options,
      id: create_fragment43.name
    });
  }
  get position() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showZoom() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showZoom(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showFitView() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showFitView(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLock() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLock(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBgColor() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBgColor(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBgColorHover() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBgColorHover(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonColor() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonColor(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonColorHover() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonColorHover(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBorderColor() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBorderColor(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitViewOptions() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitViewOptions(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Controls_default = Controls;

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/types.js
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2["Lines"] = "lines";
  BackgroundVariant2["Dots"] = "dots";
  BackgroundVariant2["Cross"] = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte
var file27 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Background\\DotPattern.svelte";
function create_fragment44(ctx) {
  let circle;
  let circle_class_value;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true, class: true });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        circle,
        "cx",
        /*radius*/
        ctx[0]
      );
      attr_dev(
        circle,
        "cy",
        /*radius*/
        ctx[0]
      );
      attr_dev(
        circle,
        "r",
        /*radius*/
        ctx[0]
      );
      attr_dev(circle, "class", circle_class_value = cc([
        "svelte-flow__background-pattern",
        "dots",
        /*className*/
        ctx[1]
      ]));
      add_location(circle, file27, 6, 0, 120);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*radius*/
      1) {
        attr_dev(
          circle,
          "cx",
          /*radius*/
          ctx2[0]
        );
      }
      if (dirty & /*radius*/
      1) {
        attr_dev(
          circle,
          "cy",
          /*radius*/
          ctx2[0]
        );
      }
      if (dirty & /*radius*/
      1) {
        attr_dev(
          circle,
          "r",
          /*radius*/
          ctx2[0]
        );
      }
      if (dirty & /*className*/
      2 && circle_class_value !== (circle_class_value = cc([
        "svelte-flow__background-pattern",
        "dots",
        /*className*/
        ctx2[1]
      ]))) {
        attr_dev(circle, "class", circle_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(circle);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DotPattern", slots, []);
  let { radius = 5 } = $$props;
  let { class: className = "" } = $$props;
  const writable_props = ["radius", "class"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<DotPattern> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("radius" in $$props2) $$invalidate(0, radius = $$props2.radius);
    if ("class" in $$props2) $$invalidate(1, className = $$props2.class);
  };
  $$self.$capture_state = () => ({ cc, radius, className });
  $$self.$inject_state = ($$props2) => {
    if ("radius" in $$props2) $$invalidate(0, radius = $$props2.radius);
    if ("className" in $$props2) $$invalidate(1, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [radius, className];
}
var DotPattern = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { radius: 0, class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DotPattern",
      options,
      id: create_fragment44.name
    });
  }
  get radius() {
    throw new Error("<DotPattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<DotPattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DotPattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DotPattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DotPattern_default = DotPattern;

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte
var file28 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Background\\LinePattern.svelte";
function create_fragment45(ctx) {
  let path;
  let path_d_value;
  let path_class_value;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        "stroke-width": true,
        d: true,
        class: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        path,
        "stroke-width",
        /*lineWidth*/
        ctx[0]
      );
      attr_dev(path, "d", path_d_value = `M${/*dimensions*/
      ctx[1][0] / 2} 0 V${/*dimensions*/
      ctx[1][1]} M0 ${/*dimensions*/
      ctx[1][1] / 2} H${/*dimensions*/
      ctx[1][0]}`);
      attr_dev(path, "class", path_class_value = cc([
        "svelte-flow__background-pattern",
        /*variant*/
        ctx[2],
        /*className*/
        ctx[3]
      ]));
      add_location(path, file28, 8, 0, 178);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*lineWidth*/
      1) {
        attr_dev(
          path,
          "stroke-width",
          /*lineWidth*/
          ctx2[0]
        );
      }
      if (dirty & /*dimensions*/
      2 && path_d_value !== (path_d_value = `M${/*dimensions*/
      ctx2[1][0] / 2} 0 V${/*dimensions*/
      ctx2[1][1]} M0 ${/*dimensions*/
      ctx2[1][1] / 2} H${/*dimensions*/
      ctx2[1][0]}`)) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*variant, className*/
      12 && path_class_value !== (path_class_value = cc([
        "svelte-flow__background-pattern",
        /*variant*/
        ctx2[2],
        /*className*/
        ctx2[3]
      ]))) {
        attr_dev(path, "class", path_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinePattern", slots, []);
  let { lineWidth = 1 } = $$props;
  let { dimensions } = $$props;
  let { variant = void 0 } = $$props;
  let { class: className = "" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (dimensions === void 0 && !("dimensions" in $$props || $$self.$$.bound[$$self.$$.props["dimensions"]])) {
      console.warn("<LinePattern> was created without expected prop 'dimensions'");
    }
  });
  const writable_props = ["lineWidth", "dimensions", "variant", "class"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<LinePattern> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("lineWidth" in $$props2) $$invalidate(0, lineWidth = $$props2.lineWidth);
    if ("dimensions" in $$props2) $$invalidate(1, dimensions = $$props2.dimensions);
    if ("variant" in $$props2) $$invalidate(2, variant = $$props2.variant);
    if ("class" in $$props2) $$invalidate(3, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    lineWidth,
    dimensions,
    variant,
    className
  });
  $$self.$inject_state = ($$props2) => {
    if ("lineWidth" in $$props2) $$invalidate(0, lineWidth = $$props2.lineWidth);
    if ("dimensions" in $$props2) $$invalidate(1, dimensions = $$props2.dimensions);
    if ("variant" in $$props2) $$invalidate(2, variant = $$props2.variant);
    if ("className" in $$props2) $$invalidate(3, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [lineWidth, dimensions, variant, className];
}
var LinePattern = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, {
      lineWidth: 0,
      dimensions: 1,
      variant: 2,
      class: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinePattern",
      options,
      id: create_fragment45.name
    });
  }
  get lineWidth() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dimensions() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dimensions(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinePattern_default = LinePattern;

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte
var file29 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Background\\Background.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1r7pe8d", ".svelte-flow__background.svelte-1r7pe8d{position:absolute;width:100%;height:100%;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFja2dyb3VuZC5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhaXVzZXI5XFxEb2N1bWVudHNcXG11a2VzaFxcbmV3LXdvcmtpbmctd2ViLW1haW5cXG5ldy13b3JraW5nLXdlYi1tYWluXFxzcGVjdHJhLWxpdGVcXG5vZGVfbW9kdWxlc1xcQHh5Zmxvd1xcc3ZlbHRlXFxkaXN0XFxsaWJcXHBsdWdpbnNcXEJhY2tncm91bmRcXEJhY2tncm91bmQuc3ZlbHRlIl19 */");
}
function create_else_block2(ctx) {
  let linepattern;
  let current;
  linepattern = new LinePattern_default({
    props: {
      dimensions: (
        /*patternDimensions*/
        ctx[6]
      ),
      variant: (
        /*variant*/
        ctx[0]
      ),
      lineWidth: (
        /*lineWidth*/
        ctx[1]
      ),
      class: (
        /*patternClass*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(linepattern.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(linepattern.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(linepattern, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const linepattern_changes = {};
      if (dirty & /*patternDimensions*/
      64) linepattern_changes.dimensions = /*patternDimensions*/
      ctx2[6];
      if (dirty & /*variant*/
      1) linepattern_changes.variant = /*variant*/
      ctx2[0];
      if (dirty & /*lineWidth*/
      2) linepattern_changes.lineWidth = /*lineWidth*/
      ctx2[1];
      if (dirty & /*patternClass*/
      16) linepattern_changes.class = /*patternClass*/
      ctx2[4];
      linepattern.$set(linepattern_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(linepattern.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linepattern.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linepattern, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(55:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let dotpattern;
  let current;
  dotpattern = new DotPattern_default({
    props: {
      radius: (
        /*scaledSize*/
        ctx[7] / 2
      ),
      class: (
        /*patternClass*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dotpattern.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dotpattern.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dotpattern, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dotpattern_changes = {};
      if (dirty & /*scaledSize*/
      128) dotpattern_changes.radius = /*scaledSize*/
      ctx2[7] / 2;
      if (dirty & /*patternClass*/
      16) dotpattern_changes.class = /*patternClass*/
      ctx2[4];
      dotpattern.$set(dotpattern_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(dotpattern.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dotpattern.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dotpattern, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(53:4) {#if isDots}",
    ctx
  });
  return block;
}
function create_fragment46(ctx) {
  let svg;
  let pattern;
  let current_block_type_index;
  let if_block;
  let pattern_x_value;
  let pattern_y_value;
  let pattern_width_value;
  let pattern_height_value;
  let pattern_patternTransform_value;
  let rect;
  let rect_fill_value;
  let svg_class_value;
  let current;
  const if_block_creators = [create_if_block11, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isDots*/
      ctx2[14]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      pattern = svg_element("pattern");
      if_block.c();
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, "data-testid": true });
      var svg_nodes = children(svg);
      pattern = claim_svg_element(svg_nodes, "pattern", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        patternUnits: true,
        patternTransform: true
      });
      var pattern_nodes = children(pattern);
      if_block.l(pattern_nodes);
      pattern_nodes.forEach(detach_dev);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        fill: true
      });
      children(rect).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        pattern,
        "id",
        /*patternId*/
        ctx[11]
      );
      attr_dev(pattern, "x", pattern_x_value = /*$viewport*/
      ctx[9].x % /*scaledGap*/
      ctx[8][0]);
      attr_dev(pattern, "y", pattern_y_value = /*$viewport*/
      ctx[9].y % /*scaledGap*/
      ctx[8][1]);
      attr_dev(pattern, "width", pattern_width_value = /*scaledGap*/
      ctx[8][0]);
      attr_dev(pattern, "height", pattern_height_value = /*scaledGap*/
      ctx[8][1]);
      attr_dev(pattern, "patternUnits", "userSpaceOnUse");
      attr_dev(pattern, "patternTransform", pattern_patternTransform_value = `translate(-${/*patternOffset*/
      ctx[10][0]},-${/*patternOffset*/
      ctx[10][1]})`);
      add_location(pattern, file29, 43, 2, 1542);
      attr_dev(rect, "x", "0");
      attr_dev(rect, "y", "0");
      attr_dev(rect, "width", "100%");
      attr_dev(rect, "height", "100%");
      attr_dev(rect, "fill", rect_fill_value = `url(#${/*patternId*/
      ctx[11]})`);
      add_location(rect, file29, 58, 2, 2023);
      attr_dev(svg, "class", svg_class_value = null_to_empty(cc([
        "svelte-flow__background",
        /*className*/
        ctx[5]
      ])) + " svelte-1r7pe8d");
      attr_dev(svg, "data-testid", "svelte-flow__background");
      set_style(
        svg,
        "--xy-background-color-props",
        /*bgColor*/
        ctx[2]
      );
      set_style(
        svg,
        "--xy-background-pattern-color-props",
        /*patternColor*/
        ctx[3]
      );
      add_location(svg, file29, 37, 0, 1335);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, pattern);
      if_blocks[current_block_type_index].m(pattern, null);
      append_hydration_dev(svg, rect);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
      if (!current || dirty & /*patternId*/
      2048) {
        attr_dev(
          pattern,
          "id",
          /*patternId*/
          ctx2[11]
        );
      }
      if (!current || dirty & /*$viewport, scaledGap*/
      768 && pattern_x_value !== (pattern_x_value = /*$viewport*/
      ctx2[9].x % /*scaledGap*/
      ctx2[8][0])) {
        attr_dev(pattern, "x", pattern_x_value);
      }
      if (!current || dirty & /*$viewport, scaledGap*/
      768 && pattern_y_value !== (pattern_y_value = /*$viewport*/
      ctx2[9].y % /*scaledGap*/
      ctx2[8][1])) {
        attr_dev(pattern, "y", pattern_y_value);
      }
      if (!current || dirty & /*scaledGap*/
      256 && pattern_width_value !== (pattern_width_value = /*scaledGap*/
      ctx2[8][0])) {
        attr_dev(pattern, "width", pattern_width_value);
      }
      if (!current || dirty & /*scaledGap*/
      256 && pattern_height_value !== (pattern_height_value = /*scaledGap*/
      ctx2[8][1])) {
        attr_dev(pattern, "height", pattern_height_value);
      }
      if (!current || dirty & /*patternOffset*/
      1024 && pattern_patternTransform_value !== (pattern_patternTransform_value = `translate(-${/*patternOffset*/
      ctx2[10][0]},-${/*patternOffset*/
      ctx2[10][1]})`)) {
        attr_dev(pattern, "patternTransform", pattern_patternTransform_value);
      }
      if (!current || dirty & /*patternId*/
      2048 && rect_fill_value !== (rect_fill_value = `url(#${/*patternId*/
      ctx2[11]})`)) {
        attr_dev(rect, "fill", rect_fill_value);
      }
      if (!current || dirty & /*className*/
      32 && svg_class_value !== (svg_class_value = null_to_empty(cc([
        "svelte-flow__background",
        /*className*/
        ctx2[5]
      ])) + " svelte-1r7pe8d")) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (dirty & /*bgColor*/
      4) {
        set_style(
          svg,
          "--xy-background-color-props",
          /*bgColor*/
          ctx2[2]
        );
      }
      if (dirty & /*patternColor*/
      8) {
        set_style(
          svg,
          "--xy-background-pattern-color-props",
          /*patternColor*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
};
function instance46($$self, $$props, $$invalidate) {
  let patternId;
  let scaledGap;
  let scaledSize;
  let patternDimensions;
  let patternOffset;
  let $viewport;
  let $flowId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Background", slots, []);
  let { id = void 0 } = $$props;
  let { variant = BackgroundVariant.Dots } = $$props;
  let { gap = 20 } = $$props;
  let { size = 1 } = $$props;
  let { lineWidth = 1 } = $$props;
  let { bgColor = void 0 } = $$props;
  let { patternColor = void 0 } = $$props;
  let { patternClass = void 0 } = $$props;
  let { class: className = "" } = $$props;
  const { viewport, flowId } = useStore();
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(9, $viewport = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(18, $flowId = value));
  const patternSize = size || defaultSize[variant];
  const isDots = variant === BackgroundVariant.Dots;
  const isCross = variant === BackgroundVariant.Cross;
  const gapXY = Array.isArray(gap) ? gap : [gap, gap];
  const writable_props = [
    "id",
    "variant",
    "gap",
    "size",
    "lineWidth",
    "bgColor",
    "patternColor",
    "patternClass",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Background> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(15, id = $$props2.id);
    if ("variant" in $$props2) $$invalidate(0, variant = $$props2.variant);
    if ("gap" in $$props2) $$invalidate(16, gap = $$props2.gap);
    if ("size" in $$props2) $$invalidate(17, size = $$props2.size);
    if ("lineWidth" in $$props2) $$invalidate(1, lineWidth = $$props2.lineWidth);
    if ("bgColor" in $$props2) $$invalidate(2, bgColor = $$props2.bgColor);
    if ("patternColor" in $$props2) $$invalidate(3, patternColor = $$props2.patternColor);
    if ("patternClass" in $$props2) $$invalidate(4, patternClass = $$props2.patternClass);
    if ("class" in $$props2) $$invalidate(5, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    defaultSize,
    cc,
    DotPattern: DotPattern_default,
    LinePattern: LinePattern_default,
    useStore,
    BackgroundVariant,
    id,
    variant,
    gap,
    size,
    lineWidth,
    bgColor,
    patternColor,
    patternClass,
    className,
    viewport,
    flowId,
    patternSize,
    isDots,
    isCross,
    gapXY,
    patternDimensions,
    scaledSize,
    patternOffset,
    scaledGap,
    patternId,
    $viewport,
    $flowId
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(15, id = $$props2.id);
    if ("variant" in $$props2) $$invalidate(0, variant = $$props2.variant);
    if ("gap" in $$props2) $$invalidate(16, gap = $$props2.gap);
    if ("size" in $$props2) $$invalidate(17, size = $$props2.size);
    if ("lineWidth" in $$props2) $$invalidate(1, lineWidth = $$props2.lineWidth);
    if ("bgColor" in $$props2) $$invalidate(2, bgColor = $$props2.bgColor);
    if ("patternColor" in $$props2) $$invalidate(3, patternColor = $$props2.patternColor);
    if ("patternClass" in $$props2) $$invalidate(4, patternClass = $$props2.patternClass);
    if ("className" in $$props2) $$invalidate(5, className = $$props2.className);
    if ("patternDimensions" in $$props2) $$invalidate(6, patternDimensions = $$props2.patternDimensions);
    if ("scaledSize" in $$props2) $$invalidate(7, scaledSize = $$props2.scaledSize);
    if ("patternOffset" in $$props2) $$invalidate(10, patternOffset = $$props2.patternOffset);
    if ("scaledGap" in $$props2) $$invalidate(8, scaledGap = $$props2.scaledGap);
    if ("patternId" in $$props2) $$invalidate(11, patternId = $$props2.patternId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$flowId, id*/
    294912) {
      $: $$invalidate(11, patternId = `background-pattern-${$flowId}-${id ? id : ""}`);
    }
    if ($$self.$$.dirty & /*$viewport*/
    512) {
      $: $$invalidate(8, scaledGap = [gapXY[0] * $viewport.zoom || 1, gapXY[1] * $viewport.zoom || 1]);
    }
    if ($$self.$$.dirty & /*$viewport*/
    512) {
      $: $$invalidate(7, scaledSize = patternSize * $viewport.zoom);
    }
    if ($$self.$$.dirty & /*scaledSize, scaledGap*/
    384) {
      $: $$invalidate(6, patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap);
    }
    if ($$self.$$.dirty & /*scaledSize, patternDimensions*/
    192) {
      $: $$invalidate(10, patternOffset = isDots ? [scaledSize / 2, scaledSize / 2] : [patternDimensions[0] / 2, patternDimensions[1] / 2]);
    }
  };
  return [
    variant,
    lineWidth,
    bgColor,
    patternColor,
    patternClass,
    className,
    patternDimensions,
    scaledSize,
    scaledGap,
    $viewport,
    patternOffset,
    patternId,
    viewport,
    flowId,
    isDots,
    id,
    gap,
    size,
    $flowId
  ];
}
var Background = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance46,
      create_fragment46,
      safe_not_equal,
      {
        id: 15,
        variant: 0,
        gap: 16,
        size: 17,
        lineWidth: 1,
        bgColor: 2,
        patternColor: 3,
        patternClass: 4,
        class: 5
      },
      add_css8
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Background",
      options,
      id: create_fragment46.name
    });
  }
  get id() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternColor() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternColor(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternClass() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternClass(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Background_default = Background;

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte
var file30 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Minimap\\MinimapNode.svelte";
function create_fragment47(ctx) {
  let rect;
  let rect_class_value;
  let rect_style_value;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        class: true,
        x: true,
        y: true,
        rx: true,
        ry: true,
        width: true,
        height: true,
        style: true,
        "shape-rendering": true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "class", rect_class_value = cc([
        "svelte-flow__minimap-node",
        /*className*/
        ctx[10]
      ]));
      attr_dev(
        rect,
        "x",
        /*x*/
        ctx[0]
      );
      attr_dev(
        rect,
        "y",
        /*y*/
        ctx[1]
      );
      attr_dev(
        rect,
        "rx",
        /*borderRadius*/
        ctx[4]
      );
      attr_dev(
        rect,
        "ry",
        /*borderRadius*/
        ctx[4]
      );
      attr_dev(
        rect,
        "width",
        /*width*/
        ctx[2]
      );
      attr_dev(
        rect,
        "height",
        /*height*/
        ctx[3]
      );
      attr_dev(rect, "style", rect_style_value = `${/*color*/
      ctx[5] ? `fill: ${/*color*/
      ctx[5]};` : ""}${/*strokeColor*/
      ctx[7] ? `stroke: ${/*strokeColor*/
      ctx[7]};` : ""}${/*strokeWidth*/
      ctx[8] ? `stroke-width: ${/*strokeWidth*/
      ctx[8]};` : ""}`);
      attr_dev(
        rect,
        "shape-rendering",
        /*shapeRendering*/
        ctx[6]
      );
      toggle_class(
        rect,
        "selected",
        /*selected*/
        ctx[9]
      );
      add_location(rect, file30, 15, 0, 349);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*className*/
      1024 && rect_class_value !== (rect_class_value = cc([
        "svelte-flow__minimap-node",
        /*className*/
        ctx2[10]
      ]))) {
        attr_dev(rect, "class", rect_class_value);
      }
      if (dirty & /*x*/
      1) {
        attr_dev(
          rect,
          "x",
          /*x*/
          ctx2[0]
        );
      }
      if (dirty & /*y*/
      2) {
        attr_dev(
          rect,
          "y",
          /*y*/
          ctx2[1]
        );
      }
      if (dirty & /*borderRadius*/
      16) {
        attr_dev(
          rect,
          "rx",
          /*borderRadius*/
          ctx2[4]
        );
      }
      if (dirty & /*borderRadius*/
      16) {
        attr_dev(
          rect,
          "ry",
          /*borderRadius*/
          ctx2[4]
        );
      }
      if (dirty & /*width*/
      4) {
        attr_dev(
          rect,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty & /*height*/
      8) {
        attr_dev(
          rect,
          "height",
          /*height*/
          ctx2[3]
        );
      }
      if (dirty & /*color, strokeColor, strokeWidth*/
      416 && rect_style_value !== (rect_style_value = `${/*color*/
      ctx2[5] ? `fill: ${/*color*/
      ctx2[5]};` : ""}${/*strokeColor*/
      ctx2[7] ? `stroke: ${/*strokeColor*/
      ctx2[7]};` : ""}${/*strokeWidth*/
      ctx2[8] ? `stroke-width: ${/*strokeWidth*/
      ctx2[8]};` : ""}`)) {
        attr_dev(rect, "style", rect_style_value);
      }
      if (dirty & /*shapeRendering*/
      64) {
        attr_dev(
          rect,
          "shape-rendering",
          /*shapeRendering*/
          ctx2[6]
        );
      }
      if (dirty & /*className, selected*/
      1536) {
        toggle_class(
          rect,
          "selected",
          /*selected*/
          ctx2[9]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(rect);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MinimapNode", slots, []);
  let { x } = $$props;
  let { y } = $$props;
  let { width = 0 } = $$props;
  let { height = 0 } = $$props;
  let { borderRadius = 5 } = $$props;
  let { color = void 0 } = $$props;
  let { shapeRendering } = $$props;
  let { strokeColor = void 0 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { selected = false } = $$props;
  let { class: className = "" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (x === void 0 && !("x" in $$props || $$self.$$.bound[$$self.$$.props["x"]])) {
      console.warn("<MinimapNode> was created without expected prop 'x'");
    }
    if (y === void 0 && !("y" in $$props || $$self.$$.bound[$$self.$$.props["y"]])) {
      console.warn("<MinimapNode> was created without expected prop 'y'");
    }
    if (shapeRendering === void 0 && !("shapeRendering" in $$props || $$self.$$.bound[$$self.$$.props["shapeRendering"]])) {
      console.warn("<MinimapNode> was created without expected prop 'shapeRendering'");
    }
  });
  const writable_props = [
    "x",
    "y",
    "width",
    "height",
    "borderRadius",
    "color",
    "shapeRendering",
    "strokeColor",
    "strokeWidth",
    "selected",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<MinimapNode> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("borderRadius" in $$props2) $$invalidate(4, borderRadius = $$props2.borderRadius);
    if ("color" in $$props2) $$invalidate(5, color = $$props2.color);
    if ("shapeRendering" in $$props2) $$invalidate(6, shapeRendering = $$props2.shapeRendering);
    if ("strokeColor" in $$props2) $$invalidate(7, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2) $$invalidate(8, strokeWidth = $$props2.strokeWidth);
    if ("selected" in $$props2) $$invalidate(9, selected = $$props2.selected);
    if ("class" in $$props2) $$invalidate(10, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    x,
    y,
    width,
    height,
    borderRadius,
    color,
    shapeRendering,
    strokeColor,
    strokeWidth,
    selected,
    className
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("borderRadius" in $$props2) $$invalidate(4, borderRadius = $$props2.borderRadius);
    if ("color" in $$props2) $$invalidate(5, color = $$props2.color);
    if ("shapeRendering" in $$props2) $$invalidate(6, shapeRendering = $$props2.shapeRendering);
    if ("strokeColor" in $$props2) $$invalidate(7, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2) $$invalidate(8, strokeWidth = $$props2.strokeWidth);
    if ("selected" in $$props2) $$invalidate(9, selected = $$props2.selected);
    if ("className" in $$props2) $$invalidate(10, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    x,
    y,
    width,
    height,
    borderRadius,
    color,
    shapeRendering,
    strokeColor,
    strokeWidth,
    selected,
    className
  ];
}
var MinimapNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      x: 0,
      y: 1,
      width: 2,
      height: 3,
      borderRadius: 4,
      color: 5,
      shapeRendering: 6,
      strokeColor: 7,
      strokeWidth: 8,
      selected: 9,
      class: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MinimapNode",
      options,
      id: create_fragment47.name
    });
  }
  get x() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shapeRendering() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shapeRendering(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeColor() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeColor(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MinimapNode_default = MinimapNode;

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/interactive.js
function interactive(domNode, params) {
  const minimap = XYMinimap({
    domNode,
    panZoom: params.panZoom,
    getTransform: () => {
      const viewport = get_store_value(params.viewport);
      return [viewport.x, viewport.y, viewport.zoom];
    },
    getViewScale: params.getViewScale
  });
  function update(params2) {
    minimap.update({
      translateExtent: params2.translateExtent,
      width: params2.width,
      height: params2.height,
      inversePan: params2.inversePan,
      zoomStep: params2.zoomStep,
      pannable: params2.pannable,
      zoomable: params2.zoomable
    });
  }
  return {
    update,
    destroy() {
      minimap.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte
var file31 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\Minimap\\Minimap.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[55] = list[i];
  const constants_0 = (
    /*$nodeLookup*/
    child_ctx[20].get(
      /*userNode*/
      child_ctx[55].id
    )
  );
  child_ctx[56] = constants_0;
  return child_ctx;
}
function get_if_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getNodeDimensions(
    /*node*/
    child_ctx[56]
  );
  child_ctx[59] = constants_0;
  return child_ctx;
}
function create_if_block12(ctx) {
  let svg;
  let if_block_anchor;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let path;
  let path_d_value;
  let svg_viewBox_value;
  let interactive_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*ariaLabel*/
    ctx[1] && create_if_block_22(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*$nodes*/
    ctx[19]
  );
  const get_key = (ctx2) => (
    /*userNode*/
    ctx2[55].id
  );
  validate_each_keys(ctx, each_value, get_each_context4, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block4(key2, child_ctx));
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        class: true,
        role: true,
        "aria-labelledby": true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(svg_nodes);
      }
      path = claim_svg_element(svg_nodes, "path", {
        class: true,
        d: true,
        "fill-rule": true,
        "pointer-events": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "class", "svelte-flow__minimap-mask");
      attr_dev(path, "d", path_d_value = "M" + /*x*/
      (ctx[26] - /*offset*/
      ctx[15]) + "," + /*y*/
      (ctx[25] - /*offset*/
      ctx[15]) + "h" + /*viewboxWidth*/
      (ctx[24] + /*offset*/
      ctx[15] * 2) + "v" + /*viewboxHeight*/
      (ctx[23] + /*offset*/
      ctx[15] * 2) + "h" + (-/*viewboxWidth*/
      ctx[24] - /*offset*/
      ctx[15] * 2) + "z\n      M" + /*viewBB*/
      ctx[18].x + "," + /*viewBB*/
      ctx[18].y + "h" + /*viewBB*/
      ctx[18].width + "v" + /*viewBB*/
      ctx[18].height + "h" + -/*viewBB*/
      ctx[18].width + "z");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "pointer-events", "none");
      add_location(path, file31, 120, 6, 4490);
      attr_dev(
        svg,
        "width",
        /*elementWidth*/
        ctx[17]
      );
      attr_dev(
        svg,
        "height",
        /*elementHeight*/
        ctx[16]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = /*x*/
      ctx[26] + " " + /*y*/
      ctx[25] + " " + /*viewboxWidth*/
      ctx[24] + " " + /*viewboxHeight*/
      ctx[23]);
      attr_dev(svg, "class", "svelte-flow__minimap-svg");
      attr_dev(svg, "role", "img");
      attr_dev(
        svg,
        "aria-labelledby",
        /*labelledBy*/
        ctx[41]
      );
      set_style(
        svg,
        "--xy-minimap-mask-background-color-props",
        /*maskColor*/
        ctx[5]
      );
      set_style(
        svg,
        "--xy-minimap-mask-stroke-color-props",
        /*maskStrokeColor*/
        ctx[6]
      );
      set_style(
        svg,
        "--xy-minimap-mask-stroke-width-props",
        /*maskStrokeWidth*/
        ctx[7] ? (
          /*maskStrokeWidth*/
          ctx[7] * /*viewScale*/
          ctx[14]
        ) : void 0
      );
      add_location(svg, file31, 75, 4, 2975);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, if_block_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      append_hydration_dev(svg, path);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(interactive_action = interactive.call(null, svg, {
          panZoom: (
            /*$panZoom*/
            ctx[27]
          ),
          viewport: (
            /*viewport*/
            ctx[31]
          ),
          getViewScale: (
            /*getViewScale*/
            ctx[42]
          ),
          translateExtent: (
            /*$translateExtent*/
            ctx[28]
          ),
          width: (
            /*$containerWidth*/
            ctx[22]
          ),
          height: (
            /*$containerHeight*/
            ctx[21]
          ),
          inversePan: (
            /*inversePan*/
            ctx[10]
          ),
          zoomStep: (
            /*zoomStep*/
            ctx[11]
          ),
          pannable: (
            /*pannable*/
            ctx[8]
          ),
          zoomable: (
            /*zoomable*/
            ctx[9]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*ariaLabel*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          if_block.m(svg, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*$nodeLookup, $nodes, nodeBorderRadius, nodeStrokeWidth*/
      1572876 | dirty[1] & /*nodeColorFunc, nodeStrokeColorFunc, shapeRendering, nodeClassFunc*/
      960) {
        each_value = ensure_array_like_dev(
          /*$nodes*/
          ctx2[19]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, svg, outro_and_destroy_block, create_each_block4, path, get_each_context4);
        check_outros();
      }
      if (!current || dirty[0] & /*x, offset, y, viewboxWidth, viewboxHeight, viewBB*/
      126124032 && path_d_value !== (path_d_value = "M" + /*x*/
      (ctx2[26] - /*offset*/
      ctx2[15]) + "," + /*y*/
      (ctx2[25] - /*offset*/
      ctx2[15]) + "h" + /*viewboxWidth*/
      (ctx2[24] + /*offset*/
      ctx2[15] * 2) + "v" + /*viewboxHeight*/
      (ctx2[23] + /*offset*/
      ctx2[15] * 2) + "h" + (-/*viewboxWidth*/
      ctx2[24] - /*offset*/
      ctx2[15] * 2) + "z\n      M" + /*viewBB*/
      ctx2[18].x + "," + /*viewBB*/
      ctx2[18].y + "h" + /*viewBB*/
      ctx2[18].width + "v" + /*viewBB*/
      ctx2[18].height + "h" + -/*viewBB*/
      ctx2[18].width + "z")) {
        attr_dev(path, "d", path_d_value);
      }
      if (!current || dirty[0] & /*elementWidth*/
      131072) {
        attr_dev(
          svg,
          "width",
          /*elementWidth*/
          ctx2[17]
        );
      }
      if (!current || dirty[0] & /*elementHeight*/
      65536) {
        attr_dev(
          svg,
          "height",
          /*elementHeight*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*x, y, viewboxWidth, viewboxHeight*/
      125829120 && svg_viewBox_value !== (svg_viewBox_value = /*x*/
      ctx2[26] + " " + /*y*/
      ctx2[25] + " " + /*viewboxWidth*/
      ctx2[24] + " " + /*viewboxHeight*/
      ctx2[23])) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (interactive_action && is_function(interactive_action.update) && dirty[0] & /*$panZoom, $translateExtent, $containerWidth, $containerHeight, inversePan, zoomStep, pannable, zoomable*/
      408948480) interactive_action.update.call(null, {
        panZoom: (
          /*$panZoom*/
          ctx2[27]
        ),
        viewport: (
          /*viewport*/
          ctx2[31]
        ),
        getViewScale: (
          /*getViewScale*/
          ctx2[42]
        ),
        translateExtent: (
          /*$translateExtent*/
          ctx2[28]
        ),
        width: (
          /*$containerWidth*/
          ctx2[22]
        ),
        height: (
          /*$containerHeight*/
          ctx2[21]
        ),
        inversePan: (
          /*inversePan*/
          ctx2[10]
        ),
        zoomStep: (
          /*zoomStep*/
          ctx2[11]
        ),
        pannable: (
          /*pannable*/
          ctx2[8]
        ),
        zoomable: (
          /*zoomable*/
          ctx2[9]
        )
      });
      if (dirty[0] & /*maskColor*/
      32) {
        set_style(
          svg,
          "--xy-minimap-mask-background-color-props",
          /*maskColor*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*maskStrokeColor*/
      64) {
        set_style(
          svg,
          "--xy-minimap-mask-stroke-color-props",
          /*maskStrokeColor*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*maskStrokeWidth, viewScale*/
      16512) {
        set_style(
          svg,
          "--xy-minimap-mask-stroke-width-props",
          /*maskStrokeWidth*/
          ctx2[7] ? (
            /*maskStrokeWidth*/
            ctx2[7] * /*viewScale*/
            ctx2[14]
          ) : void 0
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(75:2) {#if $panZoom}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let title;
  let t;
  const block = {
    c: function create() {
      title = svg_element("title");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title = claim_svg_element(nodes, "title", { id: true });
      var title_nodes = children(title);
      t = claim_text(
        title_nodes,
        /*ariaLabel*/
        ctx[1]
      );
      title_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        title,
        "id",
        /*labelledBy*/
        ctx[41]
      );
      add_location(title, file31, 100, 21, 3749);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title, anchor);
      append_hydration_dev(title, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*ariaLabel*/
      2) set_data_dev(
        t,
        /*ariaLabel*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(101:6) {#if ariaLabel}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  var _a;
  let minimapnode;
  let current;
  const minimapnode_spread_levels = [
    {
      x: (
        /*node*/
        ctx[56].internals.positionAbsolute.x
      )
    },
    {
      y: (
        /*node*/
        ctx[56].internals.positionAbsolute.y
      )
    },
    /*nodeDimesions*/
    ctx[59],
    { selected: (
      /*node*/
      ctx[56].selected
    ) },
    {
      color: (
        /*nodeColorFunc*/
        (_a = ctx[37]) == null ? void 0 : _a.call(
          ctx,
          /*node*/
          ctx[56]
        )
      )
    },
    {
      borderRadius: (
        /*nodeBorderRadius*/
        ctx[2]
      )
    },
    {
      strokeColor: (
        /*nodeStrokeColorFunc*/
        ctx[38](
          /*node*/
          ctx[56]
        )
      )
    },
    { strokeWidth: (
      /*nodeStrokeWidth*/
      ctx[3]
    ) },
    {
      shapeRendering: (
        /*shapeRendering*/
        ctx[40]
      )
    },
    {
      class: (
        /*nodeClassFunc*/
        ctx[39](
          /*node*/
          ctx[56]
        )
      )
    }
  ];
  let minimapnode_props = {};
  for (let i = 0; i < minimapnode_spread_levels.length; i += 1) {
    minimapnode_props = assign(minimapnode_props, minimapnode_spread_levels[i]);
  }
  minimapnode = new MinimapNode_default({ props: minimapnode_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(minimapnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(minimapnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(minimapnode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2;
      const minimapnode_changes = dirty[0] & /*$nodeLookup, $nodes, nodeBorderRadius, nodeStrokeWidth*/
      1572876 | dirty[1] & /*nodeColorFunc, nodeStrokeColorFunc, shapeRendering, nodeClassFunc*/
      960 ? get_spread_update(minimapnode_spread_levels, [
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 && {
          x: (
            /*node*/
            ctx2[56].internals.positionAbsolute.x
          )
        },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 && {
          y: (
            /*node*/
            ctx2[56].internals.positionAbsolute.y
          )
        },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 && get_spread_object(
          /*nodeDimesions*/
          ctx2[59]
        ),
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 && { selected: (
          /*node*/
          ctx2[56].selected
        ) },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 | dirty[1] & /*nodeColorFunc*/
        64 && {
          color: (
            /*nodeColorFunc*/
            (_a2 = ctx2[37]) == null ? void 0 : _a2.call(
              ctx2,
              /*node*/
              ctx2[56]
            )
          )
        },
        dirty[0] & /*nodeBorderRadius*/
        4 && {
          borderRadius: (
            /*nodeBorderRadius*/
            ctx2[2]
          )
        },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 | dirty[1] & /*nodeStrokeColorFunc*/
        128 && {
          strokeColor: (
            /*nodeStrokeColorFunc*/
            ctx2[38](
              /*node*/
              ctx2[56]
            )
          )
        },
        dirty[0] & /*nodeStrokeWidth*/
        8 && { strokeWidth: (
          /*nodeStrokeWidth*/
          ctx2[3]
        ) },
        dirty[1] & /*shapeRendering*/
        512 && {
          shapeRendering: (
            /*shapeRendering*/
            ctx2[40]
          )
        },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 | dirty[1] & /*nodeClassFunc*/
        256 && {
          class: (
            /*nodeClassFunc*/
            ctx2[39](
              /*node*/
              ctx2[56]
            )
          )
        }
      ]) : {};
      minimapnode.$set(minimapnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(minimapnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(minimapnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(minimapnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(105:8) {#if node && nodeHasDimensions(node)}",
    ctx
  });
  return block;
}
function create_each_block4(key_1, ctx) {
  let first;
  let show_if = (
    /*node*/
    ctx[56] && nodeHasDimensions(
      /*node*/
      ctx[56]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_15(get_if_ctx(ctx));
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*$nodeLookup, $nodes*/
      1572864) show_if = /*node*/
      ctx[56] && nodeHasDimensions(
        /*node*/
        ctx[56]
      );
      if (show_if) {
        if (if_block) {
          if_block.p(get_if_ctx(ctx), dirty);
          if (dirty[0] & /*$nodeLookup, $nodes*/
          1572864) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(get_if_ctx(ctx));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(103:6) {#each $nodes as userNode (userNode.id)}",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$panZoom*/
    ctx[27] && create_if_block12(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$panZoom*/
        ctx2[27]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$panZoom*/
          134217728) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(69:0) <Panel   {position}   style={style + (bgColor ? `;--xy-minimap-background-color-props:${bgColor}` : '')}   class={cc(['svelte-flow__minimap', className])}   data-testid=\\\"svelte-flow__minimap\\\" >",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let panel;
  let current;
  panel = new Panel_default({
    props: {
      position: (
        /*position*/
        ctx[0]
      ),
      style: (
        /*style*/
        ctx[12] + /*bgColor*/
        (ctx[4] ? `;--xy-minimap-background-color-props:${/*bgColor*/
        ctx[4]}` : "")
      ),
      class: cc([
        "svelte-flow__minimap",
        /*className*/
        ctx[13]
      ]),
      "data-testid": "svelte-flow__minimap",
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(panel.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(panel.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty[0] & /*position*/
      1) panel_changes.position = /*position*/
      ctx2[0];
      if (dirty[0] & /*style, bgColor*/
      4112) panel_changes.style = /*style*/
      ctx2[12] + /*bgColor*/
      (ctx2[4] ? `;--xy-minimap-background-color-props:${/*bgColor*/
      ctx2[4]}` : "");
      if (dirty[0] & /*className*/
      8192) panel_changes.class = cc([
        "svelte-flow__minimap",
        /*className*/
        ctx2[13]
      ]);
      if (dirty[0] & /*elementWidth, elementHeight, x, y, viewboxWidth, viewboxHeight, $panZoom, $translateExtent, $containerWidth, $containerHeight, inversePan, zoomStep, pannable, zoomable, maskColor, maskStrokeColor, maskStrokeWidth, viewScale, offset, viewBB, $nodes, $nodeLookup, nodeBorderRadius, nodeStrokeWidth, ariaLabel*/
      536858606 | dirty[1] & /*$$scope*/
      536870912) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(panel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(panel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var getAttrFunction = (func2) => func2 instanceof Function ? func2 : () => func2;
var defaultWidth = 200;
var defaultHeight = 150;
function instance48($$self, $$props, $$invalidate) {
  let viewBB;
  let elementWidth;
  let elementHeight;
  let scaledWidth;
  let scaledHeight;
  let viewScale;
  let viewWidth;
  let viewHeight;
  let offset;
  let x;
  let y;
  let viewboxWidth;
  let viewboxHeight;
  let $nodes;
  let $nodeLookup;
  let $viewport;
  let $containerHeight;
  let $containerWidth;
  let $flowId;
  let $panZoom;
  let $translateExtent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Minimap", slots, []);
  let { position = "bottom-right" } = $$props;
  let { ariaLabel = "Mini map" } = $$props;
  let { nodeStrokeColor = "transparent" } = $$props;
  let { nodeColor = void 0 } = $$props;
  let { nodeClass = "" } = $$props;
  let { nodeBorderRadius = 5 } = $$props;
  let { nodeStrokeWidth = 2 } = $$props;
  let { bgColor = void 0 } = $$props;
  let { maskColor = void 0 } = $$props;
  let { maskStrokeColor = void 0 } = $$props;
  let { maskStrokeWidth = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { pannable = true } = $$props;
  let { zoomable = true } = $$props;
  let { inversePan = void 0 } = $$props;
  let { zoomStep = void 0 } = $$props;
  let { style = "" } = $$props;
  let { class: className = "" } = $$props;
  const { nodes, nodeLookup, viewport, width: containerWidth, height: containerHeight, flowId, panZoom, translateExtent } = useStore();
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(19, $nodes = value));
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(20, $nodeLookup = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(53, $viewport = value));
  validate_store(containerWidth, "containerWidth");
  component_subscribe($$self, containerWidth, (value) => $$invalidate(22, $containerWidth = value));
  validate_store(containerHeight, "containerHeight");
  component_subscribe($$self, containerHeight, (value) => $$invalidate(21, $containerHeight = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(54, $flowId = value));
  validate_store(panZoom, "panZoom");
  component_subscribe($$self, panZoom, (value) => $$invalidate(27, $panZoom = value));
  validate_store(translateExtent, "translateExtent");
  component_subscribe($$self, translateExtent, (value) => $$invalidate(28, $translateExtent = value));
  const nodeColorFunc = nodeColor === void 0 ? void 0 : getAttrFunction(nodeColor);
  const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);
  const nodeClassFunc = getAttrFunction(nodeClass);
  const shapeRendering = (
    // @ts-expect-error - TS doesn't know about chrome
    typeof window === "undefined" || !!window.chrome ? "crispEdges" : "geometricPrecision"
  );
  const labelledBy = `svelte-flow__minimap-desc-${$flowId}`;
  let boundingRect = viewBB;
  const getViewScale = () => viewScale;
  const writable_props = [
    "position",
    "ariaLabel",
    "nodeStrokeColor",
    "nodeColor",
    "nodeClass",
    "nodeBorderRadius",
    "nodeStrokeWidth",
    "bgColor",
    "maskColor",
    "maskStrokeColor",
    "maskStrokeWidth",
    "width",
    "height",
    "pannable",
    "zoomable",
    "inversePan",
    "zoomStep",
    "style",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Minimap> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2) $$invalidate(0, position = $$props2.position);
    if ("ariaLabel" in $$props2) $$invalidate(1, ariaLabel = $$props2.ariaLabel);
    if ("nodeStrokeColor" in $$props2) $$invalidate(43, nodeStrokeColor = $$props2.nodeStrokeColor);
    if ("nodeColor" in $$props2) $$invalidate(44, nodeColor = $$props2.nodeColor);
    if ("nodeClass" in $$props2) $$invalidate(45, nodeClass = $$props2.nodeClass);
    if ("nodeBorderRadius" in $$props2) $$invalidate(2, nodeBorderRadius = $$props2.nodeBorderRadius);
    if ("nodeStrokeWidth" in $$props2) $$invalidate(3, nodeStrokeWidth = $$props2.nodeStrokeWidth);
    if ("bgColor" in $$props2) $$invalidate(4, bgColor = $$props2.bgColor);
    if ("maskColor" in $$props2) $$invalidate(5, maskColor = $$props2.maskColor);
    if ("maskStrokeColor" in $$props2) $$invalidate(6, maskStrokeColor = $$props2.maskStrokeColor);
    if ("maskStrokeWidth" in $$props2) $$invalidate(7, maskStrokeWidth = $$props2.maskStrokeWidth);
    if ("width" in $$props2) $$invalidate(46, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(47, height = $$props2.height);
    if ("pannable" in $$props2) $$invalidate(8, pannable = $$props2.pannable);
    if ("zoomable" in $$props2) $$invalidate(9, zoomable = $$props2.zoomable);
    if ("inversePan" in $$props2) $$invalidate(10, inversePan = $$props2.inversePan);
    if ("zoomStep" in $$props2) $$invalidate(11, zoomStep = $$props2.zoomStep);
    if ("style" in $$props2) $$invalidate(12, style = $$props2.style);
    if ("class" in $$props2) $$invalidate(13, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    getAttrFunction,
    cc,
    getBoundsOfRects,
    getInternalNodesBounds,
    getNodeDimensions,
    nodeHasDimensions,
    useStore,
    Panel: Panel_default,
    MinimapNode: MinimapNode_default,
    interactive,
    position,
    ariaLabel,
    nodeStrokeColor,
    nodeColor,
    nodeClass,
    nodeBorderRadius,
    nodeStrokeWidth,
    bgColor,
    maskColor,
    maskStrokeColor,
    maskStrokeWidth,
    width,
    height,
    pannable,
    zoomable,
    inversePan,
    zoomStep,
    style,
    className,
    defaultWidth,
    defaultHeight,
    nodes,
    nodeLookup,
    viewport,
    containerWidth,
    containerHeight,
    flowId,
    panZoom,
    translateExtent,
    nodeColorFunc,
    nodeStrokeColorFunc,
    nodeClassFunc,
    shapeRendering,
    labelledBy,
    boundingRect,
    getViewScale,
    viewScale,
    offset,
    viewHeight,
    viewboxHeight,
    viewWidth,
    viewboxWidth,
    y,
    x,
    elementHeight,
    elementWidth,
    scaledHeight,
    scaledWidth,
    viewBB,
    $nodes,
    $nodeLookup,
    $viewport,
    $containerHeight,
    $containerWidth,
    $flowId,
    $panZoom,
    $translateExtent
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2) $$invalidate(0, position = $$props2.position);
    if ("ariaLabel" in $$props2) $$invalidate(1, ariaLabel = $$props2.ariaLabel);
    if ("nodeStrokeColor" in $$props2) $$invalidate(43, nodeStrokeColor = $$props2.nodeStrokeColor);
    if ("nodeColor" in $$props2) $$invalidate(44, nodeColor = $$props2.nodeColor);
    if ("nodeClass" in $$props2) $$invalidate(45, nodeClass = $$props2.nodeClass);
    if ("nodeBorderRadius" in $$props2) $$invalidate(2, nodeBorderRadius = $$props2.nodeBorderRadius);
    if ("nodeStrokeWidth" in $$props2) $$invalidate(3, nodeStrokeWidth = $$props2.nodeStrokeWidth);
    if ("bgColor" in $$props2) $$invalidate(4, bgColor = $$props2.bgColor);
    if ("maskColor" in $$props2) $$invalidate(5, maskColor = $$props2.maskColor);
    if ("maskStrokeColor" in $$props2) $$invalidate(6, maskStrokeColor = $$props2.maskStrokeColor);
    if ("maskStrokeWidth" in $$props2) $$invalidate(7, maskStrokeWidth = $$props2.maskStrokeWidth);
    if ("width" in $$props2) $$invalidate(46, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(47, height = $$props2.height);
    if ("pannable" in $$props2) $$invalidate(8, pannable = $$props2.pannable);
    if ("zoomable" in $$props2) $$invalidate(9, zoomable = $$props2.zoomable);
    if ("inversePan" in $$props2) $$invalidate(10, inversePan = $$props2.inversePan);
    if ("zoomStep" in $$props2) $$invalidate(11, zoomStep = $$props2.zoomStep);
    if ("style" in $$props2) $$invalidate(12, style = $$props2.style);
    if ("className" in $$props2) $$invalidate(13, className = $$props2.className);
    if ("boundingRect" in $$props2) $$invalidate(48, boundingRect = $$props2.boundingRect);
    if ("viewScale" in $$props2) $$invalidate(14, viewScale = $$props2.viewScale);
    if ("offset" in $$props2) $$invalidate(15, offset = $$props2.offset);
    if ("viewHeight" in $$props2) $$invalidate(49, viewHeight = $$props2.viewHeight);
    if ("viewboxHeight" in $$props2) $$invalidate(23, viewboxHeight = $$props2.viewboxHeight);
    if ("viewWidth" in $$props2) $$invalidate(50, viewWidth = $$props2.viewWidth);
    if ("viewboxWidth" in $$props2) $$invalidate(24, viewboxWidth = $$props2.viewboxWidth);
    if ("y" in $$props2) $$invalidate(25, y = $$props2.y);
    if ("x" in $$props2) $$invalidate(26, x = $$props2.x);
    if ("elementHeight" in $$props2) $$invalidate(16, elementHeight = $$props2.elementHeight);
    if ("elementWidth" in $$props2) $$invalidate(17, elementWidth = $$props2.elementWidth);
    if ("scaledHeight" in $$props2) $$invalidate(51, scaledHeight = $$props2.scaledHeight);
    if ("scaledWidth" in $$props2) $$invalidate(52, scaledWidth = $$props2.scaledWidth);
    if ("viewBB" in $$props2) $$invalidate(18, viewBB = $$props2.viewBB);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$containerWidth, $containerHeight*/
    6291456 | $$self.$$.dirty[1] & /*$viewport*/
    4194304) {
      $: $$invalidate(18, viewBB = {
        x: -$viewport.x / $viewport.zoom,
        y: -$viewport.y / $viewport.zoom,
        width: $containerWidth / $viewport.zoom,
        height: $containerHeight / $viewport.zoom
      });
    }
    if ($$self.$$.dirty[0] & /*$nodeLookup, viewBB, $nodes*/
    1835008) {
      $: {
        $$invalidate(48, boundingRect = $nodeLookup.size > 0 ? getBoundsOfRects(getInternalNodesBounds($nodeLookup), viewBB) : viewBB);
        $nodes;
      }
    }
    if ($$self.$$.dirty[1] & /*width*/
    32768) {
      $: $$invalidate(17, elementWidth = width ?? defaultWidth);
    }
    if ($$self.$$.dirty[1] & /*height*/
    65536) {
      $: $$invalidate(16, elementHeight = height ?? defaultHeight);
    }
    if ($$self.$$.dirty[0] & /*elementWidth*/
    131072 | $$self.$$.dirty[1] & /*boundingRect*/
    131072) {
      $: $$invalidate(52, scaledWidth = boundingRect.width / elementWidth);
    }
    if ($$self.$$.dirty[0] & /*elementHeight*/
    65536 | $$self.$$.dirty[1] & /*boundingRect*/
    131072) {
      $: $$invalidate(51, scaledHeight = boundingRect.height / elementHeight);
    }
    if ($$self.$$.dirty[1] & /*scaledWidth, scaledHeight*/
    3145728) {
      $: $$invalidate(14, viewScale = Math.max(scaledWidth, scaledHeight));
    }
    if ($$self.$$.dirty[0] & /*viewScale, elementWidth*/
    147456) {
      $: $$invalidate(50, viewWidth = viewScale * elementWidth);
    }
    if ($$self.$$.dirty[0] & /*viewScale, elementHeight*/
    81920) {
      $: $$invalidate(49, viewHeight = viewScale * elementHeight);
    }
    if ($$self.$$.dirty[0] & /*viewScale*/
    16384) {
      $: $$invalidate(15, offset = 5 * viewScale);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    32768 | $$self.$$.dirty[1] & /*boundingRect, viewWidth*/
    655360) {
      $: $$invalidate(26, x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    32768 | $$self.$$.dirty[1] & /*boundingRect, viewHeight*/
    393216) {
      $: $$invalidate(25, y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    32768 | $$self.$$.dirty[1] & /*viewWidth*/
    524288) {
      $: $$invalidate(24, viewboxWidth = viewWidth + offset * 2);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    32768 | $$self.$$.dirty[1] & /*viewHeight*/
    262144) {
      $: $$invalidate(23, viewboxHeight = viewHeight + offset * 2);
    }
  };
  return [
    position,
    ariaLabel,
    nodeBorderRadius,
    nodeStrokeWidth,
    bgColor,
    maskColor,
    maskStrokeColor,
    maskStrokeWidth,
    pannable,
    zoomable,
    inversePan,
    zoomStep,
    style,
    className,
    viewScale,
    offset,
    elementHeight,
    elementWidth,
    viewBB,
    $nodes,
    $nodeLookup,
    $containerHeight,
    $containerWidth,
    viewboxHeight,
    viewboxWidth,
    y,
    x,
    $panZoom,
    $translateExtent,
    nodes,
    nodeLookup,
    viewport,
    containerWidth,
    containerHeight,
    flowId,
    panZoom,
    translateExtent,
    nodeColorFunc,
    nodeStrokeColorFunc,
    nodeClassFunc,
    shapeRendering,
    labelledBy,
    getViewScale,
    nodeStrokeColor,
    nodeColor,
    nodeClass,
    width,
    height,
    boundingRect,
    viewHeight,
    viewWidth,
    scaledHeight,
    scaledWidth,
    $viewport
  ];
}
var Minimap = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance48,
      create_fragment48,
      safe_not_equal,
      {
        position: 0,
        ariaLabel: 1,
        nodeStrokeColor: 43,
        nodeColor: 44,
        nodeClass: 45,
        nodeBorderRadius: 2,
        nodeStrokeWidth: 3,
        bgColor: 4,
        maskColor: 5,
        maskStrokeColor: 6,
        maskStrokeWidth: 7,
        width: 46,
        height: 47,
        pannable: 8,
        zoomable: 9,
        inversePan: 10,
        zoomStep: 11,
        style: 12,
        class: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minimap",
      options,
      id: create_fragment48.name
    });
  }
  get position() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeStrokeColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeStrokeColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeClass() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeClass(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeBorderRadius() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeBorderRadius(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeStrokeWidth() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeStrokeWidth(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskStrokeColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskStrokeColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskStrokeWidth() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskStrokeWidth(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pannable() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pannable(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomable() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomable(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inversePan() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inversePan(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomStep() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomStep(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Minimap_default = Minimap;

// node_modules/@xyflow/svelte/dist/lib/utils/index.js
var isNode = (element2) => isNodeBase(element2);
var isEdge = (element2) => isEdgeBase(element2);

// node_modules/@xyflow/svelte/dist/lib/hooks/useSvelteFlow.js
function useSvelteFlow() {
  const { zoomIn, zoomOut, fitView: fitView2, onbeforedelete, snapGrid, viewport, width, height, minZoom, maxZoom, panZoom, nodes, edges, domNode, nodeLookup, nodeOrigin, edgeLookup, connectionLookup } = useStore();
  const getNodeRect = (node) => {
    var _a, _b;
    const $nodeLookup = get_store_value(nodeLookup);
    const nodeToUse = isNode(node) ? node : $nodeLookup.get(node.id);
    const position = nodeToUse.parentId ? evaluateAbsolutePosition(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, $nodeLookup, get_store_value(nodeOrigin)) : nodeToUse.position;
    const nodeWithPosition = {
      id: nodeToUse.id,
      position,
      width: ((_a = nodeToUse.measured) == null ? void 0 : _a.width) ?? nodeToUse.width,
      height: ((_b = nodeToUse.measured) == null ? void 0 : _b.height) ?? nodeToUse.height,
      data: nodeToUse.data
    };
    return nodeToRect(nodeWithPosition);
  };
  const updateNode = (id, nodeUpdate, options = { replace: false }) => {
    var _a;
    const node = (_a = get_store_value(nodeLookup).get(id)) == null ? void 0 : _a.internals.userNode;
    if (!node) {
      return;
    }
    const nextNode = typeof nodeUpdate === "function" ? nodeUpdate(node) : nodeUpdate;
    if (options.replace) {
      nodes.update((nds) => nds.map((node2) => {
        if (node2.id === id) {
          return isNode(nextNode) ? nextNode : { ...node2, ...nextNode };
        }
        return node2;
      }));
    } else {
      Object.assign(node, nextNode);
      nodes.update((nds) => nds);
    }
  };
  const getInternalNode = (id) => get_store_value(nodeLookup).get(id);
  return {
    zoomIn,
    zoomOut,
    getInternalNode,
    getNode: (id) => {
      var _a;
      return (_a = getInternalNode(id)) == null ? void 0 : _a.internals.userNode;
    },
    getNodes: (ids) => ids === void 0 ? get_store_value(nodes) : getElements(get_store_value(nodeLookup), ids),
    getEdge: (id) => get_store_value(edgeLookup).get(id),
    getEdges: (ids) => ids === void 0 ? get_store_value(edges) : getElements(get_store_value(edgeLookup), ids),
    setZoom: (zoomLevel, options) => {
      const currentPanZoom = get_store_value(panZoom);
      return currentPanZoom ? currentPanZoom.scaleTo(zoomLevel, { duration: options == null ? void 0 : options.duration }) : Promise.resolve(false);
    },
    getZoom: () => get_store_value(viewport).zoom,
    setViewport: async (nextViewport, options) => {
      const currentViewport = get_store_value(viewport);
      const currentPanZoom = get_store_value(panZoom);
      if (!currentPanZoom) {
        return Promise.resolve(false);
      }
      await currentPanZoom.setViewport({
        x: nextViewport.x ?? currentViewport.x,
        y: nextViewport.y ?? currentViewport.y,
        zoom: nextViewport.zoom ?? currentViewport.zoom
      }, { duration: options == null ? void 0 : options.duration });
      return Promise.resolve(true);
    },
    getViewport: () => get_store_value(viewport),
    setCenter: async (x, y, options) => {
      const nextZoom = typeof (options == null ? void 0 : options.zoom) !== "undefined" ? options.zoom : get_store_value(maxZoom);
      const currentPanZoom = get_store_value(panZoom);
      if (!currentPanZoom) {
        return Promise.resolve(false);
      }
      await currentPanZoom.setViewport({
        x: get_store_value(width) / 2 - x * nextZoom,
        y: get_store_value(height) / 2 - y * nextZoom,
        zoom: nextZoom
      }, { duration: options == null ? void 0 : options.duration });
      return Promise.resolve(true);
    },
    fitView: fitView2,
    fitBounds: async (bounds, options) => {
      const currentPanZoom = get_store_value(panZoom);
      if (!currentPanZoom) {
        return Promise.resolve(false);
      }
      const viewport2 = getViewportForBounds(bounds, get_store_value(width), get_store_value(height), get_store_value(minZoom), get_store_value(maxZoom), (options == null ? void 0 : options.padding) ?? 0.1);
      await currentPanZoom.setViewport(viewport2, { duration: options == null ? void 0 : options.duration });
      return Promise.resolve(true);
    },
    getIntersectingNodes: (nodeOrRect, partially = true, nodesToIntersect) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return [];
      }
      return (nodesToIntersect || get_store_value(nodes)).filter((n) => {
        const internalNode = get_store_value(nodeLookup).get(n.id);
        if (!internalNode || !isRect && n.id === nodeOrRect.id) {
          return false;
        }
        const currNodeRect = nodeToRect(internalNode);
        const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
        const partiallyVisible = partially && overlappingArea > 0;
        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
      });
    },
    isNodeIntersecting: (nodeOrRect, area, partially = true) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return false;
      }
      const overlappingArea = getOverlappingArea(nodeRect, area);
      const partiallyVisible = partially && overlappingArea > 0;
      return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
    },
    deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] }) => {
      const { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
        nodesToRemove,
        edgesToRemove,
        nodes: get_store_value(nodes),
        edges: get_store_value(edges),
        onBeforeDelete: get_store_value(onbeforedelete)
      });
      if (matchingNodes) {
        nodes.update((nds) => nds.filter((node) => !matchingNodes.some(({ id }) => id === node.id)));
      }
      if (matchingEdges) {
        edges.update((eds) => eds.filter((edge) => !matchingEdges.some(({ id }) => id === edge.id)));
      }
      return {
        deletedNodes: matchingNodes,
        deletedEdges: matchingEdges
      };
    },
    screenToFlowPosition: (position, options = { snapToGrid: true }) => {
      const _domNode = get_store_value(domNode);
      if (!_domNode) {
        return position;
      }
      const _snapGrid = options.snapToGrid ? get_store_value(snapGrid) : false;
      const { x, y, zoom: zoom2 } = get_store_value(viewport);
      const { x: domX, y: domY } = _domNode.getBoundingClientRect();
      const correctedPosition = {
        x: position.x - domX,
        y: position.y - domY
      };
      return pointToRendererPoint(correctedPosition, [x, y, zoom2], _snapGrid !== null, _snapGrid || [1, 1]);
    },
    /**
     *
     * @param position
     * @returns
     */
    flowToScreenPosition: (position) => {
      const _domNode = get_store_value(domNode);
      if (!_domNode) {
        return position;
      }
      const { x, y, zoom: zoom2 } = get_store_value(viewport);
      const { x: domX, y: domY } = _domNode.getBoundingClientRect();
      const rendererPosition = rendererPointToPoint(position, [x, y, zoom2]);
      return {
        x: rendererPosition.x + domX,
        y: rendererPosition.y + domY
      };
    },
    toObject: () => {
      return {
        nodes: get_store_value(nodes).map((node) => ({
          ...node,
          // we want to make sure that changes to the nodes object that gets returned by toObject
          // do not affect the nodes object
          position: { ...node.position },
          data: { ...node.data }
        })),
        edges: get_store_value(edges).map((edge) => ({ ...edge })),
        viewport: { ...get_store_value(viewport) }
      };
    },
    updateNode,
    updateNodeData: (id, dataUpdate, options) => {
      var _a;
      const node = (_a = get_store_value(nodeLookup).get(id)) == null ? void 0 : _a.internals.userNode;
      if (!node) {
        return;
      }
      const nextData = typeof dataUpdate === "function" ? dataUpdate(node) : dataUpdate;
      node.data = (options == null ? void 0 : options.replace) ? nextData : { ...node.data, ...nextData };
      nodes.update((nds) => nds);
    },
    getNodesBounds: (nodes2) => {
      const _nodeLookup = get_store_value(nodeLookup);
      const _nodeOrigin = get_store_value(nodeOrigin);
      return getNodesBounds(nodes2, { nodeLookup: _nodeLookup, nodeOrigin: _nodeOrigin });
    },
    getHandleConnections: ({ type, id, nodeId }) => {
      var _a;
      return Array.from(((_a = get_store_value(connectionLookup).get(`${nodeId}-${type}-${id ?? null}`)) == null ? void 0 : _a.values()) ?? []);
    },
    viewport
  };
}
function getElements(lookup, ids) {
  var _a;
  const result = [];
  for (const id of ids) {
    const item = lookup.get(id);
    if (item) {
      const element2 = "internals" in item ? (_a = item.internals) == null ? void 0 : _a.userNode : item;
      result.push(element2);
    }
  }
  return result;
}

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeToolbar/NodeToolbar.svelte
var file32 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\NodeToolbar\\NodeToolbar.svelte";
function create_if_block13(ctx) {
  let div;
  let div_data_id_value;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-id": true, class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-id", div_data_id_value = /*toolbarNodes*/
      ctx[0].reduce(func, "").trim());
      attr_dev(div, "class", "svelte-flow__node-toolbar");
      set_style(div, "position", `absolute`);
      set_style(
        div,
        "transform",
        /*transform*/
        ctx[1]
      );
      set_style(
        div,
        "z-index",
        /*zIndex*/
        ctx[3]
      );
      add_location(div, file32, 50, 2, 1921);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal_default.call(null, div, { domNode: (
          /*$domNode*/
          ctx[4]
        ) }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*toolbarNodes*/
      1 && div_data_id_value !== (div_data_id_value = /*toolbarNodes*/
      ctx2[0].reduce(func, "").trim())) {
        attr_dev(div, "data-id", div_data_id_value);
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*$domNode*/
      16) portal_action.update.call(null, { domNode: (
        /*$domNode*/
        ctx2[4]
      ) });
      if (dirty & /*transform*/
      2) {
        set_style(
          div,
          "transform",
          /*transform*/
          ctx2[1]
        );
      }
      if (dirty & /*zIndex*/
      8) {
        set_style(
          div,
          "z-index",
          /*zIndex*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(50:0) {#if $domNode && isActive && toolbarNodes}",
    ctx
  });
  return block;
}
function create_fragment49(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$domNode*/
    ctx[4] && /*isActive*/
    ctx[2] && /*toolbarNodes*/
    ctx[0] && create_if_block13(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$domNode*/
        ctx2[4] && /*isActive*/
        ctx2[2] && /*toolbarNodes*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$domNode, isActive, toolbarNodes*/
          21) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = (acc, node) => `${acc}${node.id} `;
function instance49($$self, $$props, $$invalidate) {
  let zIndex;
  let selectedNodesCount;
  let isActive;
  let $nodes;
  let $viewport;
  let $nodeLookup;
  let $domNode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeToolbar", slots, ["default"]);
  let { nodeId = void 0 } = $$props;
  let { position = void 0 } = $$props;
  let { align = void 0 } = $$props;
  let { offset = void 0 } = $$props;
  let { isVisible = void 0 } = $$props;
  const { domNode, viewport, nodeLookup, nodes } = useStore();
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(4, $domNode = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(16, $viewport = value));
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(17, $nodeLookup = value));
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(15, $nodes = value));
  const { getNodesBounds: getNodesBounds2 } = useSvelteFlow();
  const contextNodeId = getContext("svelteflow__node_id");
  let transform2;
  let toolbarNodes = [];
  let _offset = offset !== void 0 ? offset : 10;
  let _position = position !== void 0 ? position : Position.Top;
  let _align = align !== void 0 ? align : "center";
  const writable_props = ["nodeId", "position", "align", "offset", "isVisible"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<NodeToolbar> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(9, nodeId = $$props2.nodeId);
    if ("position" in $$props2) $$invalidate(10, position = $$props2.position);
    if ("align" in $$props2) $$invalidate(11, align = $$props2.align);
    if ("offset" in $$props2) $$invalidate(12, offset = $$props2.offset);
    if ("isVisible" in $$props2) $$invalidate(13, isVisible = $$props2.isVisible);
    if ("$$scope" in $$props2) $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    Position,
    getNodeToolbarTransform,
    portal: portal_default,
    useStore,
    useSvelteFlow,
    nodeId,
    position,
    align,
    offset,
    isVisible,
    domNode,
    viewport,
    nodeLookup,
    nodes,
    getNodesBounds: getNodesBounds2,
    contextNodeId,
    transform: transform2,
    toolbarNodes,
    _offset,
    _position,
    _align,
    selectedNodesCount,
    isActive,
    zIndex,
    $nodes,
    $viewport,
    $nodeLookup,
    $domNode
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(9, nodeId = $$props2.nodeId);
    if ("position" in $$props2) $$invalidate(10, position = $$props2.position);
    if ("align" in $$props2) $$invalidate(11, align = $$props2.align);
    if ("offset" in $$props2) $$invalidate(12, offset = $$props2.offset);
    if ("isVisible" in $$props2) $$invalidate(13, isVisible = $$props2.isVisible);
    if ("transform" in $$props2) $$invalidate(1, transform2 = $$props2.transform);
    if ("toolbarNodes" in $$props2) $$invalidate(0, toolbarNodes = $$props2.toolbarNodes);
    if ("_offset" in $$props2) $$invalidate(22, _offset = $$props2._offset);
    if ("_position" in $$props2) $$invalidate(23, _position = $$props2._position);
    if ("_align" in $$props2) $$invalidate(24, _align = $$props2._align);
    if ("selectedNodesCount" in $$props2) $$invalidate(14, selectedNodesCount = $$props2.selectedNodesCount);
    if ("isActive" in $$props2) $$invalidate(2, isActive = $$props2.isActive);
    if ("zIndex" in $$props2) $$invalidate(3, zIndex = $$props2.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$nodes, nodeId, $nodeLookup*/
    164352) {
      $: {
        $nodes;
        const nodeIds = Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId];
        $$invalidate(0, toolbarNodes = nodeIds.reduce(
          (res, nodeId2) => {
            const node = $nodeLookup.get(nodeId2);
            if (node) {
              res.push(node);
            }
            return res;
          },
          []
        ));
      }
    }
    if ($$self.$$.dirty & /*toolbarNodes, $viewport*/
    65537) {
      $: {
        const nodeRect = getNodesBounds2(toolbarNodes);
        if (nodeRect) {
          $$invalidate(1, transform2 = getNodeToolbarTransform(nodeRect, $viewport, _position, _offset, _align));
        }
      }
    }
    if ($$self.$$.dirty & /*toolbarNodes*/
    1) {
      $: $$invalidate(3, zIndex = toolbarNodes.length === 0 ? 1 : Math.max(...toolbarNodes.map((node) => (node.internals.z || 5) + 1)));
    }
    if ($$self.$$.dirty & /*$nodes*/
    32768) {
      $: $$invalidate(14, selectedNodesCount = $nodes.filter((node) => node.selected).length);
    }
    if ($$self.$$.dirty & /*isVisible, toolbarNodes, selectedNodesCount*/
    24577) {
      $: $$invalidate(2, isActive = typeof isVisible === "boolean" ? isVisible : toolbarNodes.length === 1 && toolbarNodes[0].selected && selectedNodesCount === 1);
    }
  };
  return [
    toolbarNodes,
    transform2,
    isActive,
    zIndex,
    $domNode,
    domNode,
    viewport,
    nodeLookup,
    nodes,
    nodeId,
    position,
    align,
    offset,
    isVisible,
    selectedNodesCount,
    $nodes,
    $viewport,
    $nodeLookup,
    $$scope,
    slots
  ];
}
var NodeToolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {
      nodeId: 9,
      position: 10,
      align: 11,
      offset: 12,
      isVisible: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeToolbar",
      options,
      id: create_fragment49.name
    });
  }
  get nodeId() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeId(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeToolbar_default = NodeToolbar;

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/ResizeControl.svelte
var file33 = "node_modules\\@xyflow\\svelte\\dist\\lib\\plugins\\NodeResizer\\ResizeControl.svelte";
function create_fragment50(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[33].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = cc([
        "svelte-flow__resize-control",
        "nodrag",
        .../*positionClassNames*/
        ctx[4],
        /*variant*/
        ctx[0],
        /*className*/
        ctx[1]
      ]));
      attr_dev(
        div,
        "style",
        /*controlStyle*/
        ctx[3]
      );
      add_location(div, file33, 93, 0, 3323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[34](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*positionClassNames, variant, className*/
      19 && div_class_value !== (div_class_value = cc([
        "svelte-flow__resize-control",
        "nodrag",
        .../*positionClassNames*/
        ctx2[4],
        /*variant*/
        ctx2[0],
        /*className*/
        ctx2[1]
      ]))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*controlStyle*/
      8) {
        attr_dev(
          div,
          "style",
          /*controlStyle*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[34](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let _minWidth;
  let _minHeight;
  let _maxWidth;
  let _maxHeight;
  let id;
  let defaultPosition;
  let controlPosition;
  let positionClassNames;
  let colorStyleProp;
  let _style;
  let controlStyle;
  let $nodes;
  let $nodeLookup;
  let $nodeOrigin;
  let $snapGrid;
  let $viewport;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ResizeControl", slots, ["default"]);
  let { nodeId = void 0 } = $$props;
  let { position = void 0 } = $$props;
  let { variant = ResizeControlVariant.Handle } = $$props;
  let { color = void 0 } = $$props;
  let { minWidth = 10 } = $$props;
  let { minHeight = 10 } = $$props;
  let { maxWidth = Number.MAX_VALUE } = $$props;
  let { maxHeight = Number.MAX_VALUE } = $$props;
  let { keepAspectRatio = false } = $$props;
  let { shouldResize = void 0 } = $$props;
  let { onResizeStart = void 0 } = $$props;
  let { onResize = void 0 } = $$props;
  let { onResizeEnd = void 0 } = $$props;
  let { style = "" } = $$props;
  let { class: className = "" } = $$props;
  const { nodeLookup, snapGrid, viewport, nodes, nodeOrigin } = useStore();
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(37, $nodeLookup = value));
  validate_store(snapGrid, "snapGrid");
  component_subscribe($$self, snapGrid, (value) => $$invalidate(39, $snapGrid = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(40, $viewport = value));
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(36, $nodes = value));
  validate_store(nodeOrigin, "nodeOrigin");
  component_subscribe($$self, nodeOrigin, (value) => $$invalidate(38, $nodeOrigin = value));
  const contextNodeId = getContext("svelteflow__node_id");
  let resizeControlRef;
  let resizer = null;
  onMount(() => {
    if (resizeControlRef) {
      $$invalidate(23, resizer = XYResizer({
        domNode: resizeControlRef,
        nodeId: id,
        getStoreItems: () => {
          return {
            nodeLookup: $nodeLookup,
            transform: [$viewport.x, $viewport.y, $viewport.zoom],
            snapGrid: $snapGrid ?? void 0,
            snapToGrid: !!$snapGrid,
            nodeOrigin: $nodeOrigin
          };
        },
        onChange: (change, childChanges) => {
          var _a, _b;
          const node = (_a = $nodeLookup.get(id)) == null ? void 0 : _a.internals.userNode;
          if (!node) {
            return;
          }
          if (change.x !== void 0 && change.y !== void 0) {
            node.position = { x: change.x, y: change.y };
          }
          if (change.width !== void 0 && change.height !== void 0) {
            node.width = change.width;
            node.height = change.height;
          }
          for (const childChange of childChanges) {
            const childNode = (_b = $nodeLookup.get(childChange.id)) == null ? void 0 : _b.internals.userNode;
            if (childNode) {
              childNode.position = childChange.position;
            }
          }
          nodes.set($nodes);
        }
      }));
    }
    return () => {
      resizer == null ? void 0 : resizer.destroy();
    };
  });
  const writable_props = [
    "nodeId",
    "position",
    "variant",
    "color",
    "minWidth",
    "minHeight",
    "maxWidth",
    "maxHeight",
    "keepAspectRatio",
    "shouldResize",
    "onResizeStart",
    "onResize",
    "onResizeEnd",
    "style",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<ResizeControl> was created with unknown prop '${key2}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      resizeControlRef = $$value;
      $$invalidate(2, resizeControlRef);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(10, nodeId = $$props2.nodeId);
    if ("position" in $$props2) $$invalidate(11, position = $$props2.position);
    if ("variant" in $$props2) $$invalidate(0, variant = $$props2.variant);
    if ("color" in $$props2) $$invalidate(12, color = $$props2.color);
    if ("minWidth" in $$props2) $$invalidate(13, minWidth = $$props2.minWidth);
    if ("minHeight" in $$props2) $$invalidate(14, minHeight = $$props2.minHeight);
    if ("maxWidth" in $$props2) $$invalidate(15, maxWidth = $$props2.maxWidth);
    if ("maxHeight" in $$props2) $$invalidate(16, maxHeight = $$props2.maxHeight);
    if ("keepAspectRatio" in $$props2) $$invalidate(17, keepAspectRatio = $$props2.keepAspectRatio);
    if ("shouldResize" in $$props2) $$invalidate(18, shouldResize = $$props2.shouldResize);
    if ("onResizeStart" in $$props2) $$invalidate(19, onResizeStart = $$props2.onResizeStart);
    if ("onResize" in $$props2) $$invalidate(20, onResize = $$props2.onResize);
    if ("onResizeEnd" in $$props2) $$invalidate(21, onResizeEnd = $$props2.onResizeEnd);
    if ("style" in $$props2) $$invalidate(22, style = $$props2.style);
    if ("class" in $$props2) $$invalidate(1, className = $$props2.class);
    if ("$$scope" in $$props2) $$invalidate(32, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    cc,
    useStore,
    XYResizer,
    ResizeControlVariant,
    nodeId,
    position,
    variant,
    color,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    shouldResize,
    onResizeStart,
    onResize,
    onResizeEnd,
    style,
    className,
    nodeLookup,
    snapGrid,
    viewport,
    nodes,
    nodeOrigin,
    contextNodeId,
    resizeControlRef,
    resizer,
    _maxHeight,
    _maxWidth,
    _minHeight,
    _minWidth,
    controlPosition,
    id,
    _style,
    colorStyleProp,
    controlStyle,
    positionClassNames,
    defaultPosition,
    $nodes,
    $nodeLookup,
    $nodeOrigin,
    $snapGrid,
    $viewport
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(10, nodeId = $$props2.nodeId);
    if ("position" in $$props2) $$invalidate(11, position = $$props2.position);
    if ("variant" in $$props2) $$invalidate(0, variant = $$props2.variant);
    if ("color" in $$props2) $$invalidate(12, color = $$props2.color);
    if ("minWidth" in $$props2) $$invalidate(13, minWidth = $$props2.minWidth);
    if ("minHeight" in $$props2) $$invalidate(14, minHeight = $$props2.minHeight);
    if ("maxWidth" in $$props2) $$invalidate(15, maxWidth = $$props2.maxWidth);
    if ("maxHeight" in $$props2) $$invalidate(16, maxHeight = $$props2.maxHeight);
    if ("keepAspectRatio" in $$props2) $$invalidate(17, keepAspectRatio = $$props2.keepAspectRatio);
    if ("shouldResize" in $$props2) $$invalidate(18, shouldResize = $$props2.shouldResize);
    if ("onResizeStart" in $$props2) $$invalidate(19, onResizeStart = $$props2.onResizeStart);
    if ("onResize" in $$props2) $$invalidate(20, onResize = $$props2.onResize);
    if ("onResizeEnd" in $$props2) $$invalidate(21, onResizeEnd = $$props2.onResizeEnd);
    if ("style" in $$props2) $$invalidate(22, style = $$props2.style);
    if ("className" in $$props2) $$invalidate(1, className = $$props2.className);
    if ("resizeControlRef" in $$props2) $$invalidate(2, resizeControlRef = $$props2.resizeControlRef);
    if ("resizer" in $$props2) $$invalidate(23, resizer = $$props2.resizer);
    if ("_maxHeight" in $$props2) $$invalidate(24, _maxHeight = $$props2._maxHeight);
    if ("_maxWidth" in $$props2) $$invalidate(25, _maxWidth = $$props2._maxWidth);
    if ("_minHeight" in $$props2) $$invalidate(26, _minHeight = $$props2._minHeight);
    if ("_minWidth" in $$props2) $$invalidate(27, _minWidth = $$props2._minWidth);
    if ("controlPosition" in $$props2) $$invalidate(28, controlPosition = $$props2.controlPosition);
    if ("id" in $$props2) id = $$props2.id;
    if ("_style" in $$props2) $$invalidate(29, _style = $$props2._style);
    if ("colorStyleProp" in $$props2) $$invalidate(30, colorStyleProp = $$props2.colorStyleProp);
    if ("controlStyle" in $$props2) $$invalidate(3, controlStyle = $$props2.controlStyle);
    if ("positionClassNames" in $$props2) $$invalidate(4, positionClassNames = $$props2.positionClassNames);
    if ("defaultPosition" in $$props2) $$invalidate(31, defaultPosition = $$props2.defaultPosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*minWidth*/
    8192) {
      $: $$invalidate(27, _minWidth = minWidth ?? 10);
    }
    if ($$self.$$.dirty[0] & /*minHeight*/
    16384) {
      $: $$invalidate(26, _minHeight = minHeight ?? 10);
    }
    if ($$self.$$.dirty[0] & /*maxWidth*/
    32768) {
      $: $$invalidate(25, _maxWidth = maxWidth ?? Number.MAX_VALUE);
    }
    if ($$self.$$.dirty[0] & /*maxHeight*/
    65536) {
      $: $$invalidate(24, _maxHeight = maxHeight ?? Number.MAX_VALUE);
    }
    if ($$self.$$.dirty[0] & /*nodeId*/
    1024) {
      $: id = typeof nodeId === "string" ? nodeId : contextNodeId;
    }
    if ($$self.$$.dirty[0] & /*variant*/
    1) {
      $: $$invalidate(31, defaultPosition = variant === ResizeControlVariant.Line ? "right" : "bottom-right");
    }
    if ($$self.$$.dirty[0] & /*position*/
    2048 | $$self.$$.dirty[1] & /*defaultPosition*/
    1) {
      $: $$invalidate(28, controlPosition = position ?? defaultPosition);
    }
    if ($$self.$$.dirty[0] & /*controlPosition*/
    268435456) {
      $: $$invalidate(4, positionClassNames = controlPosition.split("-"));
    }
    if ($$self.$$.dirty[0] & /*variant*/
    1) {
      $: $$invalidate(30, colorStyleProp = variant === ResizeControlVariant.Line ? "border-color" : "background-color");
    }
    if ($$self.$$.dirty[0] & /*style*/
    4194304) {
      $: $$invalidate(29, _style = style ?? "");
    }
    if ($$self.$$.dirty[0] & /*color, _style, colorStyleProp*/
    1610616832) {
      $: $$invalidate(3, controlStyle = color ? `${_style} ${colorStyleProp}: ${color};` : _style);
    }
    if ($$self.$$.dirty[0] & /*resizer, controlPosition, _minWidth, _minHeight, _maxWidth, _maxHeight, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize*/
    532545536) {
      $: {
        resizer == null ? void 0 : resizer.update({
          controlPosition,
          boundaries: {
            minWidth: _minWidth,
            minHeight: _minHeight,
            maxWidth: _maxWidth,
            maxHeight: _maxHeight
          },
          keepAspectRatio: !!keepAspectRatio,
          onResizeStart,
          onResize,
          onResizeEnd,
          shouldResize
        });
      }
    }
  };
  return [
    variant,
    className,
    resizeControlRef,
    controlStyle,
    positionClassNames,
    nodeLookup,
    snapGrid,
    viewport,
    nodes,
    nodeOrigin,
    nodeId,
    position,
    color,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    shouldResize,
    onResizeStart,
    onResize,
    onResizeEnd,
    style,
    resizer,
    _maxHeight,
    _maxWidth,
    _minHeight,
    _minWidth,
    controlPosition,
    _style,
    colorStyleProp,
    defaultPosition,
    $$scope,
    slots,
    div_binding
  ];
}
var ResizeControl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance50,
      create_fragment50,
      safe_not_equal,
      {
        nodeId: 10,
        position: 11,
        variant: 0,
        color: 12,
        minWidth: 13,
        minHeight: 14,
        maxWidth: 15,
        maxHeight: 16,
        keepAspectRatio: 17,
        shouldResize: 18,
        onResizeStart: 19,
        onResize: 20,
        onResizeEnd: 21,
        style: 22,
        class: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ResizeControl",
      options,
      id: create_fragment50.name
    });
  }
  get nodeId() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeId(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minWidth() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minWidth(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minHeight() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minHeight(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxWidth() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxWidth(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxHeight() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxHeight(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepAspectRatio() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepAspectRatio(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldResize() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldResize(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResizeStart() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResizeStart(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResize() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResize(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResizeEnd() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResizeEnd(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ResizeControl_default = ResizeControl;

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/NodeResizer.svelte
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function create_if_block14(ctx) {
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let each1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(XY_RESIZER_LINE_POSITIONS);
  const get_key = (ctx2) => (
    /*position*/
    ctx2[20]
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key2 = get_key(child_ctx);
    each0_lookup.set(key2, each_blocks_1[i] = create_each_block_1(key2, child_ctx));
  }
  let each_value = ensure_array_like_dev(XY_RESIZER_HANDLE_POSITIONS);
  const get_key_1 = (ctx2) => (
    /*position*/
    ctx2[20]
  );
  validate_each_keys(ctx, each_value, get_each_context5, get_key_1);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context5(ctx, each_value, i);
    let key2 = get_key_1(child_ctx);
    each1_lookup.set(key2, each_blocks[i] = create_each_block5(key2, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(nodes);
      }
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*lineClass, lineStyle, nodeId, color, _minWidth, _minHeight, _maxWidth, _maxHeight, onResizeStart, keepAspectRatio, shouldResize, onResize, onResizeEnd*/
      65521) {
        each_value_1 = ensure_array_like_dev(XY_RESIZER_LINE_POSITIONS);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, t.parentNode, outro_and_destroy_block, create_each_block_1, t, get_each_context_1);
        check_outros();
      }
      if (dirty & /*handleClass, handleStyle, nodeId, color, _minWidth, _minHeight, _maxWidth, _maxHeight, onResizeStart, keepAspectRatio, shouldResize, onResize, onResizeEnd*/
      65485) {
        each_value = ensure_array_like_dev(XY_RESIZER_HANDLE_POSITIONS);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context5, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value, each1_lookup, each1_anchor.parentNode, outro_and_destroy_block, create_each_block5, each1_anchor, get_each_context5);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(each1_anchor);
      }
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d(detaching);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(25:0) {#if isVisible}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let resizecontrol;
  let current;
  resizecontrol = new ResizeControl_default({
    props: {
      class: (
        /*lineClass*/
        ctx[4]
      ),
      style: (
        /*lineStyle*/
        ctx[5]
      ),
      nodeId: (
        /*nodeId*/
        ctx[0]
      ),
      position: (
        /*position*/
        ctx[20]
      ),
      variant: ResizeControlVariant.Line,
      color: (
        /*color*/
        ctx[6]
      ),
      minWidth: (
        /*_minWidth*/
        ctx[12]
      ),
      minHeight: (
        /*_minHeight*/
        ctx[13]
      ),
      maxWidth: (
        /*_maxWidth*/
        ctx[14]
      ),
      maxHeight: (
        /*_maxHeight*/
        ctx[15]
      ),
      onResizeStart: (
        /*onResizeStart*/
        ctx[9]
      ),
      keepAspectRatio: (
        /*keepAspectRatio*/
        ctx[7]
      ),
      shouldResize: (
        /*shouldResize*/
        ctx[8]
      ),
      onResize: (
        /*onResize*/
        ctx[10]
      ),
      onResizeEnd: (
        /*onResizeEnd*/
        ctx[11]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(resizecontrol.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(resizecontrol.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(resizecontrol, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const resizecontrol_changes = {};
      if (dirty & /*lineClass*/
      16) resizecontrol_changes.class = /*lineClass*/
      ctx[4];
      if (dirty & /*lineStyle*/
      32) resizecontrol_changes.style = /*lineStyle*/
      ctx[5];
      if (dirty & /*nodeId*/
      1) resizecontrol_changes.nodeId = /*nodeId*/
      ctx[0];
      if (dirty & /*color*/
      64) resizecontrol_changes.color = /*color*/
      ctx[6];
      if (dirty & /*onResizeStart*/
      512) resizecontrol_changes.onResizeStart = /*onResizeStart*/
      ctx[9];
      if (dirty & /*keepAspectRatio*/
      128) resizecontrol_changes.keepAspectRatio = /*keepAspectRatio*/
      ctx[7];
      if (dirty & /*shouldResize*/
      256) resizecontrol_changes.shouldResize = /*shouldResize*/
      ctx[8];
      if (dirty & /*onResize*/
      1024) resizecontrol_changes.onResize = /*onResize*/
      ctx[10];
      if (dirty & /*onResizeEnd*/
      2048) resizecontrol_changes.onResizeEnd = /*onResizeEnd*/
      ctx[11];
      resizecontrol.$set(resizecontrol_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(resizecontrol.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(resizecontrol.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(resizecontrol, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(26:2) {#each XY_RESIZER_LINE_POSITIONS as position (position)}",
    ctx
  });
  return block;
}
function create_each_block5(key_1, ctx) {
  let first;
  let resizecontrol;
  let current;
  resizecontrol = new ResizeControl_default({
    props: {
      class: (
        /*handleClass*/
        ctx[2]
      ),
      style: (
        /*handleStyle*/
        ctx[3]
      ),
      nodeId: (
        /*nodeId*/
        ctx[0]
      ),
      position: (
        /*position*/
        ctx[20]
      ),
      color: (
        /*color*/
        ctx[6]
      ),
      minWidth: (
        /*_minWidth*/
        ctx[12]
      ),
      minHeight: (
        /*_minHeight*/
        ctx[13]
      ),
      maxWidth: (
        /*_maxWidth*/
        ctx[14]
      ),
      maxHeight: (
        /*_maxHeight*/
        ctx[15]
      ),
      onResizeStart: (
        /*onResizeStart*/
        ctx[9]
      ),
      keepAspectRatio: (
        /*keepAspectRatio*/
        ctx[7]
      ),
      shouldResize: (
        /*shouldResize*/
        ctx[8]
      ),
      onResize: (
        /*onResize*/
        ctx[10]
      ),
      onResizeEnd: (
        /*onResizeEnd*/
        ctx[11]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(resizecontrol.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(resizecontrol.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(resizecontrol, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const resizecontrol_changes = {};
      if (dirty & /*handleClass*/
      4) resizecontrol_changes.class = /*handleClass*/
      ctx[2];
      if (dirty & /*handleStyle*/
      8) resizecontrol_changes.style = /*handleStyle*/
      ctx[3];
      if (dirty & /*nodeId*/
      1) resizecontrol_changes.nodeId = /*nodeId*/
      ctx[0];
      if (dirty & /*color*/
      64) resizecontrol_changes.color = /*color*/
      ctx[6];
      if (dirty & /*onResizeStart*/
      512) resizecontrol_changes.onResizeStart = /*onResizeStart*/
      ctx[9];
      if (dirty & /*keepAspectRatio*/
      128) resizecontrol_changes.keepAspectRatio = /*keepAspectRatio*/
      ctx[7];
      if (dirty & /*shouldResize*/
      256) resizecontrol_changes.shouldResize = /*shouldResize*/
      ctx[8];
      if (dirty & /*onResize*/
      1024) resizecontrol_changes.onResize = /*onResize*/
      ctx[10];
      if (dirty & /*onResizeEnd*/
      2048) resizecontrol_changes.onResizeEnd = /*onResizeEnd*/
      ctx[11];
      resizecontrol.$set(resizecontrol_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(resizecontrol.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(resizecontrol.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(resizecontrol, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(45:2) {#each XY_RESIZER_HANDLE_POSITIONS as position (position)}",
    ctx
  });
  return block;
}
function create_fragment51(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isVisible*/
    ctx[1] && create_if_block14(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isVisible*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isVisible*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeResizer", slots, []);
  let { nodeId = void 0 } = $$props;
  let { isVisible = true } = $$props;
  let { handleClass = void 0 } = $$props;
  let { handleStyle = void 0 } = $$props;
  let { lineClass = void 0 } = $$props;
  let { lineStyle = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { minWidth = 10 } = $$props;
  let { minHeight = 10 } = $$props;
  let { maxWidth = Number.MAX_VALUE } = $$props;
  let { maxHeight = Number.MAX_VALUE } = $$props;
  let { keepAspectRatio = false } = $$props;
  let { shouldResize = void 0 } = $$props;
  let { onResizeStart = void 0 } = $$props;
  let { onResize = void 0 } = $$props;
  let { onResizeEnd = void 0 } = $$props;
  let _minWidth = minWidth || 10;
  let _minHeight = minHeight || 10;
  let _maxWidth = maxWidth || Number.MAX_VALUE;
  let _maxHeight = maxHeight || Number.MAX_VALUE;
  const writable_props = [
    "nodeId",
    "isVisible",
    "handleClass",
    "handleStyle",
    "lineClass",
    "lineStyle",
    "color",
    "minWidth",
    "minHeight",
    "maxWidth",
    "maxHeight",
    "keepAspectRatio",
    "shouldResize",
    "onResizeStart",
    "onResize",
    "onResizeEnd"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<NodeResizer> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(0, nodeId = $$props2.nodeId);
    if ("isVisible" in $$props2) $$invalidate(1, isVisible = $$props2.isVisible);
    if ("handleClass" in $$props2) $$invalidate(2, handleClass = $$props2.handleClass);
    if ("handleStyle" in $$props2) $$invalidate(3, handleStyle = $$props2.handleStyle);
    if ("lineClass" in $$props2) $$invalidate(4, lineClass = $$props2.lineClass);
    if ("lineStyle" in $$props2) $$invalidate(5, lineStyle = $$props2.lineStyle);
    if ("color" in $$props2) $$invalidate(6, color = $$props2.color);
    if ("minWidth" in $$props2) $$invalidate(16, minWidth = $$props2.minWidth);
    if ("minHeight" in $$props2) $$invalidate(17, minHeight = $$props2.minHeight);
    if ("maxWidth" in $$props2) $$invalidate(18, maxWidth = $$props2.maxWidth);
    if ("maxHeight" in $$props2) $$invalidate(19, maxHeight = $$props2.maxHeight);
    if ("keepAspectRatio" in $$props2) $$invalidate(7, keepAspectRatio = $$props2.keepAspectRatio);
    if ("shouldResize" in $$props2) $$invalidate(8, shouldResize = $$props2.shouldResize);
    if ("onResizeStart" in $$props2) $$invalidate(9, onResizeStart = $$props2.onResizeStart);
    if ("onResize" in $$props2) $$invalidate(10, onResize = $$props2.onResize);
    if ("onResizeEnd" in $$props2) $$invalidate(11, onResizeEnd = $$props2.onResizeEnd);
  };
  $$self.$capture_state = () => ({
    ResizeControl: ResizeControl_default,
    ResizeControlVariant,
    XY_RESIZER_HANDLE_POSITIONS,
    XY_RESIZER_LINE_POSITIONS,
    nodeId,
    isVisible,
    handleClass,
    handleStyle,
    lineClass,
    lineStyle,
    color,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    shouldResize,
    onResizeStart,
    onResize,
    onResizeEnd,
    _minWidth,
    _minHeight,
    _maxWidth,
    _maxHeight
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(0, nodeId = $$props2.nodeId);
    if ("isVisible" in $$props2) $$invalidate(1, isVisible = $$props2.isVisible);
    if ("handleClass" in $$props2) $$invalidate(2, handleClass = $$props2.handleClass);
    if ("handleStyle" in $$props2) $$invalidate(3, handleStyle = $$props2.handleStyle);
    if ("lineClass" in $$props2) $$invalidate(4, lineClass = $$props2.lineClass);
    if ("lineStyle" in $$props2) $$invalidate(5, lineStyle = $$props2.lineStyle);
    if ("color" in $$props2) $$invalidate(6, color = $$props2.color);
    if ("minWidth" in $$props2) $$invalidate(16, minWidth = $$props2.minWidth);
    if ("minHeight" in $$props2) $$invalidate(17, minHeight = $$props2.minHeight);
    if ("maxWidth" in $$props2) $$invalidate(18, maxWidth = $$props2.maxWidth);
    if ("maxHeight" in $$props2) $$invalidate(19, maxHeight = $$props2.maxHeight);
    if ("keepAspectRatio" in $$props2) $$invalidate(7, keepAspectRatio = $$props2.keepAspectRatio);
    if ("shouldResize" in $$props2) $$invalidate(8, shouldResize = $$props2.shouldResize);
    if ("onResizeStart" in $$props2) $$invalidate(9, onResizeStart = $$props2.onResizeStart);
    if ("onResize" in $$props2) $$invalidate(10, onResize = $$props2.onResize);
    if ("onResizeEnd" in $$props2) $$invalidate(11, onResizeEnd = $$props2.onResizeEnd);
    if ("_minWidth" in $$props2) $$invalidate(12, _minWidth = $$props2._minWidth);
    if ("_minHeight" in $$props2) $$invalidate(13, _minHeight = $$props2._minHeight);
    if ("_maxWidth" in $$props2) $$invalidate(14, _maxWidth = $$props2._maxWidth);
    if ("_maxHeight" in $$props2) $$invalidate(15, _maxHeight = $$props2._maxHeight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nodeId,
    isVisible,
    handleClass,
    handleStyle,
    lineClass,
    lineStyle,
    color,
    keepAspectRatio,
    shouldResize,
    onResizeStart,
    onResize,
    onResizeEnd,
    _minWidth,
    _minHeight,
    _maxWidth,
    _maxHeight,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight
  ];
}
var NodeResizer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, {
      nodeId: 0,
      isVisible: 1,
      handleClass: 2,
      handleStyle: 3,
      lineClass: 4,
      lineStyle: 5,
      color: 6,
      minWidth: 16,
      minHeight: 17,
      maxWidth: 18,
      maxHeight: 19,
      keepAspectRatio: 7,
      shouldResize: 8,
      onResizeStart: 9,
      onResize: 10,
      onResizeEnd: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeResizer",
      options,
      id: create_fragment51.name
    });
  }
  get nodeId() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeId(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleClass() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handleClass(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleStyle() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handleStyle(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineClass() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineClass(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineStyle() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineStyle(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minWidth() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minWidth(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minHeight() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minHeight(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxWidth() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxWidth(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxHeight() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxHeight(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepAspectRatio() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepAspectRatio(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldResize() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldResize(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResizeStart() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResizeStart(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResize() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResize(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResizeEnd() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResizeEnd(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeResizer_default = NodeResizer;

// node_modules/@xyflow/svelte/dist/lib/hooks/useUpdateNodeInternals.js
function useUpdateNodeInternals() {
  const { domNode, updateNodeInternals: updateNodeInternals2 } = useStore();
  const updateInternals = (id) => {
    const updateIds = Array.isArray(id) ? id : [id];
    const updates = /* @__PURE__ */ new Map();
    updateIds.forEach((updateId) => {
      var _a;
      const nodeElement = (_a = get_store_value(domNode)) == null ? void 0 : _a.querySelector(`.svelte-flow__node[data-id="${updateId}"]`);
      if (nodeElement) {
        updates.set(updateId, { id: updateId, nodeElement, force: true });
      }
    });
    requestAnimationFrame(() => updateNodeInternals2(updates));
  };
  return updateInternals;
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useConnection.js
function useConnection() {
  const { connection } = useStore();
  return connection;
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodesEdges.js
function useNodes() {
  const { nodes } = useStore();
  return nodes;
}
function useEdges() {
  const { edges } = useStore();
  return edges;
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useHandleConnections.js
var initialConnections = [];
function useHandleConnections({ type, nodeId, id = null }) {
  const { edges, connectionLookup } = useStore();
  const _nodeId = getContext("svelteflow__node_id");
  const currentNodeId = nodeId ?? _nodeId;
  let prevConnections = void 0;
  return derived([edges, connectionLookup], ([, connectionLookup2], set) => {
    const nextConnections = connectionLookup2.get(`${currentNodeId}-${type}-${id || null}`);
    if (!areConnectionMapsEqual(nextConnections, prevConnections)) {
      prevConnections = nextConnections;
      set(Array.from((prevConnections == null ? void 0 : prevConnections.values()) || []));
    }
  }, initialConnections);
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodesData.js
function useNodesData(nodeIds) {
  const { nodes, nodeLookup } = useStore();
  let prevNodesData = [];
  return derived([nodes, nodeLookup], ([, nodeLookup2], set) => {
    var _a;
    const nextNodesData = [];
    const isArrayOfIds = Array.isArray(nodeIds);
    const _nodeIds = isArrayOfIds ? nodeIds : [nodeIds];
    for (const nodeId of _nodeIds) {
      const node = (_a = nodeLookup2.get(nodeId)) == null ? void 0 : _a.internals.userNode;
      if (node) {
        nextNodesData.push({
          id: node.id,
          type: node.type,
          data: node.data
        });
      }
    }
    if (!shallowNodeData(nextNodesData, prevNodesData)) {
      prevNodesData = nextNodesData;
      set(isArrayOfIds ? nextNodesData : nextNodesData[0] ?? null);
    }
  });
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useInternalNode.js
function useInternalNode(id) {
  const { nodeLookup, nodes } = useStore();
  return derived([nodeLookup, nodes], ([nodeLookup2]) => nodeLookup2.get(id));
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useInitialized.js
function useNodesInitialized() {
  const { nodesInitialized } = useStore();
  return {
    subscribe: nodesInitialized.subscribe
  };
}
function useInitialized() {
  const { initialized } = useStore();
  return {
    subscribe: initialized.subscribe
  };
}
export {
  Background_default as Background,
  BackgroundVariant,
  BaseEdge_default as BaseEdge,
  BezierEdge_default as BezierEdge,
  ConnectionLineType,
  ConnectionMode,
  ControlButton_default as ControlButton,
  Controls_default as Controls,
  EdgeLabel_default as EdgeLabel,
  EdgeLabelRenderer_default as EdgeLabelRenderer,
  Handle_default as Handle,
  MarkerType,
  Minimap_default as MiniMap,
  ResizeControl_default as NodeResizeControl,
  NodeResizer_default as NodeResizer,
  NodeToolbar_default as NodeToolbar,
  PanOnScrollMode,
  Panel_default as Panel,
  Position,
  SelectionMode,
  SmoothStepEdge_default as SmoothStepEdge,
  StepEdge_default as StepEdge,
  StraightEdge_default as StraightEdge,
  SvelteFlow_default as SvelteFlow,
  SvelteFlowProvider_default as SvelteFlowProvider,
  ViewportPortal_default as ViewportPortal,
  addEdge,
  getBezierEdgeCenter,
  getBezierPath,
  getConnectedEdges,
  getEdgeCenter,
  getIncomers,
  getNodesBounds,
  getOutgoers,
  getSmoothStepPath,
  getStraightPath,
  getViewportForBounds,
  isEdge,
  isNode,
  useConnection,
  useEdges,
  useHandleConnections,
  useInitialized,
  useInternalNode,
  useNodes,
  useNodesData,
  useNodesInitialized,
  useStore,
  useSvelteFlow,
  useUpdateNodeInternals
};
//# sourceMappingURL=@xyflow_svelte.js.map
