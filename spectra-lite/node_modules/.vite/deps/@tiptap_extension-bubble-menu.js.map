{
  "version": 3,
  "sources": ["../../@tiptap/extension-bubble-menu/src/bubble-menu-plugin.ts", "../../@tiptap/extension-bubble-menu/src/bubble-menu.ts"],
  "sourcesContent": ["import {\n  Editor, isNodeSelection, isTextSelection, posToDOMRect,\n} from '@tiptap/core'\nimport { EditorState, Plugin, PluginKey } from '@tiptap/pm/state'\nimport { EditorView } from '@tiptap/pm/view'\nimport tippy, { Instance, Props } from 'tippy.js'\n\nexport interface BubbleMenuPluginProps {\n  /**\n   * The plugin key.\n   * @type {PluginKey | string}\n   * @default 'bubbleMenu'\n   */\n  pluginKey: PluginKey | string\n\n  /**\n   * The editor instance.\n   */\n  editor: Editor\n\n  /**\n   * The DOM element that contains your menu.\n   * @type {HTMLElement}\n   * @default null\n   */\n  element: HTMLElement\n\n  /**\n   * The options for the tippy.js instance.\n   * @see https://atomiks.github.io/tippyjs/v6/all-props/\n   */\n  tippyOptions?: Partial<Props>\n\n  /**\n   * The delay in milliseconds before the menu should be updated.\n   * This can be useful to prevent performance issues.\n   * @type {number}\n   * @default 250\n   */\n  updateDelay?: number\n\n  /**\n   * A function that determines whether the menu should be shown or not.\n   * If this function returns `false`, the menu will be hidden, otherwise it will be shown.\n   */\n  shouldShow?:\n    | ((props: {\n        editor: Editor\n        element: HTMLElement\n        view: EditorView\n        state: EditorState\n        oldState?: EditorState\n        from: number\n        to: number\n      }) => boolean)\n    | null\n}\n\nexport type BubbleMenuViewProps = BubbleMenuPluginProps & {\n  view: EditorView\n}\n\nexport class BubbleMenuView {\n  public editor: Editor\n\n  public element: HTMLElement\n\n  public view: EditorView\n\n  public preventHide = false\n\n  public tippy: Instance | undefined\n\n  public tippyOptions?: Partial<Props>\n\n  public updateDelay: number\n\n  private updateDebounceTimer: number | undefined\n\n  public shouldShow: Exclude<BubbleMenuPluginProps['shouldShow'], null> = ({\n    view,\n    state,\n    from,\n    to,\n  }) => {\n    const { doc, selection } = state\n    const { empty } = selection\n\n    // Sometime check for `empty` is not enough.\n    // Doubleclick an empty paragraph returns a node size of 2.\n    // So we check also for an empty text size.\n    const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection)\n\n    // When clicking on a element inside the bubble menu the editor \"blur\" event\n    // is called and the bubble menu item is focussed. In this case we should\n    // consider the menu as part of the editor and keep showing the menu\n    const isChildOfMenu = this.element.contains(document.activeElement)\n\n    const hasEditorFocus = view.hasFocus() || isChildOfMenu\n\n    if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n      return false\n    }\n\n    return true\n  }\n\n  constructor({\n    editor,\n    element,\n    view,\n    tippyOptions = {},\n    updateDelay = 250,\n    shouldShow,\n  }: BubbleMenuViewProps) {\n    this.editor = editor\n    this.element = element\n    this.view = view\n    this.updateDelay = updateDelay\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler)\n    this.editor.on('focus', this.focusHandler)\n    this.editor.on('blur', this.blurHandler)\n    this.tippyOptions = tippyOptions\n    // Detaches menu content from its current parent\n    this.element.remove()\n    this.element.style.visibility = 'visible'\n  }\n\n  mousedownHandler = () => {\n    this.preventHide = true\n  }\n\n  dragstartHandler = () => {\n    this.hide()\n  }\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.editor.view))\n  }\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.preventHide) {\n      this.preventHide = false\n\n      return\n    }\n\n    if (event?.relatedTarget && this.element.parentNode?.contains(event.relatedTarget as Node)) {\n      return\n    }\n\n    if (\n      event?.relatedTarget === this.editor.view.dom\n    ) {\n      return\n    }\n\n    this.hide()\n  }\n\n  tippyBlurHandler = (event: FocusEvent) => {\n    this.blurHandler({ event })\n  }\n\n  createTooltip() {\n    const { element: editorElement } = this.editor.options\n    const editorIsAttached = !!editorElement.parentElement\n\n    this.element.tabIndex = 0\n\n    if (this.tippy || !editorIsAttached) {\n      return\n    }\n\n    this.tippy = tippy(editorElement, {\n      duration: 0,\n      getReferenceClientRect: null,\n      content: this.element,\n      interactive: true,\n      trigger: 'manual',\n      placement: 'top',\n      hideOnClick: 'toggle',\n      ...this.tippyOptions,\n    })\n\n    // maybe we have to hide tippy on its own blur event as well\n    if (this.tippy.popper.firstChild) {\n      (this.tippy.popper.firstChild as HTMLElement).addEventListener('blur', this.tippyBlurHandler)\n    }\n  }\n\n  update(view: EditorView, oldState?: EditorState) {\n    const { state } = view\n    const hasValidSelection = state.selection.from !== state.selection.to\n\n    if (this.updateDelay > 0 && hasValidSelection) {\n      this.handleDebouncedUpdate(view, oldState)\n      return\n    }\n\n    const selectionChanged = !oldState?.selection.eq(view.state.selection)\n    const docChanged = !oldState?.doc.eq(view.state.doc)\n\n    this.updateHandler(view, selectionChanged, docChanged, oldState)\n  }\n\n  handleDebouncedUpdate = (view: EditorView, oldState?: EditorState) => {\n    const selectionChanged = !oldState?.selection.eq(view.state.selection)\n    const docChanged = !oldState?.doc.eq(view.state.doc)\n\n    if (!selectionChanged && !docChanged) {\n      return\n    }\n\n    if (this.updateDebounceTimer) {\n      clearTimeout(this.updateDebounceTimer)\n    }\n\n    this.updateDebounceTimer = window.setTimeout(() => {\n      this.updateHandler(view, selectionChanged, docChanged, oldState)\n    }, this.updateDelay)\n  }\n\n  updateHandler = (view: EditorView, selectionChanged: boolean, docChanged: boolean, oldState?: EditorState) => {\n    const { state, composing } = view\n    const { selection } = state\n\n    const isSame = !selectionChanged && !docChanged\n\n    if (composing || isSame) {\n      return\n    }\n\n    this.createTooltip()\n\n    // support for CellSelections\n    const { ranges } = selection\n    const from = Math.min(...ranges.map(range => range.$from.pos))\n    const to = Math.max(...ranges.map(range => range.$to.pos))\n\n    const shouldShow = this.shouldShow?.({\n      editor: this.editor,\n      element: this.element,\n      view,\n      state,\n      oldState,\n      from,\n      to,\n    })\n\n    if (!shouldShow) {\n      this.hide()\n\n      return\n    }\n\n    this.tippy?.setProps({\n      getReferenceClientRect:\n        this.tippyOptions?.getReferenceClientRect\n        || (() => {\n          if (isNodeSelection(state.selection)) {\n            let node = view.nodeDOM(from) as HTMLElement\n\n            if (node) {\n              const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector('[data-node-view-wrapper]')\n\n              if (nodeViewWrapper) {\n                node = nodeViewWrapper.firstChild as HTMLElement\n              }\n\n              if (node) {\n                return node.getBoundingClientRect()\n              }\n            }\n          }\n\n          return posToDOMRect(view, from, to)\n        }),\n    })\n\n    this.show()\n  }\n\n  show() {\n    this.tippy?.show()\n  }\n\n  hide() {\n    this.tippy?.hide()\n  }\n\n  destroy() {\n    if (this.tippy?.popper.firstChild) {\n      (this.tippy.popper.firstChild as HTMLElement).removeEventListener(\n        'blur',\n        this.tippyBlurHandler,\n      )\n    }\n    this.tippy?.destroy()\n    this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler)\n    this.editor.off('focus', this.focusHandler)\n    this.editor.off('blur', this.blurHandler)\n  }\n}\n\nexport const BubbleMenuPlugin = (options: BubbleMenuPluginProps) => {\n  return new Plugin({\n    key:\n      typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n    view: view => new BubbleMenuView({ view, ...options }),\n  })\n}\n", "import { Extension } from '@tiptap/core'\n\nimport { BubbleMenuPlugin, BubbleMenuPluginProps } from './bubble-menu-plugin.js'\n\nexport type BubbleMenuOptions = Omit<BubbleMenuPluginProps, 'editor' | 'element'> & {\n  /**\n   * The DOM element that contains your menu.\n   * @type {HTMLElement}\n   * @default null\n   */\n  element: HTMLElement | null,\n}\n\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */\nexport const BubbleMenu = Extension.create<BubbleMenuOptions>({\n  name: 'bubbleMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      tippyOptions: {},\n      pluginKey: 'bubbleMenu',\n      updateDelay: undefined,\n      shouldShow: null,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return []\n    }\n\n    return [\n      BubbleMenuPlugin({\n        pluginKey: this.options.pluginKey,\n        editor: this.editor,\n        element: this.options.element,\n        tippyOptions: this.options.tippyOptions,\n        updateDelay: this.options.updateDelay,\n        shouldShow: this.options.shouldShow,\n      }),\n    ]\n  },\n})\n"],
  "mappings": "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",
  "names": ["view", "shouldShow"]
}
