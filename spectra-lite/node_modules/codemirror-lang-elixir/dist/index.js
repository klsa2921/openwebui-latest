import { LRLanguage, indentNodeProp, continuedIndent, delimitedIndent, flatIndent, foldNodeProp, foldInside, syntaxTree, getIndentUnit, getIndentation, indentString, LanguageSupport } from '@codemirror/language';
import { EditorSelection, Prec } from '@codemirror/state';
import { keymap } from '@codemirror/view';
import { parser } from 'lezer-elixir';

/**
A syntax provider based on the [Lezer Elixir parser](https://github.com/lezer-parser/elixir),
extended with highlighting and indentation information.
*/
const elixirLanguage = /*@__PURE__*/LRLanguage.define({
    name: "elixir",
    parser: /*@__PURE__*/parser.configure({
        props: [
            /*@__PURE__*/indentNodeProp.add({
                "DoBlock AfterBlock ElseBlock CatchBlock RescueBlock": /*@__PURE__*/withContinuedStabClause(/*@__PURE__*/continuedIndent({
                    except: /^\s*(after|else|catch|rescue|end)\b/,
                })),
                AnonymousFunction: /*@__PURE__*/withContinuedStabClause(/*@__PURE__*/delimitedIndent({ closing: "end", align: false })),
                Block: /*@__PURE__*/withContinuedStabClause(/*@__PURE__*/delimitedIndent({ closing: ")", align: false })),
                StabClause: /*@__PURE__*/continuedIndent(),
                List: /*@__PURE__*/delimitedIndent({ closing: "]", align: false }),
                Tuple: /*@__PURE__*/delimitedIndent({ closing: "}", align: false }),
                Bitstring: /*@__PURE__*/delimitedIndent({ closing: ">>", align: false }),
                Arguments: /*@__PURE__*/delimitedIndent({ closing: ")", align: false }),
                Map: /*@__PURE__*/delimitedIndent({ closing: "}", align: false }),
                "String Charlist Sigil": flatIndent,
                BinaryOperator: /*@__PURE__*/continuedIndent(),
                Pair: /*@__PURE__*/continuedIndent(),
            }),
            /*@__PURE__*/foldNodeProp.add({
                "DoBlock Block List Tuple Bitstring AnonymousFunction": foldInside,
                Map: foldMap,
            }),
        ],
    }),
    languageData: {
        commentTokens: { line: "#" },
        closeBrackets: {
            brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
            // Built-in sigils
            stringPrefixes: ["~s", "~S", "~r", "~R", "~c", "~C", "~D", "~N"],
        },
        indentOnInput: /^\s*([\}\]\)]|>>|after|else|catch|rescue|end)|.*->$/,
    },
});
function withContinuedStabClause(baseStrategy) {
    return (context) => {
        var _a, _b, _c, _d;
        const before = context.node.childBefore(context.pos);
        // If end is being introduced, use the top-level node indentation
        if (((_b = (_a = context.node.lastChild) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.name) === "end" &&
            context.textAfter.endsWith("end")) {
            return context.baseIndentFor(context.node);
        }
        // If a new stab clause is introduced, we give it the same indentation
        // as the previous one
        if (((_c = before === null || before === void 0 ? void 0 : before.type) === null || _c === void 0 ? void 0 : _c.name) === "StabClause" &&
            context.textAfter.endsWith("->")) {
            return context.baseIndentFor(before);
        }
        // If we are positioned right after a child stab clause, we keep
        // that stab clause's indentation
        if (((_d = before === null || before === void 0 ? void 0 : before.type) === null || _d === void 0 ? void 0 : _d.name) === "StabClause") {
            return context.baseIndentFor(before) + context.unit;
        }
        return baseStrategy(context);
    };
}
function foldMap(context) {
    const open = context.getChild("{");
    const close = context.getChild("}");
    if (open && close) {
        return { from: open.to, to: close.from };
    }
    else {
        return null;
    }
}

/**
This command, when invoked inside a do-block or an anonymous
function, inserts the closing end when applicable.
*/
const insertNewlineCloseEnd = (view) => {
    const { state, dispatch } = view;
    const tree = syntaxTree(state);
    const indentationUnit = getIndentUnit(state);
    let apply = true;
    const changes = state.changeByRange((range) => {
        if (!range.empty || !elixirLanguage.isActiveAt(state, range.from)) {
            apply = false;
            return { range };
        }
        const node = tree.resolve(range.from, -1);
        const parent = endDelimitedParent(node);
        if (parent && !checkAllClosed(parent)) {
            const indentation = getIndentation(state, parent.from + 1) || indentationUnit;
            const innerIndent = indentString(state, indentation);
            const outerIndent = indentString(state, indentation - indentationUnit);
            const insertPre = `\n${innerIndent}`;
            const insertPost = `\n${outerIndent}end`;
            const newPos = range.from + insertPre.length;
            return {
                range: EditorSelection.cursor(newPos),
                changes: [
                    { from: range.from, to: range.to, insert: insertPre + insertPost },
                ],
            };
        }
        apply = false;
        return { range };
    });
    if (apply) {
        dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
        return true;
    }
    else {
        return false;
    }
};
function endDelimitedParent(node) {
    let cur = node;
    if (cur && cur.type.name === "do") {
        cur = cur.parent;
    }
    if (cur && cur.type.name === "Operator") {
        cur = cur.parent;
    }
    if (cur && (cur.type.name === "StabClause" || cur.type.name === "fn")) {
        cur = cur.parent;
    }
    if (cur && isEndDelimited(cur)) {
        return cur;
    }
    else {
        return null;
    }
}
function isEndDelimited(node) {
    return node.type.name === "DoBlock" || node.type.name === "AnonymousFunction";
}
function checkAllClosed(node) {
    var _a, _b;
    let cur = node;
    while (cur) {
        if (isEndDelimited(cur)) {
            if (((_b = (_a = cur.lastChild) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.name) !== "end") {
                return false;
            }
        }
        cur = cur.parent;
    }
    return true;
}

const elixirKeymap = [{ key: "Enter", run: insertNewlineCloseEnd }];
/**
Elixir language support.
*/
function elixir() {
    const support = [Prec.high(keymap.of(elixirKeymap))];
    return new LanguageSupport(elixirLanguage, support);
}

export { elixir, elixirLanguage };
